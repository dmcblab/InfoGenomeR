diff --git a/Eulerian/DAG_entropy/main b/Eulerian/DAG_entropy/main
index 723a96a..33afcc5 100755
Binary files a/Eulerian/DAG_entropy/main and b/Eulerian/DAG_entropy/main differ
diff --git a/Eulerian/karyotyping b/Eulerian/karyotyping
index c5d0d75..98982a5 100755
--- a/Eulerian/karyotyping
+++ b/Eulerian/karyotyping
@@ -36,12 +36,16 @@ fi
 
 cd $out_dir
 iter=`ls -l | grep -E 'iter[1-9]?[0-9]?[0-9]$' | awk 'BEGIN{max=0}{split($9,f,"iter"); if(max<f[2]) max=f[2];}END{print max}'`
-mkdir InfoGenomeR_output/karyotypes
+mkdir -p InfoGenomeR_output/karyotypes
 cd iter$iter
 
 
 while read -r -a line;do
-	cd ${line[0]}
+	if [[ -s ${line[0]} ]];then
+		cd ${line[0]}
+	else
+		continue;
+	fi
 
 	all="F"
 	euler_library=$InfoGenomeR_lib/Eulerian/DAG_entropy
@@ -78,3 +82,5 @@ while read -r -a line;do
 	cp -r ${line[0]} ../InfoGenomeR_output/karyotypes
 done < euler.list
 
+cp euler.list ../InfoGenomeR_output/karyotypes
+
diff --git a/README.md b/README.md
index 000e779..4c6a68f 100644
--- a/README.md
+++ b/README.md
@@ -6,369 +6,73 @@
   </a>
 </p>
 
-# Requirements
-- Executables in your PATH
-    - bwa (version 0.7.15)
-    - samtools (version 1.3)
-    - bedtools (version 1.3)
-    - blat (version 36)
-    - blastn (version 2.2.30+)
-- R (version 3.4.3) and libraries
-    - lpSolveAPI (version 5.5.2.0.17)
-    - ABSOLUTE (version 1.0.6)
-    - fitdistrplus (version 1.1.11)
-    - plyr (version 1.8.4)
-    - plotrix (version 3.7)
-- BIC-seq2 (version 0.7.2)
-# Environment settings
-- download InfoGenomeR and BIC-seq2 in your working directory. 
+# Snakemake install
+- The InfoGenomeR workflow is run by the snakemake.
+- Environments are described in workflow/envs.
+- Rules are described in workflow/Snakefile.
 ```
-## For example, the working directory is /home/dmcblab.
-cd /home/dmcblab
-#### Download InfoGenomeR
-git clone https://github.com/dmcblab/InfoGenomeR.git
-#### Download BIC-seq2
-wget http://compbio.med.harvard.edu/BIC-seq/NBICseq-seg_v0.7.2.tar.gz
-tar -xvf NBICseq-seg_v0.7.2.tar.gz
+wget https://github.com/conda-forge/miniforge/releases/download/24.1.2-0/Miniforge3-Linux-x86_64.sh
+bash Miniforge3-Linux-x86_64.sh
+mamba create -c conda-forge -c bioconda -n snakemake snakemake
+conda config --set channel_priority strict
+conda activate snakemake
 ```
-- download repeatmasker files.
-```
-#### Get repeatmastker files
-cd InfoGenomeR/humandb
-wget https://zenodo.org/record/5112761/files/GRCh37.repeatmasker.xz
-xz -d GRCh37.repeatmasker.xz
-wget https://zenodo.org/record/5112761/files/GRCh38.repeatmasker.xz
-xz -d GRCh38.repeatmasker.xz
-cd ../../
-```
-- download haplotype DAGs and bwa-indexed reference genome (GRCh37 or GRCh38).
-```
-## GRCh37
-wget https://zenodo.org/record/5105505/files/GRCh37.tar.xz
-tar Jxvf GRCh37.tar.xz
-wget https://zenodo.org/record/5105505/files/haplotype_1000G.tar.xz
-tar Jxvf haplotype_1000G.tar.xz
-
-## GRCh38
-wget https://zenodo.org/record/5105505/files/GRCh38.tar.xz
-tar Jxvf GRCh38.tar.xz
-wget https://zenodo.org/record/5105505/files/haplotype_1000G_GRCh38.tar.xz
-tar Jxvf haplotype_1000G_GRCh38.tar.xz
-```
-- set the BIC-seq2 path, InfoGenomeR_lib, and Haplotype path.
-```
-export BICseq2_path=/home/dmcblab/NBICseq-seg_v0.7.2
-export InfoGenomeR_lib=/home/dmcblab/InfoGenomeR
-export Haplotype_path=/home/dmcblab/haplotype_1000G ## for GRCh37. If GRCh38 was used, export Haplotype_path=/home/dmcblab/haplotype_1000G_38
-export Ref_version=GRCh37 ## for GRCh37. export Ref_version=GRCh38 for GRCh38.
-```
-- set executables (bwa, samtools ...) in your PATH. You may use precompiled binaries in the InfoGenomeR/ext folder if they work in your computer. Otherwise, please install them.
-```
-export PATH=$InfoGenomeR_lib/ext:$PATH
-```
-- set the PATH environment.
-```
-export PATH=$InfoGenomeR_lib/breakpoint_graph:$InfoGenomeR_lib/allele_graph:$InfoGenomeR_lib/haplotype_graph:$InfoGenomeR_lib/Eulerian:$PATH
-```
-
-# Inputs
-- genome-binning read depths (cn_norm, cn_norm_germ)
-- Initial SV calls (delly.format, manta.format, novobreak.format)
-- Non-properly paired reads (NPE.fq1, NPE.fq2)
-- Reference genome (GRCh37.fa, .fa.fai, .2bit, .bwt2) or (GRCh38.fa,.fa.fai, .2bit, .bwt2)
-- SNP calls (het_snps.format, hom_snps.format)
-- Haplotype DAGs (haplotype_1000G) or (haplotype_1000G_GRCh38)
-
-# Outputs
-- Haplotype-resolved SVs and CNAs (SVs.CN_opt.phased, copy_number.CN_opt.phased)
-- Haplotypes (haplotype)
-- Purity and ploidy (purity_ploidy)
-- Haplotype graph (node_keys, edge_information.txt)
-- Karyotypes (Eulerian_path.0)
-- SV cluster and topology (cluster_sv)
-
-# Running InfoGenomeR
-- Breakpoint graph construction
-```
-Usage: breakpoint_graph <SVs> <cn_norm> [options]
-
-Options:
-        -m, --mode (required)
-                 Select the mode (germline, total, somatic, simplification)
-        -e, --simple_length
-                 simplifying SVs shorter than simple_length for the simplification mode (default: 100000)
-        -i, --lambda_ini (required)
-                 Initial lambda for the first round iterations (default: 1)
-        -f, --lambda_fi (required)
-                 Final lambda for the second round iterations (default: 4)
-        -t, --cancer_type (optional)
-                 Cancer type used for ABSOLUTE estimation (BRCA, GBM, OV, ...). If unknown, write null.
-        -n, --min_ploidy (optional)
-                 minimum cancer ploidy used for ABSOLUTE estimation (default: 1.5)
-        -x, --max_ploidy (optional)
-                 maximum cnacer ploidy used for ABSOLUTE estimation (default: 5)
-        -d, --npe_dir (optional)
-                 Directory that contains NPE.fq1 and NPE.fq2 (non-properly paired reads). If it is not assigned, InfoGenomeR runs without NP reads mapping.
-        -g, --ref_genome (required for NP reads mapping)
-                 Fasta prefix (hg19 or hg38). Enter the prefix without .2bit and .fa extension.
-        -c, cn_norm_germ (required for somatic mode)
-                 Directory that contains copy number bins from a control genome.
-        -s, --germ_LocSeq_result (required for somatic mode)
-                 Local segmentation results from a control genome.
-        -s, --stringent
-                 stringent condition for low-confidence regions (default: F). turn off if the graph simplification will be applied.
-        -o, --out_dir
-                 If it already exists, results are overlaid (default: InfoGenomeR_job)
-        -h, --help
-```
-- Allele-specific graph construction
-```
-Usage: allele_graph <hom_snps.format> <het_snps.format> [options]
-
-Options:
-        -m, --mode (required)
-                 Select the mode (germline, total, somatic)
-        -s, --germ_LocSeq_result (required for somatic mode)
-                 Local segmentation results from a control genome.
-        -g, --ref_genome (required for NP reads mapping)
-                 Fasta prefix (hg19 or hg38). Enter the prefix without .2bit and .fa extension.
-        -o, --breakpoint_graph_dir
-                 The output directory of breakpoint graph construction
-        -t, --threads
-                 The number of threads
-        -h, --help
-```
-- Haplotype graph construction
-```
-Usage: haplotype_graph [options]
 
-        -o, --allele_graph_dir
-                 The output directory of allele graph construction
-        -t, --threads
-                 The number of threads
-        -h, --help
-```
-- Karyotyping
-```
-Usage: karyotyping [options]
-        -o, --breakpoint_graph_dir
-                 The output directory of breakpoint graph construction
-        -h, --help
-```
-# How to generate inputs from BAM
-- We provide scripts for generating inputs using BIC-seq2, DELLY2, Manta, and novobreak, but we recommend that a user follow the guideline of each tool.
-- Generate cn_norm and cn_norm_germ.
-    - Install BICseq2 and modifiedSamtools.
-    - Set configs in the script `bicseq_preprocess.sh` and run the script for cn_norm.
-    - Set configs in the script `bicseq_preprocess_germ.sh` and run the script for cn_norm_germ.
-```
-reference=hg19.fa
-norm_script=./NBICseq-norm_v0.2.4/NBICseq-norm.pl
-map_file=./NBICseq-norm_v0.2.4/hg19.CRG.50bp
-read_length=100
-fragment_size=350
-tumor_bam=tumor.bam
-```
- `./preprocessing/bicseq_preprocess.sh`
-        
- ```
-reference=hg19.fa
-norm_script=./NBICseq-norm_v0.2.4/NBICseq-norm.pl
-map_file=./NBICseq-norm_v0.2.4/hg19.CRG.50bp
-read_length=100
-fragment_size=350
-normal_bam=normal.bam
-```
-`./preprocessing/bicseq_preprocess_germ.sh`
-- Generate NPE.fq1 and NPE.fq2
-```
-samtools view -h -F 2 -b simulated_sorted.bam >simulated_sorted_NPE.bam
-samtools sort -n simulated_sorted_NPE.bam > simulated_sorted_NPE_sorted.bam
-bamToFastq  -i simulated_sorted_NPE_sorted.bam  -fq NPE.fq1 -fq2 NPE.fq2
-```
-- Generate delly SV calls (delly.format).
-    - Install DELLY2, set configs, and run the script.
-```
-ref=hg19.fa
-tsv=samples.tsv
-tumor_bam=tumor.bam
-normal_bam=normal.bam
-```
-`./preprocessing/delly_somatic.sh 3 20`
-- Generate manta SV calls (manta.format).
-    - Install Manta, set configs, and run the script.
-```
-reference=hg19.fa
-script1=./manta-1.1.0.centos5_x86_64/bin/configManta.py
-script2=./runWorkflow.py
-normal_bam=normal.bam
-tumor_bam=tumor.bam
+# Dataset download
 ```
-`./preprocessing/manta_somatic.sh`
-- Generate novobreak SV calls (novobreak.format).
-    - Install novobreak and copy the scripts `./preprocessing/run_novoBreak_orient_partial_corrected.sh` and `./preprocessing/infer_sv_orientation.pl` to the novobreak-installed folder.
-    - Set configs, and run the script.
+snakemake --cores all --use-conda InfoGenomeR_download
 ```
-novo_dir=./novoBreak_distribution_v1.1.3rc
-reference=hg19.fa
-tumor_bam=tumor.bam
-normal_bam=normal.bam
+# Conda environment setting
 ```
-`./preprocessing/novobreak_somatic.sh`
-- Generate SNP calls (het_snps.format and hom_snps.format).
-    - Set configs and run the script.
+snakemake --core all --use-conda InfoGenomeR_env
 ```
-reference=hg19.fa
-normal_bam=normal.bam
-tumor_bam=tumor.bam
-```
-`./preprocessing/het_SNP_detection_somatic.sh`
- 
-# Tutorials
-- Download tutorial files. Tutorial files contains input files for InfoGenomeR. 
-- Tutorial 1:Germline and somatic mode (GRCh37). a simiulated cancer genome (haplotype coverage 5X, triploidy, purity 75%) that has 162 somatic SVs (true_SV_sets_somatic). [Tutorial_1](https://zenodo.org/record/5105505/files/tutorial1.tar.xz).
-- Tutorial 2:Somatic mode (GRCh38). a simiulated cancer genome (haplotype coverage 10X, triploidy, purity 75%). [Tutorial_2](https://zenodo.org/record/4545666/files/GRCh38.triploidy.f10.p0.75.tar.xz)
-- Tutorial 3:Total mode, graph simpification, and karyotyping (GRCh37). T47D breast cancer cell line (SRR5371367).
 
-# Tutorial 1 (GRCh37)
-```
-wget https://zenodo.org/record/5105505/files/tutorial1.tar.xz
-tar Jxvf tutorial1.tar.xz
-cd tutorial1
-cp $InfoGenomeR_lib/etc/SV_performance.R ./
-```
-- Check baselines for SVs.
-```
-## delly
-Rscript SV_performance.R delly.format true_SV_sets_somatic
-precision:0.690217 recall:0.798742 fmeasure: 0.740525
-## manta
-Rscript SV_performance.R manta.format true_SV_sets_somatic
-precision:0.949580 recall:0.710692 fmeasure: 0.812950
-## novobreak
-Rscript SV_performance.R novobreak.format true_SV_sets_somatic
-precision:0.902174 recall:0.496855 fmeasure: 0.640801
+# InfoGenomeR workflow
+Take a low coverage example (~50G)
 ```
-- Running InfoGenomeR.
+snakemake --core all --use-conda InfoGenomeR_example_download
 ```
-## Generate a germline copy number profile
-breakpoint_graph -m germline germline_delly.format -o germline_job cp_norm_germ
-cp germline_job/copy_numbers ./copy_numbers.control
-
-## Merge SV calls.
-cat delly.format manta.format novobreak.format > SVs
-## breakpoint graph construction
-breakpoint_graph -m somatic -d ./ SVs ./cp_norm -g /home/dmcblab/GRCh37/GRCh37 -c cp_norm_germ -s copy_numbers.control -o somatic_job --stringent T
-## allele graph construction
-allele_graph -m somatic -s copy_numbers.control hom_snps.format het_snps.format -o somatic_job -g /home/dmcblab/GRCh37/GRCh37 -t 23
-## haplotype graph construction
-haplotype_graph -o somatic_job -t 6 ## 40GB memory per one thread (total about 256GB). Do not exceed the maximum memory.
+## Set a workspace
 ```
-It takes a few hours during three iterations and outputs SVs, copy numbers and a breakpoint graph at the haplotype level.
+# go to the InfoGenomeR base directory
+cd InfoHiC
 
-- Check performance for SV calls from InfoGenomeR.
-```
-## The output directory is InfoGenomeR_output
-Rscript SV_performance.R somatic_job/InfoGenomeR_output/SVs.CN_opt.phased true_SV_sets_somatic
-precision:0.955224 recall:0.805031 fmeasure: 0.873720
-```
+# make a workspace directory
+workspace_dir=InfoGenomeR_workspace1
+mkdir -p ${workspace_dir}
 
-# Tutorial 2 (GRCh38)
-```
-wget https://zenodo.org/record/4545666/files/GRCh38.triploidy.f10.p0.75.tar.xz
-tar Jxvf GRCh38.triploidy.f10.p0.75.tar.xz
-cd GRCh38.triploidy.f10.p0.75 
-cp $InfoGenomeR_lib/etc/SV_performance.R ./
-### Change the environment to GRCh38.
-export Haplotype_path=/home/dmcblab/haplotype_1000G_GRCh38
-export Ref_version=GRCh38
-```
-- Check baselines for SVs.
-```
-Rscript SV_performance.R delly.format ./simulated_genome/true_SV_sets_somatic_dup_checked.refcoor
-precision:0.869110 recall:0.775701 fmeasure: 0.819753
-Rscript SV_performance.R manta.format ./simulated_genome/true_SV_sets_somatic_dup_checked.refcoor
-precision:0.935897 recall:0.738318 fmeasure: 0.825449
-Rscript SV_performance.R novobreak.format ./simulated_genome/true_SV_sets_somatic_dup_checked.refcoor
-precision:0.937500 recall:0.532710 fmeasure: 0.679380
-```
-- Running InfoGenomeR.
-```
-## Merge SV calls.
-cat delly.format manta.format novobreak.format > SVs
-## breakpoint graph construction
-breakpoint_graph -m somatic -d ./ SVs ./cp_norm -g /home/dmcblab/GRCh38/GRCh38 -c cp_norm_germ -s copy_numbers.control -o somatic_job --stringent T
-## allele graph construction
-allele_graph -m somatic -s copy_numbers.control hom_snps.format het_snps.format -o somatic_job -g /home/dmcblab/GRCh38/GRCh38 -t 23
-## haplotype graph construction
-haplotype_graph -o somatic_job -t 6 ## 40GB memory per one thread ( total about 256GB). Do not exceed the maximum memory.
-```
-- Check performance for SV calls from InfoGenomeR.
-```
-## The output directory is InfoGenomeR_output
-Rscript SV_performance.R somatic_job/InfoGenomeR_output/SVs.CN_opt.phased ./simulated_genome/true_SV_sets_somatic_dup_checked.refcoor
-precision:0.971910 recall:0.808411 fmeasure: 0.882653
-```
-# Tutorial 3
-```
-wget https://zenodo.org/record/5719772/files/tutorial3.tar.gz
-tar -xvf tutorial3.tar.gz
-cd tutorial3
+# link the reference in the workspace directory
+ln -s ${PWD}/humandb/ref ${workspace_dir}/ref
 ```
-- Running InfoGenomeR.
+## Starting from fastq
+Take the low coverage example in examples/fastq
+### Inputs should be located in the workspace
+  - fastq/normal1.fq.gz (optional for somatic)
+  - fastq/normal2.fq.gz (optional for somatic)
+  - fastq/tumor1.fq.gz
+  - fastq/tumor2.fq.gz
 ```
-## breakpoint graph construction (It takes a day during about 30 iterations)
-breakpoint_graph -m total SVs cn_norm/ -i 16 -f 2000 -o total_job -t BRCA
-breakpoint_graph -m simplification -o total_job -i 16 -f 2000 total_job/SVs total_job/cn_norm/ -t BRCA
-## allele graph construction
-allele_graph -m total -g /DASstorage6/home/dmcblab/GRCh37/GRCh37 -o total_job -t 23 hom_snps.format het_snps.format
-## haplotype graph construction
-haplotype_graph -o total_job -t 6
-## Find Eulerian paths with a minimum entropy
-karyotyping -o total_job
+ln -s ${PWD}/examples/fastq ${workspace_dir}/fastq
 ```
-- It outputs files in total_job/InfoGenomeR_output
-	- copy_number.CN_opt.phased
-	- haplotype
-	- karyotypes
-	- purity_ploidy
-	- SVs.CN_opt.phased
-
-
-- Visualizing the haplotype graph.
+Then, go to [InfoGenomeR run](#infogenomer-run)
+## Starting from bam
+### Inputs should be located in the workspace 
+Here, the bam folder would be yours, which should be named as below.
+  - bam/tumor_sorted.bam
+  - bam/normal_sorted.bam
 ```
-### Visualize the haplotype graph. The total_job_test folder has outputs by pre-run.
-cd total_job_test/InfoGenomeR_output
-Rscript $InfoGenomeR_lib/etc/graph_plot.R # It generates ACN.pdf
+ln -s bam ${workspace_dir}/bam
 ```
-<p align="center">
-    <img width="700" src="https://github.com/YeonghunL/InfoGenomeR/blob/master/doc/InfoGenomeR_output/ACN.png">
-  </a>
-</p>
-
-- Visualizing karyotypes
-
+Then, go to [InfoGenomeR run](#infogenomer-run)
+## InfoGenomeR run
+Select either somatic or total mode
+### Somatic run 
 ```
-### chromosomes 8 and 14
-cd karyotypes/
-cd euler.8.14
-Rscript $InfoGenomeR_lib/etc/chromosomes_graph.R # It generates karyotypes.pdf
+# Run the InfoGenomeR workflow. The example is triploidy
+snakemake --core all --use-conda ${workspace_dir}/InfoGenomeR_output --config mode=somatic min_ploidy=2.5 max_ploidy=3.5 
 ```
-<p align="center">
-    <img width="280" src="https://github.com/YeonghunL/InfoGenomeR/blob/master/doc/InfoGenomeR_output/euler.8.14/karyotypes.png">
-  </a>
-</p>
-
-
+### Total run
 ```
-### chromosomes 3,5,10,12, and 20
-cd ../
-cd euler.3.5.10.12.20
-Rscript $InfoGenomeR_lib/etc/chromosomes_graph.R # It generates karyotypes.pdf
+snakemake --core all --use-conda ${workspace_dir}/InfoGenomeR_output --config mode=total min_ploidy=2.5 max_ploidy=3.5 
 ```
-<p align="center">
-    <img width="1700" src="https://github.com/YeonghunL/InfoGenomeR/blob/master/doc/InfoGenomeR_output/euler.3.5.10.12.20/karyotypes.png">
-  </a>
-</p>
-
 
diff --git a/allele_graph/ACN_estimation.R b/allele_graph/ACN_estimation.R
index f35bc53..6645c47 100644
--- a/allele_graph/ACN_estimation.R
+++ b/allele_graph/ACN_estimation.R
@@ -50,6 +50,10 @@ if(prefiltered_or_not=="T"){
         SNP=read.table("het_snps.format", stringsAsFactors=F)
 }
 
+low_coverage=T
+if(mean(SNP[,8]+SNP[,9])>20){
+	low_coverage=F
+}
 
 SNP[SNP[,1]=="X",1]<-23
 
@@ -91,6 +95,10 @@ MAX_DEPTH_multiple=Inf;
 minimum_snp=5;
 min_het_snp_density=1e-5;
 min_nm_p=0.0001;
+if(low_coverage){
+	min_het_snp_density=1e-6;
+	min_nm_p=1e-6;
+}
 min_seg=1e5;
 min_conf_seg=1e6;
 min_probe=100;
@@ -182,6 +190,7 @@ for(CN_i in 1:nrow(CN)){
 		
 ############
 #                if(nrow(t)>=minimum_snp && nrow(t) / (CN[CN_i,"End.bp"] - CN[CN_i,"Start.bp"]) > min_het_snp_density){
+
                 if(nrow(t)>=minimum_snp && p_val > min_nm_p && nrow(t) < CN[CN_i,"Probes"] && abs(nrow(t) / (CN[CN_i,"End.bp"] - CN[CN_i,"Start.bp"])) > min_het_snp_density){    ####### remove hyper mutation 
 
 #################
diff --git a/allele_graph/SNP_phasing_decision_boundary_ver_with_homozygous.R b/allele_graph/SNP_phasing_decision_boundary_ver_with_homozygous.R
index 618fc08..0e5c593 100644
--- a/allele_graph/SNP_phasing_decision_boundary_ver_with_homozygous.R
+++ b/allele_graph/SNP_phasing_decision_boundary_ver_with_homozygous.R
@@ -1,9 +1,17 @@
 args=commandArgs(T)
+prefiltered=args[2]
 #SNP=read.table("SNP.format", stringsAsFactors=F)
-SNP=read.table("het_snps.format.filtered",stringsAsFactors=F);
-SNP=cbind(SNP,V10=NA, V11=NA, V12=NA);
+if(prefiltered=="T"){
+        SNP=read.table("het_snps.format.filtered", stringsAsFactors=F)
+	SNP_hom = read.table("hom_snps.format.filtered", stringsAsFactors=F);
+}else{  
+        SNP=read.table("het_snps.format", stringsAsFactors=F)
+	SNP_hom = read.table("hom_snps.format", stringsAsFactors=F);
+}
 
-SNP_hom = read.table("hom_snps.format.filtered", stringsAsFactors=F);
+
+SNP=cbind(SNP,V10=NA, V11=NA, V12=NA);
+#SNP_hom = read.table("hom_snps.format.filtered", stringsAsFactors=F);
 SNP_hom = cbind(SNP_hom, V10=NA, V11=NA, V12=NA);
 CN_ACN=read.table("copy_numbers.CN_opt.ACN", header=T,  stringsAsFactors=F)
 SNP_phased=data.frame()
diff --git a/allele_graph/allele_graph b/allele_graph/allele_graph
index f98752c..686460b 100755
--- a/allele_graph/allele_graph
+++ b/allele_graph/allele_graph
@@ -111,28 +111,32 @@ fi
 cd $out_dir
 iter=`ls -l | grep -E 'iter[1-9]?[0-9]?[0-9]$' | awk 'BEGIN{max=0}{split($9,f,"iter"); if(max<f[2]) max=f[2];}END{print max}'`
 
-echo -n "" > exclude
+if [[ -s exclude.bed ]];then
+       echo "exclude.bed from simplification job"
+else
+	echo -n "" > exclude.bed
+fi
 if [[ $mode == "somatic" ]];then
-        cat $germ_LocSeq_result | awk '{if($6 < -0.5 || $6 > 0.3 ) print $2"\t"$3"\t"$4}' > exclude
+        cat $germ_LocSeq_result | awk '{if($6 < -0.5 || $6 > 0.3 ) print $2"\t"$3"\t"$4}' >> exclude.bed
 fi
 
-final_iter=$(($iter -1 ));
+#final_iter=$(($iter -1 ));
 
-for i in `seq 1 $final_iter`;do
-        if [[ -s iter$i\/exclude ]];then
-                cat iter$i\/exclude >> exclude
-        fi
-done
+#for i in `seq 1 $final_iter`;do
+#        if [[ -s iter$i\/exclude ]];then
+#                cat iter$i\/exclude >> exclude
+#        fi
+#done
 
 cd iter$iter
 echo "tagging homologous recombinations..."
 $library/HR_tag $library $ref;
 
-cp ../exclude ./
+cp ../exclude.bed ./
 cp $hom ./hom_snps.format
 cp $het ./het_snps.format
 echo "ACN estimation..."
-if [[ -s exclude ]];then
+if [[ -s exclude.bed ]];then
 	Rscript $library/snps_remove.R
 	$library/ACN_estimation $library T $haplotype_path $thread
 else
@@ -140,7 +144,11 @@ else
 fi
 
 echo "Imbalanced SNPs phasing..."
-Rscript $library/SNP_phasing_decision_boundary_ver_with_homozygous.R $haplotype_path
+if [[ -s het_snps.format.filtered ]];then
+	Rscript $library/SNP_phasing_decision_boundary_ver_with_homozygous.R $haplotype_path T
+else
+        Rscript $library/SNP_phasing_decision_boundary_ver_with_homozygous.R $haplotype_path F
+fi
 echo "genotype formatting..."
 Rscript $library/genotype_format_for_popul_phasing.R  $haplotype_path
 echo "Allele-specific graph construction is finished"
diff --git a/allele_graph/snps_remove.R b/allele_graph/snps_remove.R
index 6195839..dec50f4 100644
--- a/allele_graph/snps_remove.R
+++ b/allele_graph/snps_remove.R
@@ -1,6 +1,6 @@
 snp=read.table("het_snps.format",stringsAsFactors=F)
 
-t=read.table("exclude", stringsAsFactors=F)
+t=read.table("exclude.bed", stringsAsFactors=F)
 remove=c();
 for(i in 1:nrow(t)){
 	c=which(snp$V1==t[i,1] & snp$V2 < t[i,3] & snp$V2 > t[i,2]);
@@ -17,7 +17,7 @@ write.table(snp,"het_snps.format.filtered", quote=F, col.names=F, row.names=F, s
 
 snp = read.table("hom_snps.format",stringsAsFactors=F);
 
-t=read.table("exclude", stringsAsFactors=F)
+t=read.table("exclude.bed", stringsAsFactors=F)
 remove=c();
 for(i in 1:nrow(t)){
         c=which(snp$V1==t[i,1] & snp$V2 < t[i,3] & snp$V2 > t[i,2]);
diff --git a/breakpoint_graph/SV_local_CN_segment_wgs_raw.R b/breakpoint_graph/SV_local_CN_segment_wgs_raw.R
index 43c2e0c..648309c 100644
--- a/breakpoint_graph/SV_local_CN_segment_wgs_raw.R
+++ b/breakpoint_graph/SV_local_CN_segment_wgs_raw.R
@@ -9,7 +9,7 @@ min_seg_length=1e3;
 min_log_diff=0;
 min_marker=0;
 bicseq_bin_size=100;
-library(DNAcopy)
+#library(DNAcopy)
 
 my.merge<-function(x){
 	i<-1
diff --git a/breakpoint_graph/SV_local_CN_segment_wgs_raw_somatic.R b/breakpoint_graph/SV_local_CN_segment_wgs_raw_somatic.R
index 92f10f8..7734855 100644
--- a/breakpoint_graph/SV_local_CN_segment_wgs_raw_somatic.R
+++ b/breakpoint_graph/SV_local_CN_segment_wgs_raw_somatic.R
@@ -23,7 +23,6 @@ min_seg_length=1e3;
 min_log_diff=0;
 min_marker=0;
 bicseq_bin_size=100;
-library(DNAcopy)
 
 germ_remove<-function(x){
         j=2;
diff --git a/breakpoint_graph/breakpoint_graph b/breakpoint_graph/breakpoint_graph
index 12106de..fa73b86 100755
--- a/breakpoint_graph/breakpoint_graph
+++ b/breakpoint_graph/breakpoint_graph
@@ -217,7 +217,6 @@ else
 fi
 
 
-
 SV=SVs
 i=1;
 iter=1;
@@ -231,7 +230,7 @@ if [ $mode == "germline" ];then
 	tmp_folder="$PWD/tmp/"
         Rscript $library/SV_local_CN_segment_wgs_raw.R $SV $i $bin $tmp_folder $bicseq $lambda_ini $bam $chr_prefix;
 	rm -rf tmp;
-	exit 1
+	exit 0
 fi
 
 
@@ -312,7 +311,6 @@ else
         bin="$PWD/cn_norm_simple/"
         normal_bin="$PWD/cn_norm_germ_simple/"
 
-
 	iter=`ls -l  | awk '{print $9}'|  grep -P '^iter[1-9][0-9]{0,2}$' | awk 'BEGIN{max=0}{split($1,f,"iter"); if(max<f[2]) max=f[2];}END{print max}'`
 	min_simplifying_iter=`cat itr.log |  grep -P '^iter[1-9][0-9]{0,2}.block_clusters$' |  awk 'BEGIN{min=999}{split($1,f,"iter"); split(f[2],g,".block_clusters"); if(min>g[1]) min=g[1];}END{print min}'`
 	cd iter$iter;
@@ -428,3 +426,7 @@ do
 		break;
 	fi
 done
+
+if [[ $mode == "simplification" ]];then
+	cat iter*/exclude > exclude.bed
+fi
diff --git a/breakpoint_graph/breakpoint_graph_simple_SVs b/breakpoint_graph/breakpoint_graph_simple_SVs
index e9d9bfb..42577e1 100755
--- a/breakpoint_graph/breakpoint_graph_simple_SVs
+++ b/breakpoint_graph/breakpoint_graph_simple_SVs
@@ -166,7 +166,11 @@ SV_l1=`cat complex_SV | wc -l`
 SV_l2=`cat SVs | wc -l`
 if [ $SV_l1 -eq $SV_l2 ];then
         cd ../
-        exit 1
+        cp -r $bin cn_norm_simple
+	if [[ $mode == "somatic" ]];then
+		cp -r $normal_bin cn_norm_germ_simple
+	fi
+        exit 0
 fi
 if [ $mode == "somatic" ];then
         Rscript $library/simple_filter_cn_remove.R $bin $normal_bin
diff --git a/ext/ABSOLUTE_1.0.6.tar.gz b/ext/ABSOLUTE_1.0.6.tar.gz
new file mode 100755
index 0000000..5a48f22
Binary files /dev/null and b/ext/ABSOLUTE_1.0.6.tar.gz differ
diff --git a/ext/nbicseq-norm_v0.2.4.tar.gz b/ext/nbicseq-norm_v0.2.4.tar.gz
new file mode 100644
index 0000000..0ffe968
Binary files /dev/null and b/ext/nbicseq-norm_v0.2.4.tar.gz differ
diff --git a/ext/nbicseq-seg_v0.7.2.tar.gz b/ext/nbicseq-seg_v0.7.2.tar.gz
new file mode 100644
index 0000000..fa6e516
Binary files /dev/null and b/ext/nbicseq-seg_v0.7.2.tar.gz differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3.tar.gz b/ext/samtools-0.1.7a_getUnique-0.1.3.tar.gz
new file mode 100644
index 0000000..53caaab
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3.tar.gz differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/AUTHORS b/ext/samtools-0.1.7a_getUnique-0.1.3/AUTHORS
new file mode 100644
index 0000000..435431c
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/AUTHORS
@@ -0,0 +1,16 @@
+Heng Li from the Sanger Institute wrote most of the initial source codes
+of SAMtools and various converters.
+
+Bob Handsaker from the Broad Institute is a major contributor to the
+SAM/BAM specification. He designed and implemented the BGZF format, the
+underlying indexable compression format for the BAM format. BGZF does
+not support arithmetic between file offsets.
+
+Jue Ruan for the Beijing Genome Institute designed and implemented the
+RAZF format, an alternative indexable compression format. RAZF supports
+arithmetic between file offsets, at the cost of increased index file
+size and the full compatibility with gzip. RAZF is optional and only
+used in `faidx' for indexing RAZF compressed fasta files.
+
+Colin Hercus updated novo2sam.pl to support gapped alignment by
+novoalign.
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/COPYING b/ext/samtools-0.1.7a_getUnique-0.1.3/COPYING
new file mode 100644
index 0000000..82fa2f4
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/COPYING
@@ -0,0 +1,21 @@
+The MIT License
+
+Copyright (c) 2008-2009 Genome Research Ltd.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/ChangeLog b/ext/samtools-0.1.7a_getUnique-0.1.3/ChangeLog
new file mode 100644
index 0000000..6b1a695
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/ChangeLog
@@ -0,0 +1,3041 @@
+------------------------------------------------------------------------
+r509 | lh3lh3 | 2009-11-06 09:17:09 -0500 (Fri, 06 Nov 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-22 (r509)
+ * forget to fix a similar problem in glfgen
+
+------------------------------------------------------------------------
+r508 | lh3lh3 | 2009-11-06 09:06:40 -0500 (Fri, 06 Nov 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.6-21 (r508)
+ * fixed a potential bug in the indel caller towards the end of a chromosome
+
+------------------------------------------------------------------------
+r494 | lh3lh3 | 2009-10-26 11:38:00 -0400 (Mon, 26 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.6-19 (r494)
+ * allow to convert Illumina quality (64 based) to the BAM quality
+
+------------------------------------------------------------------------
+r493 | lh3lh3 | 2009-10-26 10:24:39 -0400 (Mon, 26 Oct 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam_header.c
+
+ * samtools-0.1.6-18 (r493)
+ * fixed the bugs due to improperly incorporating Petr's header parser
+ * a little code clean up in sam_header.c
+
+------------------------------------------------------------------------
+r492 | petulda | 2009-10-24 09:43:25 -0400 (Sat, 24 Oct 2009) | 1 line
+Changed paths:
+   M /trunk/samtools/sam_header.c
+
+Added sam_header_line_free call for sam_header_parse2
+------------------------------------------------------------------------
+r491 | lh3lh3 | 2009-10-24 00:50:16 -0400 (Sat, 24 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/sam_view.c
+
+ * BUGGY VERSION
+ * fixed a minor bug
+
+------------------------------------------------------------------------
+r490 | lh3lh3 | 2009-10-24 00:45:12 -0400 (Sat, 24 Oct 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/sam.c
+
+ * BUGGY VERSION
+ * improved the interface a bit
+ * bug unfixed
+
+------------------------------------------------------------------------
+r489 | lh3lh3 | 2009-10-24 00:41:50 -0400 (Sat, 24 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/sam_header.c
+   M /trunk/samtools/sam_header.h
+
+ * BUGGY VERSION. Please NOT use it.
+ * Fixed a minor bug, but the major bug is still there.
+
+------------------------------------------------------------------------
+r488 | lh3lh3 | 2009-10-24 00:17:10 -0400 (Sat, 24 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_rmdup.c
+   M /trunk/samtools/bam_rmdupse.c
+   M /trunk/samtools/kaln.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam_header.c
+   M /trunk/samtools/sam_header.h
+   M /trunk/samtools/sam_view.c
+
+ * This revision is SERIOUSLY BUGGY. Please NOT use it.
+ * Start to incorporate header parsing from Petr Danecek
+
+------------------------------------------------------------------------
+r487 | petulda | 2009-10-23 11:44:32 -0400 (Fri, 23 Oct 2009) | 1 line
+Changed paths:
+   M /trunk/samtools/sam_header.c
+   M /trunk/samtools/sam_header.h
+
+Now possible to merge multiple HeaderDict dictionaries
+------------------------------------------------------------------------
+r486 | petulda | 2009-10-22 11:46:58 -0400 (Thu, 22 Oct 2009) | 1 line
+Changed paths:
+   M /trunk/samtools/sam_header.c
+
+
+------------------------------------------------------------------------
+r485 | petulda | 2009-10-22 11:41:56 -0400 (Thu, 22 Oct 2009) | 1 line
+Changed paths:
+   A /trunk/samtools/sam_header.c
+   A /trunk/samtools/sam_header.h
+
+
+------------------------------------------------------------------------
+r484 | lh3lh3 | 2009-10-19 14:31:32 -0400 (Mon, 19 Oct 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_rmdupse.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/examples/Makefile
+
+ * samtools-0.1.6-17 (r484)
+ * fixed a memory leak in rmdupse
+ * fixed a bug in parsing @RG header lines
+ * test rmdup in examples/
+
+------------------------------------------------------------------------
+r483 | lh3lh3 | 2009-10-19 13:22:48 -0400 (Mon, 19 Oct 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_rmdup.c
+   M /trunk/samtools/bam_rmdupse.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-16 (r483)
+ * unify the interface of rmdup and rmdupse
+ * a new bug found in rg2lib(). Have not been fixed yet.
+
+------------------------------------------------------------------------
+r482 | lh3lh3 | 2009-10-19 13:03:34 -0400 (Mon, 19 Oct 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_rmdup.c
+   M /trunk/samtools/bam_rmdupse.c
+   M /trunk/samtools/bamtk.c
+   A /trunk/samtools/klist.h
+
+ * samtools-0.1.6-15 (r482)
+ * rewrite rmdupse
+ * rmdupse is now library aware
+
+------------------------------------------------------------------------
+r481 | lh3lh3 | 2009-10-18 00:07:21 -0400 (Sun, 18 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_rmdup.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-14 (r480)
+ * rmdup is now RG aware
+
+------------------------------------------------------------------------
+r480 | lh3lh3 | 2009-10-17 22:05:20 -0400 (Sat, 17 Oct 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+added a small unitity to parse SRA XML files
+
+------------------------------------------------------------------------
+r479 | lh3lh3 | 2009-10-17 20:57:26 -0400 (Sat, 17 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_maqcns.h
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-13 (r479)
+ * merge: optionally use file names as RG tags
+
+------------------------------------------------------------------------
+r478 | lh3lh3 | 2009-10-14 14:18:12 -0400 (Wed, 14 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/kaln.c
+
+ * samtools-0.1.6-12 (r478)
+ * fixed a bug in the indel caller
+
+------------------------------------------------------------------------
+r477 | lh3lh3 | 2009-10-10 06:12:26 -0400 (Sat, 10 Oct 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-11 (r477)
+ * fixed a bug due to recent change in bam_index.c (thank Nicole Washington for the patch)
+
+------------------------------------------------------------------------
+r476 | petulda | 2009-10-09 11:45:36 -0400 (Fri, 09 Oct 2009) | 1 line
+Changed paths:
+   A /trunk/samtools/misc/sam2vcf.pl
+
+Added the sam2vcf.pl script.
+------------------------------------------------------------------------
+r475 | lh3lh3 | 2009-10-08 10:19:16 -0400 (Thu, 08 Oct 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bamtk.c
+   A /trunk/samtools/kaln.c
+   A /trunk/samtools/kaln.h
+
+Unfinished modification. Please do not use this revision...
+
+------------------------------------------------------------------------
+r474 | petulda | 2009-10-08 06:39:54 -0400 (Thu, 08 Oct 2009) | 1 line
+Changed paths:
+   M /trunk/samtools/knetfile.c
+
+Removed the offending knet_seek message.
+------------------------------------------------------------------------
+r473 | petulda | 2009-10-06 09:26:35 -0400 (Tue, 06 Oct 2009) | 1 line
+Changed paths:
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/razf.c
+
+Bug fix - faidx on RAZF compressed files now working.
+------------------------------------------------------------------------
+r472 | lh3lh3 | 2009-10-02 08:42:57 -0400 (Fri, 02 Oct 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/samtools.1
+
+Clarify the meaning of a region like "chr2:1,000,000".
+
+------------------------------------------------------------------------
+r471 | lh3lh3 | 2009-10-02 05:42:19 -0400 (Fri, 02 Oct 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/novo2sam.pl
+
+Fixed minor bugs in novo2sam.pl (on behalf of Ken Chen and Colin Hercus)
+
+------------------------------------------------------------------------
+r470 | lh3lh3 | 2009-09-29 15:01:27 -0400 (Tue, 29 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile.mingw
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+ * samtools-0.1.6-9 (r470)
+ * make knetfile.c compatible with MinGW (thank Martin Morgan for the patch)
+
+------------------------------------------------------------------------
+r469 | lh3lh3 | 2009-09-29 08:07:44 -0400 (Tue, 29 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-9 (r469)
+ * refactor bam_fetch() for Python binding. On behalf of Leo Goodstadt.
+
+------------------------------------------------------------------------
+r468 | lh3lh3 | 2009-09-28 05:18:29 -0400 (Mon, 28 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools-0.1.6-7 (r468)
+ * make merge stable
+
+------------------------------------------------------------------------
+r467 | petulda | 2009-09-28 04:51:29 -0400 (Mon, 28 Sep 2009) | 1 line
+Changed paths:
+   M /trunk/samtools/bgzf.c
+   M /trunk/samtools/bgzip.c
+   M /trunk/samtools/razf.c
+   M /trunk/samtools/razip.c
+
+Changed the mode for newly created files to 0666. This allows less strict permissions with umask properly set (e.g. 0002 vs. 0022).
+------------------------------------------------------------------------
+r466 | lh3lh3 | 2009-09-24 06:29:19 -0400 (Thu, 24 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-6 (r466)
+ * do not crash calmd when some sequences are absent from the reference.
+
+------------------------------------------------------------------------
+r464 | jmarshall | 2009-09-23 06:14:32 -0400 (Wed, 23 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/knetfile.c
+
+Suppress bgzf_check_EOF() messages when reading from a pipe, as there is
+no way to seek on a pipe and the messages always appear.
+
+------------------------------------------------------------------------
+r463 | petulda | 2009-09-16 07:05:41 -0400 (Wed, 16 Sep 2009) | 1 line
+Changed paths:
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/razf.c
+
+A bug fix, "samtools view" is now working again.
+------------------------------------------------------------------------
+r462 | lh3lh3 | 2009-09-16 04:51:07 -0400 (Wed, 16 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/faidx.c
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+   M /trunk/samtools/razf.c
+   M /trunk/samtools/razf.h
+
+ * samtools-0.1.6-5 (r462)
+ * Added knetfile support in razf and faidx (on behalf of Petr Danecek)
+
+------------------------------------------------------------------------
+r460 | lh3lh3 | 2009-09-09 07:06:22 -0400 (Wed, 09 Sep 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/samtools.1
+
+fixed a formatting issue
+
+------------------------------------------------------------------------
+r459 | lh3lh3 | 2009-09-08 18:14:08 -0400 (Tue, 08 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-4 (r459)
+ * make sort output the result to stdout when -o is in use
+
+------------------------------------------------------------------------
+r458 | lh3lh3 | 2009-09-07 05:10:28 -0400 (Mon, 07 Sep 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/faidx.c
+   M /trunk/samtools/faidx.h
+   M /trunk/samtools/samtools.1
+
+ * samtools-0.1.6-2 (r458)
+ * added more interface to faidx (by Nils)
+ * updated documentation
+
+------------------------------------------------------------------------
+r457 | lh3lh3 | 2009-09-05 16:12:04 -0400 (Sat, 05 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.6-2 (r457)
+ * get rid of three assert() in bam_sort.c
+
+------------------------------------------------------------------------
+r456 | jmarshall | 2009-09-04 12:46:25 -0400 (Fri, 04 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/razf.c
+
+Return NULL from _razf_open() (and hence razf_open()/razf_open2())
+when opening the file fails.
+
+------------------------------------------------------------------------
+r453 | lh3lh3 | 2009-09-02 08:56:33 -0400 (Wed, 02 Sep 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/NEWS
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/samtools.1
+   D /trunk/samtools/source.dot
+
+Release samtools-0.1.6
+
+------------------------------------------------------------------------
+r451 | lh3lh3 | 2009-09-02 05:44:48 -0400 (Wed, 02 Sep 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bam_rmdup.c
+   M /trunk/samtools/bam_rmdupse.c
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/samtools.1
+
+ * samtools-0.1.5-34 (r451)
+ * applied the patch by John
+ * improved the help message a little bit
+
+------------------------------------------------------------------------
+r450 | lh3lh3 | 2009-09-02 04:55:55 -0400 (Wed, 02 Sep 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_color.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-33 (r450)
+ * fixed a bug in bam_color.c (on behalf of Nils Homer)
+
+------------------------------------------------------------------------
+r449 | lh3lh3 | 2009-08-29 15:36:41 -0400 (Sat, 29 Aug 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools-0.1.5-32 (r449)
+ * fillmd: fixed a bug in modifying MD/NM tags
+ * in import, give a warning if the read is aligned but there is no CIGAR.
+
+------------------------------------------------------------------------
+r448 | lh3lh3 | 2009-08-19 04:44:28 -0400 (Wed, 19 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/wgsim_eval.pl
+
+ * samtools-0.1.5-31 (r448)
+ * fixed an issue when the last CIGAR is I or D
+
+------------------------------------------------------------------------
+r447 | lh3lh3 | 2009-08-17 04:34:57 -0400 (Mon, 17 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-30 (r447)
+ * fixed a bug in bam_aux_get(): 'A' is not checked
+
+------------------------------------------------------------------------
+r446 | lh3lh3 | 2009-08-17 04:33:17 -0400 (Mon, 17 Aug 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bamtk.c
+
+ * 
+
+------------------------------------------------------------------------
+r444 | lh3lh3 | 2009-08-11 05:02:36 -0400 (Tue, 11 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-28 (r444)
+ * bug in "merge -n"
+
+------------------------------------------------------------------------
+r443 | lh3lh3 | 2009-08-11 04:29:11 -0400 (Tue, 11 Aug 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-27 (r443)
+ * SEQ and QUAL can be "*"
+ * parse CIGAR "=" and "X" as "M"
+
+------------------------------------------------------------------------
+r442 | lh3lh3 | 2009-08-07 16:56:38 -0400 (Fri, 07 Aug 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/md5.c
+   M /trunk/samtools/misc/md5.h
+   M /trunk/samtools/misc/md5fa.c
+
+ * samtools-0.1.5-26 (r442)
+ * replace RSA Inc md5.* with ones under permissive lincense
+ * fixed a bug in detecting unsorted bam in pileup
+
+------------------------------------------------------------------------
+r441 | bhandsaker | 2009-08-05 09:41:28 -0400 (Wed, 05 Aug 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bgzf.c
+   M /trunk/samtools/bgzf.h
+   M /trunk/samtools/bgzip.c
+
+Change copyright notices now that MIT has approved open source distribution.
+
+------------------------------------------------------------------------
+r440 | lh3lh3 | 2009-08-05 05:44:24 -0400 (Wed, 05 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_stat.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-25 (r436)
+ * in flagstats, do not report singletons if both ends are unmapped
+
+------------------------------------------------------------------------
+r439 | lh3lh3 | 2009-08-04 17:16:51 -0400 (Tue, 04 Aug 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/maq2sam.c
+
+fixed a SERIOUS bug in setting 0x20 flag
+
+------------------------------------------------------------------------
+r438 | lh3lh3 | 2009-08-04 16:50:43 -0400 (Tue, 04 Aug 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+fixed two minor bugs (suggested by Tim M Storm)
+
+------------------------------------------------------------------------
+r437 | lh3lh3 | 2009-08-04 04:13:24 -0400 (Tue, 04 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/samtools.pl
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.5-24 (r435)
+ * fixed a typo
+
+------------------------------------------------------------------------
+r434 | lh3lh3 | 2009-08-03 05:40:42 -0400 (Mon, 03 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-23 (r434)
+ * in tview, press 'r' to show read names rather than sequences
+
+------------------------------------------------------------------------
+r433 | lh3lh3 | 2009-08-02 14:13:35 -0400 (Sun, 02 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/knetfile.c
+
+ * tried to fixed the buggy FTP random access in Windows. FAILED.
+ * anyway, MinGW seems to have problem with "%lld".
+
+------------------------------------------------------------------------
+r432 | lh3lh3 | 2009-08-01 19:32:07 -0400 (Sat, 01 Aug 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/Makefile.mingw
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/faidx.c
+   M /trunk/samtools/razf.c
+   A /trunk/samtools/win32/libcurses.a
+   A /trunk/samtools/win32/xcurses.h
+
+ * samtools-0.1.5-22 (r432)
+ * faidx: fixed compitability issue with _WIN32
+ * razf: fixed potential compitability issue with _WIN32
+ * PDCurses support in Windows
+
+------------------------------------------------------------------------
+r431 | lh3lh3 | 2009-08-01 18:34:54 -0400 (Sat, 01 Aug 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/win32/libz.a
+
+replace the GnuWin32 version of libz.a with my own build with MinGW.
+
+------------------------------------------------------------------------
+r430 | lh3lh3 | 2009-08-01 18:21:07 -0400 (Sat, 01 Aug 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/knetfile.c
+
+add comments
+
+------------------------------------------------------------------------
+r429 | lh3lh3 | 2009-08-01 17:41:19 -0400 (Sat, 01 Aug 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile.mingw
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+ * samtools-0.1.5-21 (r428)
+ * knetfile.c is now compatible with mingw-winsock
+
+------------------------------------------------------------------------
+r428 | lh3lh3 | 2009-07-31 19:39:07 -0400 (Fri, 31 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile.mingw
+
+simplify MinGW Makefile
+
+------------------------------------------------------------------------
+r427 | lh3lh3 | 2009-07-31 19:30:54 -0400 (Fri, 31 Jul 2009) | 5 lines
+Changed paths:
+   A /trunk/samtools/Makefile.mingw
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   A /trunk/samtools/win32
+   A /trunk/samtools/win32/libz.a
+   A /trunk/samtools/win32/zconf.h
+   A /trunk/samtools/win32/zlib.h
+
+ * samtools-0.1.5-20 (r427)
+ * MinGW support. At least SAM<->BAM conversion is working. Other
+   functionality are not tested at the moment.
+ * zlib headers and Windows version of libz.a are included in win32/
+
+------------------------------------------------------------------------
+r426 | lh3lh3 | 2009-07-31 18:32:09 -0400 (Fri, 31 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.5-19 (r426)
+ * fixed a bug caused by recent modifications. Sorry.
+
+------------------------------------------------------------------------
+r425 | lh3lh3 | 2009-07-31 18:23:51 -0400 (Fri, 31 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bgzf.c
+
+compatible with Windows binary files
+
+------------------------------------------------------------------------
+r424 | lh3lh3 | 2009-07-31 05:19:59 -0400 (Fri, 31 Jul 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_maqcns.h
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools-0.1.5-18 (r423)
+ * output additional information in pileup indel lines, for the purepose
+   of debugging at the moment
+ * in tview, optionally allow to treat reference skip as deletion
+
+------------------------------------------------------------------------
+r423 | lh3lh3 | 2009-07-30 17:00:36 -0400 (Thu, 30 Jul 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/misc/psl2sam.pl
+
+convert BLAT psl to SAM.
+
+------------------------------------------------------------------------
+r422 | lh3lh3 | 2009-07-30 06:24:39 -0400 (Thu, 30 Jul 2009) | 6 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.c
+   M /trunk/samtools/bgzf.h
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.5-17 (r422)
+ * fixed a but in knetfile.c when seek type is not SEEK_SET
+ * write an empty BGZF block to every BGZF file
+ * check BGZF EOF marker in bam_header_read()
+ * update ChangeLog
+
+------------------------------------------------------------------------
+r421 | lh3lh3 | 2009-07-30 05:03:39 -0400 (Thu, 30 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/samtools.pl
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam.h
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.5-16 (r421)
+ * in view and pileup, load header from FASTA index if the input is SAM.
+
+------------------------------------------------------------------------
+r420 | lh3lh3 | 2009-07-29 04:18:55 -0400 (Wed, 29 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/maq2sam.c
+
+do not set "read 1" if reads are not mapped in the PE mode of maq
+
+------------------------------------------------------------------------
+r419 | lh3lh3 | 2009-07-28 04:52:33 -0400 (Tue, 28 Jul 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/samtools.pl
+   M /trunk/samtools/misc/wgsim_eval.pl
+
+ * samtools-0.1.5-15 (r419)
+ * in sam_open(), return NULL when the file cannot be opened.
+ * make wgsim_eval.pl more robust to imperfect SAM
+ * add "unique" command to samtools.pl
+
+------------------------------------------------------------------------
+r418 | lh3lh3 | 2009-07-24 09:04:19 -0400 (Fri, 24 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/wgsim_eval.pl
+
+skip @header lines in SAM
+
+------------------------------------------------------------------------
+r417 | lh3lh3 | 2009-07-24 07:42:38 -0400 (Fri, 24 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.5-14 (r417)
+ * more help in "samtools view" due to the recent changes.
+
+------------------------------------------------------------------------
+r416 | lh3lh3 | 2009-07-24 07:34:30 -0400 (Fri, 24 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam.h
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.5-17 (r416)
+ * support import/export SAM with string tags
+
+------------------------------------------------------------------------
+r415 | lh3lh3 | 2009-07-24 06:39:26 -0400 (Fri, 24 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam.h
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.5-12 (r415)
+ * FLAG now can be in HEX
+
+------------------------------------------------------------------------
+r414 | lh3lh3 | 2009-07-22 17:03:49 -0400 (Wed, 22 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/kstring.h
+
+fixed a compiling error (thank Ken for fixing it)
+
+------------------------------------------------------------------------
+r412 | lh3lh3 | 2009-07-21 17:19:40 -0400 (Tue, 21 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/kstring.c
+   M /trunk/samtools/kstring.h
+
+Implemented Boyer-Moore search in the kstring library.
+
+------------------------------------------------------------------------
+r409 | lh3lh3 | 2009-07-17 12:10:20 -0400 (Fri, 17 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+
+do not include knetfile.h when _USE_KNETFILE is not defined
+
+------------------------------------------------------------------------
+r408 | lh3lh3 | 2009-07-17 10:29:21 -0400 (Fri, 17 Jul 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.c
+
+ * samtools-0.1.5-11 (r408)
+ * force to overwirte existing MD if it is different from the one calculated
+   from fillmd.
+ * bgzf.c: improved the compatibility with Windows headers
+
+------------------------------------------------------------------------
+r407 | lh3lh3 | 2009-07-17 09:46:56 -0400 (Fri, 17 Jul 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.h
+
+ * samtools-0.1.5-10 (r407)
+ * implemented bam_aux_del() to remove a tag
+ * fillmd: generate the NM tag
+ * fillmd: cmd interface improvement
+
+------------------------------------------------------------------------
+r406 | lh3lh3 | 2009-07-16 18:30:40 -0400 (Thu, 16 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+
+Sorry. The old Makefile is for PDCurses...
+
+------------------------------------------------------------------------
+r405 | lh3lh3 | 2009-07-16 18:30:11 -0400 (Thu, 16 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-9 (r405)
+ * improved the compatibility with PDCurses a little bit
+
+------------------------------------------------------------------------
+r404 | lh3lh3 | 2009-07-16 18:23:52 -0400 (Thu, 16 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-8 (r404)
+ * compatible with PDCurses
+
+------------------------------------------------------------------------
+r403 | lh3lh3 | 2009-07-16 17:39:39 -0400 (Thu, 16 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/kseq.h
+
+ * samtools-0.1.5-7 (r403)
+ * fixed a bug in kseq.h for binary files (text files are fine)
+
+------------------------------------------------------------------------
+r402 | lh3lh3 | 2009-07-16 06:49:53 -0400 (Thu, 16 Jul 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.c
+
+ * samtools-0.1.5-6 (r402)
+ * fixed compiling error when "-D_USE_NETFILE" is not applied
+ * improve portability to MinGW
+
+------------------------------------------------------------------------
+r398 | lh3lh3 | 2009-07-13 05:21:36 -0400 (Mon, 13 Jul 2009) | 3 lines
+Changed paths:
+   A /trunk/bam-lite/bam.h (from /trunk/samtools/bam.h:395)
+   A /trunk/bam-lite/bam_lite.c (from /trunk/samtools/bam_lite.c:395)
+   D /trunk/samtools/bam_lite.c
+
+ * move bam_lite.c to bam-lite
+ * copy bam.h to bam-lite
+
+------------------------------------------------------------------------
+r395 | lh3lh3 | 2009-07-13 05:12:57 -0400 (Mon, 13 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_lite.c
+   M /trunk/samtools/bam_lpileup.c
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-5 (r395)
+ * added bam_pileup_file() and removed bam_lpileup_file()
+
+------------------------------------------------------------------------
+r394 | lh3lh3 | 2009-07-12 19:35:10 -0400 (Sun, 12 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+ * samtools-0.1.5-4 (r394)
+ * http_proxy support in knetfile library (check http_proxy ENV)
+
+------------------------------------------------------------------------
+r393 | lh3lh3 | 2009-07-12 18:57:07 -0400 (Sun, 12 Jul 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+ * samtools-0.1.5-3 (r393)
+ * knetfile now supports HTTP (no proxy at the moment)
+ * fixed a potential issue in knetfile on opening ordinary file, although I have
+   not seen the sideeffect so far.
+
+------------------------------------------------------------------------
+r392 | lh3lh3 | 2009-07-12 13:50:55 -0400 (Sun, 12 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/samtools.1
+
+Remove the warning in tview
+
+------------------------------------------------------------------------
+r391 | lh3lh3 | 2009-07-12 13:42:43 -0400 (Sun, 12 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-2 (r391)
+ * do not show a blank screen when no reads mapped
+
+------------------------------------------------------------------------
+r390 | lh3lh3 | 2009-07-09 09:01:42 -0400 (Thu, 09 Jul 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   A /trunk/samtools/bam_lite.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.5-1 (r390)
+ * removed useless _IOLIB in bam.h. This should cause no change at all.
+ * added bam_lite.c for light-weight BAM reading
+
+------------------------------------------------------------------------
+r385 | lh3lh3 | 2009-07-07 11:53:29 -0400 (Tue, 07 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/knetfile.c
+
+Release samtools-0.1.5c (fixed a bug in piping)
+
+------------------------------------------------------------------------
+r383 | lh3lh3 | 2009-07-07 06:39:55 -0400 (Tue, 07 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+
+Release samtools-0.1.5b (BUG! so embarrassing!)
+
+------------------------------------------------------------------------
+r381 | lh3lh3 | 2009-07-07 06:20:06 -0400 (Tue, 07 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bamtk.c
+
+Release samtools-0.1.5a (for compatibility with Bio::DB::Sam)
+
+------------------------------------------------------------------------
+r373 | lh3lh3 | 2009-07-07 05:26:57 -0400 (Tue, 07 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/NEWS
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/samtools.1
+
+Release samtools-0.1.5
+
+------------------------------------------------------------------------
+r372 | lh3lh3 | 2009-07-07 04:49:27 -0400 (Tue, 07 Jul 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+
+ * samtools-0.1.4-23 (r372)
+ * keep header text if "view -t" is used (by Gerton)
+
+------------------------------------------------------------------------
+r371 | lh3lh3 | 2009-07-06 20:13:32 -0400 (Mon, 06 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/samtools.1
+
+update documentation
+
+------------------------------------------------------------------------
+r370 | bhandsaker | 2009-07-02 17:24:34 -0400 (Thu, 02 Jul 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+
+Introduced LIBPATH variable so this could be overridden to allow samtools to build correct at the Broad.
+
+------------------------------------------------------------------------
+r369 | lh3lh3 | 2009-07-02 08:36:53 -0400 (Thu, 02 Jul 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.4-22 (r369)
+ * in pileup, optionally print E2 and U2
+ * remove the debugging code in bam_aux_get() (Drat!)
+
+------------------------------------------------------------------------
+r368 | lh3lh3 | 2009-07-02 06:32:26 -0400 (Thu, 02 Jul 2009) | 6 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bam_lpileup.c
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bam_rmdup.c
+   M /trunk/samtools/bam_stat.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/faidx.c
+   M /trunk/samtools/faidx.h
+   M /trunk/samtools/glf.c
+
+ * samtools-0.1.4-21 (r368)
+ * propagate errors rather than exit or complain assertion failure. Assertion
+   should be only used for checking internal bugs, but not for external input
+   inconsistency. I was just a bit lazy.
+ * small memory leak may be present on failure, though
+
+------------------------------------------------------------------------
+r367 | lh3lh3 | 2009-06-30 11:18:42 -0400 (Tue, 30 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/knetfile.c
+
+reduce the chance of blocking in FTP connection
+
+------------------------------------------------------------------------
+r366 | lh3lh3 | 2009-06-30 10:35:21 -0400 (Tue, 30 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/knetfile.c
+
+minor changes to knetfile: invalid fd equals -1 rather than 0
+
+------------------------------------------------------------------------
+r365 | lh3lh3 | 2009-06-30 09:04:30 -0400 (Tue, 30 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+ * samtools-0.1.4-20 (r365)
+ * download the BAM index file if it is not found in the current working directory.
+
+------------------------------------------------------------------------
+r364 | lh3lh3 | 2009-06-30 07:39:07 -0400 (Tue, 30 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/knetfile.c
+
+ * samtools-0.1.4-19 (r364)
+ * knetfile: report error when the file is not present on FTP
+
+------------------------------------------------------------------------
+r363 | lh3lh3 | 2009-06-29 18:23:32 -0400 (Mon, 29 Jun 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.c
+   M /trunk/samtools/bgzf.h
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+ * samtools-0.1.4-18 (r363)
+ * knetfile: do not trigger network communication in FTP seek (lazy seek)
+ * bgzf: cache recent blocks (disabled by default)
+
+------------------------------------------------------------------------
+r362 | lh3lh3 | 2009-06-25 16:04:34 -0400 (Thu, 25 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bgzf.c
+
+write changelog
+
+------------------------------------------------------------------------
+r361 | lh3lh3 | 2009-06-25 16:03:10 -0400 (Thu, 25 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.4-17 (r361)
+ * if a file is given on FTP, search locally for the BAM index
+
+------------------------------------------------------------------------
+r360 | lh3lh3 | 2009-06-25 15:44:52 -0400 (Thu, 25 Jun 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.c
+   M /trunk/samtools/bgzf.h
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+ * samtools-0.1.4-16 (r360)
+ * report more information in index when the input is not sorted
+ * change the behaviour of knet_seek() such that it returns 0 on success
+ * support knetfile library in BGZF
+
+------------------------------------------------------------------------
+r359 | lh3lh3 | 2009-06-25 12:10:55 -0400 (Thu, 25 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/knetfile.c
+   M /trunk/samtools/knetfile.h
+
+fixed bugs in knetfile.*
+
+------------------------------------------------------------------------
+r358 | lh3lh3 | 2009-06-25 08:53:19 -0400 (Thu, 25 Jun 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/knetfile.h
+
+this is the header file
+
+------------------------------------------------------------------------
+r357 | lh3lh3 | 2009-06-25 08:52:03 -0400 (Thu, 25 Jun 2009) | 3 lines
+Changed paths:
+   A /trunk/samtools/knetfile.c
+
+ * open a file at FTP
+ * preliminary version
+
+------------------------------------------------------------------------
+r354 | lh3lh3 | 2009-06-24 09:02:25 -0400 (Wed, 24 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.4-15 (r354)
+ * fixed a memory leak in bam_view1(), although samtools is not using this routine.
+
+------------------------------------------------------------------------
+r351 | lh3lh3 | 2009-06-17 19:16:26 -0400 (Wed, 17 Jun 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/faidx.c
+
+ * samtools-0.1.4-13 (r351)
+ * make faidx more tolerant to empty lines right before or after > lines
+ * hope this does not introduce new bugs...
+
+------------------------------------------------------------------------
+r350 | lh3lh3 | 2009-06-16 09:37:01 -0400 (Tue, 16 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.4-13 (r350)
+ * fixed a small memory leak in pileup, caused by recent modifications
+
+------------------------------------------------------------------------
+r347 | lh3lh3 | 2009-06-13 16:20:49 -0400 (Sat, 13 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.4-12 (r347)
+ * added `-S' to pileup, similar to `view -S' 
+
+------------------------------------------------------------------------
+r346 | lh3lh3 | 2009-06-13 12:52:31 -0400 (Sat, 13 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam_view.c
+   M /trunk/samtools/samtools.1
+
+ * samtools-0.1.4-11 (r346)
+ * allow to select a read group at view command-line
+
+------------------------------------------------------------------------
+r344 | lh3lh3 | 2009-06-13 09:06:24 -0400 (Sat, 13 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/examples/calDepth.c
+
+added more comments
+
+------------------------------------------------------------------------
+r343 | lh3lh3 | 2009-06-13 09:01:22 -0400 (Sat, 13 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/examples/calDepth.c
+
+nothing really
+
+------------------------------------------------------------------------
+r342 | lh3lh3 | 2009-06-13 08:58:48 -0400 (Sat, 13 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/examples/Makefile
+   A /trunk/samtools/examples/calDepth.c
+
+added an example of calculating read depth
+
+------------------------------------------------------------------------
+r341 | lh3lh3 | 2009-06-13 08:00:08 -0400 (Sat, 13 Jun 2009) | 6 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   A /trunk/samtools/bam_color.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam.h
+
+ * samtools-0.1.4-10 (r341)
+ * only include key APIs in libbam.a
+ * move color-specific routines to bam_color.c
+ * update documentations
+ * remove the support of -q in pileup
+
+------------------------------------------------------------------------
+r340 | lh3lh3 | 2009-06-13 06:17:14 -0400 (Sat, 13 Jun 2009) | 6 lines
+Changed paths:
+   M /trunk/samtools/INSTALL
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/razf.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.4-9 (r340)
+ * added a warning to razf.c if zlib<1.2.2.1
+ * fixed a compilation warning
+ * fixed a segfault caused by @RG parsing
+ * detect NCURSES in bam_tview.c
+
+------------------------------------------------------------------------
+r339 | lh3lh3 | 2009-06-13 05:35:19 -0400 (Sat, 13 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/INSTALL
+
+update INSTALL
+
+------------------------------------------------------------------------
+r338 | lh3lh3 | 2009-06-12 19:15:24 -0400 (Fri, 12 Jun 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/kstring.h
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.4-8 (r338)
+ * parse the @RG header lines and allow to choose library at the "samtools view"
+   command line
+
+------------------------------------------------------------------------
+r337 | lh3lh3 | 2009-06-12 16:25:50 -0400 (Fri, 12 Jun 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.c
+   M /trunk/samtools/bgzf.h
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.4-7 (r337)
+ * bgzf.c: support mode string "wu": uncompressed output
+ * "samtools view" support "-u" command-line option
+
+------------------------------------------------------------------------
+r336 | lh3lh3 | 2009-06-12 12:20:12 -0400 (Fri, 12 Jun 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/misc/Makefile
+   M /trunk/samtools/razf.c
+   M /trunk/samtools/razf.h
+   M /trunk/samtools/razip.c
+
+ * no changes to samtools itself
+ * remove zlib source codes
+ * make RAZF reading compatible with old version of zlib
+ * on old version of zlib, writing is not available
+
+------------------------------------------------------------------------
+r335 | lh3lh3 | 2009-06-12 11:47:33 -0400 (Fri, 12 Jun 2009) | 2 lines
+Changed paths:
+   D /trunk/samtools/zlib
+
+remove zlib for simplification...
+
+------------------------------------------------------------------------
+r334 | lh3lh3 | 2009-06-12 10:43:36 -0400 (Fri, 12 Jun 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.4-6 (r334)
+ * do not export bam_aux_get_core() for Bio::DB::Sam because it has already
+   been implemented in that.
+ * this version works with the latest Bio::DB::Sam (20090612)
+
+------------------------------------------------------------------------
+r333 | lh3lh3 | 2009-06-12 10:33:42 -0400 (Fri, 12 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+
+update ChangeLog
+
+------------------------------------------------------------------------
+r332 | lh3lh3 | 2009-06-12 10:21:21 -0400 (Fri, 12 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/AUTHORS
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/misc/Makefile
+
+fixed minor things in Makefile
+
+------------------------------------------------------------------------
+r331 | lh3lh3 | 2009-06-12 10:07:05 -0400 (Fri, 12 Jun 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.4-5 (r3310
+ * no change to samtools itself. Version number is increased to reflect the
+   changes in the Makefile building system.
+
+------------------------------------------------------------------------
+r330 | lh3lh3 | 2009-06-12 10:03:38 -0400 (Fri, 12 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/AUTHORS
+   D /trunk/samtools/README
+
+update information...
+
+------------------------------------------------------------------------
+r329 | lh3lh3 | 2009-06-12 09:52:21 -0400 (Fri, 12 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/novo2sam.pl
+
+ * updated novoalign converter by Colin Hercus et al.
+ * this version works with indels
+
+------------------------------------------------------------------------
+r328 | lh3lh3 | 2009-06-12 09:50:53 -0400 (Fri, 12 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/INSTALL
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/misc/Makefile
+   M /trunk/samtools/zlib/Makefile
+
+ * update Makefile
+ * update INSTALL instruction
+
+------------------------------------------------------------------------
+r327 | lh3lh3 | 2009-06-12 09:18:29 -0400 (Fri, 12 Jun 2009) | 4 lines
+Changed paths:
+   A /trunk/samtools/Makefile (from /trunk/samtools/Makefile.generic:325)
+   D /trunk/samtools/Makefile.am
+   D /trunk/samtools/Makefile.generic
+   D /trunk/samtools/Makefile.lite
+   D /trunk/samtools/autogen.sh
+   D /trunk/samtools/cleanup.sh
+   D /trunk/samtools/configure.ac
+   A /trunk/samtools/misc/Makefile (from /trunk/samtools/misc/Makefile.generic:305)
+   D /trunk/samtools/misc/Makefile.am
+   D /trunk/samtools/misc/Makefile.generic
+   M /trunk/samtools/razf.c
+   A /trunk/samtools/zlib
+   A /trunk/samtools/zlib/Makefile
+   A /trunk/samtools/zlib/adler32.c
+   A /trunk/samtools/zlib/compress.c
+   A /trunk/samtools/zlib/crc32.c
+   A /trunk/samtools/zlib/crc32.h
+   A /trunk/samtools/zlib/deflate.c
+   A /trunk/samtools/zlib/deflate.h
+   A /trunk/samtools/zlib/gzio.c
+   A /trunk/samtools/zlib/infback.c
+   A /trunk/samtools/zlib/inffast.c
+   A /trunk/samtools/zlib/inffast.h
+   A /trunk/samtools/zlib/inffixed.h
+   A /trunk/samtools/zlib/inflate.c
+   A /trunk/samtools/zlib/inflate.h
+   A /trunk/samtools/zlib/inftrees.c
+   A /trunk/samtools/zlib/inftrees.h
+   A /trunk/samtools/zlib/trees.c
+   A /trunk/samtools/zlib/trees.h
+   A /trunk/samtools/zlib/uncompr.c
+   A /trunk/samtools/zlib/zconf.h
+   A /trunk/samtools/zlib/zlib.h
+   A /trunk/samtools/zlib/zutil.c
+   A /trunk/samtools/zlib/zutil.h
+   D /trunk/samtools/zutil.h
+
+ * added zlib-1.2.3 as razip requires that
+ * prepare to changed back to the Makefile building system
+ * unfinished! (will be soon)
+
+------------------------------------------------------------------------
+r326 | lh3lh3 | 2009-06-12 09:12:03 -0400 (Fri, 12 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+Unfinished
+
+------------------------------------------------------------------------
+r325 | lh3lh3 | 2009-06-10 11:27:59 -0400 (Wed, 10 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.4-4 (r325)
+ * further avoid wrong consensus calls in repetitive regions.
+
+------------------------------------------------------------------------
+r324 | lh3lh3 | 2009-06-10 10:56:17 -0400 (Wed, 10 Jun 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam.h
+
+ * samtools-0.1.4-3 (r324)
+ * make maqcns generate the correct call in repetitive regions.
+ * allow filtering on mapQ at the pileup command line
+
+------------------------------------------------------------------------
+r323 | lh3lh3 | 2009-06-10 05:04:21 -0400 (Wed, 10 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.3.2 (r322)
+ * indels and SNPs use different mapping quality threshold
+
+------------------------------------------------------------------------
+r322 | lh3lh3 | 2009-06-10 05:03:22 -0400 (Wed, 10 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/export2sam.pl
+
+fixed a typo
+
+------------------------------------------------------------------------
+r321 | lh3lh3 | 2009-06-09 04:21:48 -0400 (Tue, 09 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+just typo. no real change
+
+------------------------------------------------------------------------
+r320 | lh3lh3 | 2009-06-08 09:32:51 -0400 (Mon, 08 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+a little bit code cleanup
+
+------------------------------------------------------------------------
+r319 | lh3lh3 | 2009-06-08 09:22:33 -0400 (Mon, 08 Jun 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.3.1
+ * change default parameters
+ * optionally print filtered variants
+
+------------------------------------------------------------------------
+r318 | lh3lh3 | 2009-06-08 09:14:26 -0400 (Mon, 08 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.3.0
+ * combine snpFilter and indelFilter
+
+------------------------------------------------------------------------
+r317 | lh3lh3 | 2009-06-08 06:31:42 -0400 (Mon, 08 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.2.3
+ * change a default parameter
+
+------------------------------------------------------------------------
+r316 | lh3lh3 | 2009-06-08 06:11:06 -0400 (Mon, 08 Jun 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_maqcns.h
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+
+ * samtools-0.1.4-2 (r316)
+ * pileup: cap mapping quality at 60 (by default)
+ * pileup: always calculate RMS mapq
+ * pileup: allow to output variant sites only
+
+------------------------------------------------------------------------
+r312 | lh3lh3 | 2009-06-04 08:01:10 -0400 (Thu, 04 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.2.2
+ * added pileup2fq
+
+------------------------------------------------------------------------
+r311 | lh3lh3 | 2009-06-03 04:40:40 -0400 (Wed, 03 Jun 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * in snpFilter, suppress non-SNP sites
+
+------------------------------------------------------------------------
+r310 | lh3lh3 | 2009-06-01 09:35:13 -0400 (Mon, 01 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.2.1
+ * fixed a typo
+
+------------------------------------------------------------------------
+r309 | lh3lh3 | 2009-06-01 09:04:39 -0400 (Mon, 01 Jun 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.2.0
+ * snpFilter
+
+------------------------------------------------------------------------
+r306 | lh3lh3 | 2009-05-28 06:49:35 -0400 (Thu, 28 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bgzf.c
+
+ * minor changes to bgzf: return NULL if fd == -1
+ * suggested by {kdj,jm18}@sanger.ac.uk
+
+------------------------------------------------------------------------
+r305 | lh3lh3 | 2009-05-28 06:16:08 -0400 (Thu, 28 May 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/misc/interpolate_sam.pl
+
+Script for paired-end pileup, contributed by Stephen Montgomery.
+
+------------------------------------------------------------------------
+r304 | lh3lh3 | 2009-05-28 06:08:49 -0400 (Thu, 28 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+
+ * samtools-0.1.4-1 (r304)
+ * fixed a minor bug in printing headers
+
+------------------------------------------------------------------------
+r297 | lh3lh3 | 2009-05-21 11:06:16 -0400 (Thu, 21 May 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/NEWS
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/maq2sam.c
+   M /trunk/samtools/samtools.1
+
+Release samtools-0.1.4
+
+------------------------------------------------------------------------
+r296 | lh3lh3 | 2009-05-21 07:53:14 -0400 (Thu, 21 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-24 (r296)
+ * another similar bug in the indel caller
+
+------------------------------------------------------------------------
+r295 | lh3lh3 | 2009-05-21 07:50:28 -0400 (Thu, 21 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-23 (r295)
+ * fixed a critical bug in the indel caller
+
+------------------------------------------------------------------------
+r294 | lh3lh3 | 2009-05-20 08:00:20 -0400 (Wed, 20 May 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bam_stat.c
+
+added a missing header file
+
+------------------------------------------------------------------------
+r293 | lh3lh3 | 2009-05-19 18:44:25 -0400 (Tue, 19 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-22 (r293)
+ * open tview in the dot-view mode by default
+
+------------------------------------------------------------------------
+r292 | lh3lh3 | 2009-05-18 16:01:23 -0400 (Mon, 18 May 2009) | 6 lines
+Changed paths:
+   M /trunk/samtools/samtools.1
+
+Added a note to the manual. Currently SAMtools used unaligned words in
+several places. Although this does not cause bus errors to me, it may
+affect portability. Please see the "Bus error" wiki page for more
+information. Also thank James Bonfields for pointing this out.
+
+
+------------------------------------------------------------------------
+r286 | lh3lh3 | 2009-05-14 10:23:13 -0400 (Thu, 14 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-21 (286)
+ * declare bam_aux_get_core() in bam.h
+
+------------------------------------------------------------------------
+r276 | lh3lh3 | 2009-05-13 05:07:55 -0400 (Wed, 13 May 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-20 (r276)
+ * remove bam1_t::hash again. We need to modify the Perl API anyway to
+   make it work with the latest SVN.
+ * As is suggested by Tim, scan "{base}.bai" and "{base}.bam.bai" for index
+
+------------------------------------------------------------------------
+r275 | lh3lh3 | 2009-05-12 16:14:10 -0400 (Tue, 12 May 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-19 (r275)
+ * a minor change to the bam1_t struct: added back "void *hash" for the
+   backward compatibility with Bio::DB::Sam
+
+------------------------------------------------------------------------
+r273 | lh3lh3 | 2009-05-12 09:28:39 -0400 (Tue, 12 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_rmdupse.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-18 (r273)
+ * rmdupse: do not remove unmapped reads
+
+------------------------------------------------------------------------
+r272 | lh3lh3 | 2009-05-12 09:20:00 -0400 (Tue, 12 May 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bam_rmdupse.c
+
+change a parameter. It does nothing
+
+------------------------------------------------------------------------
+r271 | lh3lh3 | 2009-05-12 09:17:58 -0400 (Tue, 12 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile.am
+   M /trunk/samtools/Makefile.generic
+   M /trunk/samtools/Makefile.lite
+   A /trunk/samtools/bam_rmdupse.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/configure.ac
+
+ * samtools-0.1.3-17 (r271)
+ * added 'rmdupse' command
+
+------------------------------------------------------------------------
+r267 | lh3lh3 | 2009-05-05 17:31:41 -0400 (Tue, 05 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.3-16 (r267)
+ * in sam_view.c, changed g_flag_on based on the suggestion by Angie Hinrichs
+
+------------------------------------------------------------------------
+r266 | lh3lh3 | 2009-05-05 17:23:27 -0400 (Tue, 05 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-15 (r266)
+ * report an error if a non-* reference is present while @SQ is absent
+
+------------------------------------------------------------------------
+r265 | lh3lh3 | 2009-05-05 17:09:00 -0400 (Tue, 05 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.3-14 (r262)
+ * make samopen() recognize @SQ header lines
+
+------------------------------------------------------------------------
+r261 | lh3lh3 | 2009-05-05 10:10:30 -0400 (Tue, 05 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam_view.c
+
+ * samtools-0.1.3-13 (r260)
+ * report error for file I/O error
+
+------------------------------------------------------------------------
+r260 | lh3lh3 | 2009-05-05 10:01:16 -0400 (Tue, 05 May 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile.am
+
+update Makefile.am
+
+------------------------------------------------------------------------
+r259 | lh3lh3 | 2009-05-05 09:52:25 -0400 (Tue, 05 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/sam.c
+   M /trunk/samtools/sam.h
+
+ * samtools-0.1.3-12 (r259)
+ * use the new I/O interface in pileup
+
+------------------------------------------------------------------------
+r258 | lh3lh3 | 2009-05-05 09:33:22 -0400 (Tue, 05 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile.generic
+   M /trunk/samtools/Makefile.lite
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   A /trunk/samtools/sam.c
+   A /trunk/samtools/sam.h
+   A /trunk/samtools/sam_view.c
+
+ * samtools-0.1.3-11 (r258)
+ * unify the interface to BAM and SAM I/O
+
+------------------------------------------------------------------------
+r257 | lh3lh3 | 2009-05-05 04:53:35 -0400 (Tue, 05 May 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile.lite
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-10 (r257)
+ * allow hex with "pileup -m"
+
+------------------------------------------------------------------------
+r256 | lh3lh3 | 2009-05-04 14:16:50 -0400 (Mon, 04 May 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_lpileup.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-9 (r256)
+ * fixed a bug in bam_lpileup.c
+ * I do not know if this also fixes the bug causing assertion failure in the tview
+
+------------------------------------------------------------------------
+r251 | lh3lh3 | 2009-04-28 08:53:23 -0400 (Tue, 28 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-8 (r251)
+ * fixed a bug when there are reads without coordinates
+
+------------------------------------------------------------------------
+r250 | lh3lh3 | 2009-04-28 08:43:33 -0400 (Tue, 28 Apr 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/AUTHORS
+   A /trunk/samtools/README
+   M /trunk/samtools/cleanup.sh
+
+added missing files
+
+------------------------------------------------------------------------
+r249 | lh3lh3 | 2009-04-28 08:37:16 -0400 (Tue, 28 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile.generic
+   M /trunk/samtools/Makefile.lite
+   M /trunk/samtools/configure.ac
+   M /trunk/samtools/misc/Makefile.generic
+
+improve large file support in compilation
+
+------------------------------------------------------------------------
+r248 | lh3lh3 | 2009-04-28 08:33:24 -0400 (Tue, 28 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/INSTALL
+
+update INSTALL
+
+------------------------------------------------------------------------
+r247 | lh3lh3 | 2009-04-28 08:28:50 -0400 (Tue, 28 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile.am
+   M /trunk/samtools/autogen.sh
+   M /trunk/samtools/cleanup.sh
+   M /trunk/samtools/configure.ac
+   A /trunk/samtools/misc/Makefile.am
+
+fixed various issues about the GNU building scripts
+
+------------------------------------------------------------------------
+r246 | lh3lh3 | 2009-04-28 08:10:23 -0400 (Tue, 28 Apr 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   D /trunk/samtools/Makefile
+   A /trunk/samtools/Makefile.am
+   A /trunk/samtools/Makefile.generic
+   A /trunk/samtools/autogen.sh
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   A /trunk/samtools/cleanup.sh
+   A /trunk/samtools/configure.ac
+   D /trunk/samtools/misc/Makefile
+   A /trunk/samtools/misc/Makefile.generic (from /trunk/samtools/misc/Makefile:245)
+
+ * samtools-0.1.3-7 (r246)
+ * incorporated revisions from Nils Homer
+ * enhanced support of displaying color-space reads
+
+------------------------------------------------------------------------
+r244 | lh3lh3 | 2009-04-25 06:49:40 -0400 (Sat, 25 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-6 (r244)
+ * fixed segfault for unmapped reads
+
+------------------------------------------------------------------------
+r243 | lh3lh3 | 2009-04-24 16:27:26 -0400 (Fri, 24 Apr 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-5 (r243)
+ * fixed a long existing bug which may cause memory leak
+ * check MD
+ * consensus calling now works with "=", but indel calling not
+
+------------------------------------------------------------------------
+r242 | lh3lh3 | 2009-04-24 15:44:46 -0400 (Fri, 24 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_md.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-4 (r242)
+ * fixed a memory leak
+
+------------------------------------------------------------------------
+r240 | lh3lh3 | 2009-04-24 11:40:18 -0400 (Fri, 24 Apr 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/Makefile.lite
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   A /trunk/samtools/bam_md.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-3 (r240)
+ * generate MD tag
+ * generate "=" bases
+ * the plain pileup now support "=" bases, but consensus calling and glfgen may fail
+
+------------------------------------------------------------------------
+r239 | lh3lh3 | 2009-04-24 07:08:20 -0400 (Fri, 24 Apr 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_aux.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-2 (r239)
+ * fixed bugs in bam_aux.c (these functions nevered used by samtools)
+ * removed bam_aux_init()/bam_aux_destroy()
+ * added tagview for testing bam_aux
+
+------------------------------------------------------------------------
+r235 | lh3lh3 | 2009-04-21 18:17:39 -0400 (Tue, 21 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.3-1
+ * fixed a bug in pileup: the first read in a chromosome may not be printed
+
+------------------------------------------------------------------------
+r232 | lh3lh3 | 2009-04-16 10:25:43 -0400 (Thu, 16 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile.lite
+
+a missing file in Makefile.lite
+
+------------------------------------------------------------------------
+r227 | lh3lh3 | 2009-04-15 17:02:53 -0400 (Wed, 15 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/NEWS
+   M /trunk/samtools/bamtk.c
+
+Release samtools-0.1.3
+
+------------------------------------------------------------------------
+r223 | lh3lh3 | 2009-04-15 09:31:32 -0400 (Wed, 15 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-28
+ * make samtools more robust to weird input such as empty file
+
+------------------------------------------------------------------------
+r222 | lh3lh3 | 2009-04-15 09:05:33 -0400 (Wed, 15 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/NEWS
+   M /trunk/samtools/samtools.1
+
+prepare for release 0.1.3
+
+------------------------------------------------------------------------
+r221 | lh3lh3 | 2009-04-15 08:32:14 -0400 (Wed, 15 Apr 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/misc/blast2sam.pl
+
+convert NCBI-BLASTN to SAM
+
+------------------------------------------------------------------------
+r220 | lh3lh3 | 2009-04-15 08:18:19 -0400 (Wed, 15 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_lpileup.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-27
+ * fixed a small memory leak in tview
+
+------------------------------------------------------------------------
+r219 | lh3lh3 | 2009-04-15 08:00:08 -0400 (Wed, 15 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_rmdup.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-26
+ * fixed a bug in rmdup when there are unmapped reads
+
+------------------------------------------------------------------------
+r218 | lh3lh3 | 2009-04-14 17:28:58 -0400 (Tue, 14 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/NEWS
+
+proposed NEWS for the new release (have not yet)
+
+------------------------------------------------------------------------
+r216 | lh3lh3 | 2009-04-14 17:10:46 -0400 (Tue, 14 Apr 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/misc/samtools.pl
+
+ * samtools.pl-0.1.1
+ * improve indelFilter to avoid filtering true indels. The new filter relies
+   on the new pileup indel line implemented in samtools-0.1.2-25
+
+------------------------------------------------------------------------
+r215 | lh3lh3 | 2009-04-14 17:04:19 -0400 (Tue, 14 Apr 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/samtools.1
+
+ * samtools-0.1.2-25
+ * change the pileup indel line to shows the number of alignments actually
+   containing indels
+
+------------------------------------------------------------------------
+r211 | lh3lh3 | 2009-04-13 07:07:13 -0400 (Mon, 13 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+
+update ChangeLog from "svn log"
+
+------------------------------------------------------------------------
+r210 | lh3lh3 | 2009-04-12 15:57:05 -0400 (Sun, 12 Apr 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/kseq.h
+
+ * samtools-0.1.2-24
+ * in merge, gives a warning rather than error if the target sequence length is different
+ * allow empty header
+
+------------------------------------------------------------------------
+r209 | lh3lh3 | 2009-04-12 15:32:44 -0400 (Sun, 12 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-23
+ * recognize '*' at the QUAL field
+
+------------------------------------------------------------------------
+r208 | lh3lh3 | 2009-04-12 15:08:02 -0400 (Sun, 12 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/kseq.h
+
+ * samtools-0.1.2-22
+ * the field separater is TAB only, now
+
+------------------------------------------------------------------------
+r207 | lh3lh3 | 2009-04-08 10:18:03 -0400 (Wed, 08 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/examples/ex1.sam.gz
+
+ * fixed the problem in the example alignment due to the bug in fixmate
+
+------------------------------------------------------------------------
+r206 | lh3lh3 | 2009-04-08 10:15:05 -0400 (Wed, 08 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_mate.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/soap2sam.pl
+
+ * samtools-0.1.2-21
+ * fixed a nasty bug in `fixmate'
+
+------------------------------------------------------------------------
+r205 | lh3lh3 | 2009-04-08 05:57:08 -0400 (Wed, 08 Apr 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/bowtie2sam.pl
+   M /trunk/samtools/misc/soap2sam.pl
+   M /trunk/samtools/misc/wgsim_eval.pl
+
+make the script robust to the bugs in SOAP-2.1.7
+
+------------------------------------------------------------------------
+r200 | lh3lh3 | 2009-04-02 10:14:56 -0400 (Thu, 02 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_stat.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-20
+ * check if file is truncated in flagstat
+
+------------------------------------------------------------------------
+r199 | lh3lh3 | 2009-04-02 10:09:10 -0400 (Thu, 02 Apr 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-19
+ * print the header if requested
+
+------------------------------------------------------------------------
+r193 | lh3lh3 | 2009-03-27 11:09:50 -0400 (Fri, 27 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-18
+ * fixed a minor bug reported by Nils Homer
+
+------------------------------------------------------------------------
+r185 | lh3lh3 | 2009-03-24 07:50:32 -0400 (Tue, 24 Mar 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/Makefile (from /trunk/samtools/Makefile.std:184)
+   D /trunk/samtools/Makefile.std
+   A /trunk/samtools/misc/Makefile (from /trunk/samtools/misc/Makefile.std:184)
+   D /trunk/samtools/misc/Makefile.std
+
+rename Makefile.std as Makefile. GNU building systerm is not ready and may take some time...
+
+------------------------------------------------------------------------
+r184 | lh3lh3 | 2009-03-24 06:36:38 -0400 (Tue, 24 Mar 2009) | 4 lines
+Changed paths:
+   D /trunk/samtools/Makefile
+   A /trunk/samtools/Makefile.std (from /trunk/samtools/Makefile:183)
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bam_tview.c
+   M /trunk/samtools/bamtk.c
+   D /trunk/samtools/misc/Makefile
+   A /trunk/samtools/misc/Makefile.std (from /trunk/samtools/misc/Makefile:182)
+   M /trunk/samtools/samtools.1
+
+ * samtools-0.1.2-17
+ * incorporating Nils' changes
+ * rename Makefile to Makefile.std and prepare to add the GNU building systerms (also by Nils)
+
+------------------------------------------------------------------------
+r183 | lh3lh3 | 2009-03-24 06:30:23 -0400 (Tue, 24 Mar 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_maqcns.h
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/kseq.h
+   A /trunk/samtools/kstring.c
+   A /trunk/samtools/kstring.h
+
+ * samtools-0.1.2-16
+ * made pileup take a list of proposed indels. An insertion is N at the moment.
+ * added my kstring library for a bit complex parsing of the position list.
+
+------------------------------------------------------------------------
+r169 | lh3lh3 | 2009-03-12 09:40:14 -0400 (Thu, 12 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/soap2sam.pl
+
+ * soap2sam.pl-0.1.2
+ * more robust to truncated soap output
+
+------------------------------------------------------------------------
+r168 | lh3lh3 | 2009-03-11 06:49:00 -0400 (Wed, 11 Mar 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile.lite
+
+added bam_stat.o to Makefile.lite
+
+------------------------------------------------------------------------
+r167 | lh3lh3 | 2009-03-10 18:11:31 -0400 (Tue, 10 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-15
+ * generate RMS of mapQ instead of max mapQ
+
+------------------------------------------------------------------------
+r166 | lh3lh3 | 2009-03-10 18:06:45 -0400 (Tue, 10 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/glf.c
+   M /trunk/samtools/glf.h
+   M /trunk/samtools/misc/Makefile
+
+ * samtools-0.1.2-14
+ * implemented GLFv3
+
+------------------------------------------------------------------------
+r159 | lh3lh3 | 2009-03-03 06:26:08 -0500 (Tue, 03 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-13
+ * fixed a minor bug in displaying pileup
+
+------------------------------------------------------------------------
+r158 | lh3lh3 | 2009-03-03 06:24:16 -0500 (Tue, 03 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-12
+ * optionally print SAM header
+
+------------------------------------------------------------------------
+r153 | lh3lh3 | 2009-03-02 05:45:28 -0500 (Mon, 02 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/glf.c
+
+ * samtools-0.1.2-11
+ * use "GLF\3" as the magic for GLFv3 files
+
+------------------------------------------------------------------------
+r152 | lh3lh3 | 2009-03-02 05:39:09 -0500 (Mon, 02 Mar 2009) | 5 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/glf.c
+   M /trunk/samtools/glf.h
+
+ * samtools-0.1.2-10
+ * fixed a bug in import: core.bin is undefined for unmapped reads
+ * this bug can be alleviated (not completely solved) in bam_index.c
+ * update to GLFv3: pos is changed to offset for better compression
+
+------------------------------------------------------------------------
+r151 | lh3lh3 | 2009-03-01 10:18:43 -0500 (Sun, 01 Mar 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/wgsim.c
+
+ * wgsim-0.2.3
+ * fixed a bug in simulating indels
+
+------------------------------------------------------------------------
+r145 | lh3lh3 | 2009-02-26 14:43:57 -0500 (Thu, 26 Feb 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/misc/wgsim.c
+
+ * wgsim-0.2.2
+ * allow to print mismatch information as fastq comment. MAQ does
+   not like long read names.
+
+------------------------------------------------------------------------
+r141 | lh3lh3 | 2009-02-26 09:53:03 -0500 (Thu, 26 Feb 2009) | 6 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/misc/wgsim.c
+   M /trunk/samtools/misc/wgsim_eval.pl
+
+ * wgsim-0.2.1
+ * fixed a bug about color read coordinates
+ * fixed a bug in read names
+ * wgsim_eval.pl-0.1.3
+ * make the script work with color reads
+
+------------------------------------------------------------------------
+r140 | lh3lh3 | 2009-02-26 09:02:57 -0500 (Thu, 26 Feb 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/Makefile
+   M /trunk/samtools/misc/wgsim.c
+
+ * wgsim: added a note
+
+------------------------------------------------------------------------
+r139 | lh3lh3 | 2009-02-26 06:39:08 -0500 (Thu, 26 Feb 2009) | 7 lines
+Changed paths:
+   M /trunk/samtools/misc/wgsim.c
+   M /trunk/samtools/misc/wgsim_eval.pl
+
+ * wgsim-0.2.0
+ * considerable code clean up
+ * print number of substitutions/indels/errors on each read
+ * potentially support SOLiD simulation, though not tested at the moment
+ * wgsim_eval.pl-0.1.2
+ * change in accordant with wgsim
+
+------------------------------------------------------------------------
+r129 | lh3lh3 | 2009-02-18 17:23:27 -0500 (Wed, 18 Feb 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-9
+ * fixed a bug in bam_fetch, caused by completely contained adjacent chunks
+
+------------------------------------------------------------------------
+r128 | bhandsaker | 2009-02-18 14:06:57 -0500 (Wed, 18 Feb 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bamtk.c
+
+Fix annoying segv when invalid region specified.
+
+------------------------------------------------------------------------
+r127 | lh3lh3 | 2009-02-17 05:49:55 -0500 (Tue, 17 Feb 2009) | 2 lines
+Changed paths:
+   D /trunk/samtools/misc/indel_filter.pl
+   A /trunk/samtools/misc/samtools.pl
+
+ * move indel_filter.pl to samtools.pl
+
+------------------------------------------------------------------------
+r126 | lh3lh3 | 2009-02-14 16:22:30 -0500 (Sat, 14 Feb 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_mate.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-7
+ * fixed a bug in fixmate: SE reads are flagged as BAM_FMUNMAP
+
+------------------------------------------------------------------------
+r125 | lh3lh3 | 2009-02-13 04:54:45 -0500 (Fri, 13 Feb 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_stat.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-7
+ * fixed a minor bug in flagstat
+
+------------------------------------------------------------------------
+r124 | lh3lh3 | 2009-02-12 06:15:32 -0500 (Thu, 12 Feb 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/misc/indel_filter.pl
+
+ * samtools-0.1.2-6
+ * improve indel caller by setting maximum window size
+
+------------------------------------------------------------------------
+r123 | lh3lh3 | 2009-02-12 05:30:29 -0500 (Thu, 12 Feb 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bamtk.c
+
+ * output max mapping quality in indel line
+
+------------------------------------------------------------------------
+r122 | lh3lh3 | 2009-02-11 05:59:10 -0500 (Wed, 11 Feb 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/misc/maq2sam.c
+
+fixed a bug in generating tag AM
+
+------------------------------------------------------------------------
+r121 | lh3lh3 | 2009-02-03 05:43:11 -0500 (Tue, 03 Feb 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bamtk.c
+
+fixed a potential memory problem in indexing
+
+------------------------------------------------------------------------
+r120 | bhandsaker | 2009-02-02 10:52:52 -0500 (Mon, 02 Feb 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+
+Pass LIBS to recursive targets to facilitate building at Broad.
+
+------------------------------------------------------------------------
+r119 | lh3lh3 | 2009-02-02 05:12:15 -0500 (Mon, 02 Feb 2009) | 4 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/bam_plcmd.c
+   M /trunk/samtools/bam_stat.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-3
+ * fixed a bug in generating GLFv2 for indels
+ * improve flagstat report a little bit
+
+------------------------------------------------------------------------
+r118 | lh3lh3 | 2009-01-29 07:33:23 -0500 (Thu, 29 Jan 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/Makefile
+   A /trunk/samtools/bam_stat.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.2-1
+ * added flagstat command
+
+------------------------------------------------------------------------
+r116 | lh3lh3 | 2009-01-28 08:31:12 -0500 (Wed, 28 Jan 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/NEWS
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/samtools.1
+
+Release SAMtools-0.1.2
+
+------------------------------------------------------------------------
+r115 | lh3lh3 | 2009-01-28 07:54:08 -0500 (Wed, 28 Jan 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/misc/indel_filter.pl
+
+Script for filtering indel results
+
+------------------------------------------------------------------------
+r114 | lh3lh3 | 2009-01-25 06:45:37 -0500 (Sun, 25 Jan 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/misc/zoom2sam.pl
+
+convert ZOOM to SAM
+
+------------------------------------------------------------------------
+r113 | lh3lh3 | 2009-01-24 09:25:07 -0500 (Sat, 24 Jan 2009) | 2 lines
+Changed paths:
+   A /trunk/samtools/misc/novo2sam.pl
+
+add a script to convert novo alignment to SAM
+
+------------------------------------------------------------------------
+r112 | lh3lh3 | 2009-01-23 15:57:39 -0500 (Fri, 23 Jan 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/ChangeLog
+   M /trunk/samtools/ChangeLog.old
+   M /trunk/samtools/samtools.1
+
+update documentation and ChangeLog
+
+------------------------------------------------------------------------
+r111 | lh3lh3 | 2009-01-23 14:22:59 -0500 (Fri, 23 Jan 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+
+ * samtools-0.1.1-19
+ * fixed a bug in "merge" command line
+
+------------------------------------------------------------------------
+r110 | lh3lh3 | 2009-01-22 10:36:48 -0500 (Thu, 22 Jan 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/misc/Makefile
+   A /trunk/samtools/misc/bowtie2sam.pl (from /branches/dev/samtools/misc/bowtie2sam.pl:108)
+   M /trunk/samtools/misc/export2sam.pl
+   A /trunk/samtools/misc/soap2sam.pl (from /branches/dev/samtools/misc/soap2sam.pl:108)
+   A /trunk/samtools/misc/wgsim.c (from /branches/dev/samtools/misc/wgsim.c:108)
+   A /trunk/samtools/misc/wgsim_eval.pl (from /branches/dev/samtools/misc/wgsim_eval.pl:108)
+
+ * merge from branches/dev/
+ * all future development will happen here
+
+------------------------------------------------------------------------
+r109 | lh3lh3 | 2009-01-22 10:14:27 -0500 (Thu, 22 Jan 2009) | 3 lines
+Changed paths:
+   M /trunk/samtools/COPYING
+   M /trunk/samtools/ChangeLog
+   A /trunk/samtools/INSTALL (from /branches/dev/samtools/INSTALL:108)
+   M /trunk/samtools/Makefile
+   A /trunk/samtools/Makefile.lite (from /branches/dev/samtools/Makefile.lite:108)
+   M /trunk/samtools/bam.c
+   M /trunk/samtools/bam.h
+   M /trunk/samtools/bam_import.c
+   M /trunk/samtools/bam_index.c
+   M /trunk/samtools/bam_lpileup.c
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_maqcns.h
+   A /trunk/samtools/bam_mate.c (from /branches/dev/samtools/bam_mate.c:108)
+   M /trunk/samtools/bam_pileup.c
+   M /trunk/samtools/bam_plcmd.c
+   A /trunk/samtools/bam_rmdup.c (from /branches/dev/samtools/bam_rmdup.c:108)
+   M /trunk/samtools/bam_sort.c
+   M /trunk/samtools/bamtk.c
+   M /trunk/samtools/bgzf.h
+   M /trunk/samtools/examples/00README.txt
+   A /trunk/samtools/examples/Makefile (from /branches/dev/samtools/examples/Makefile:108)
+   D /trunk/samtools/examples/ex1.fa.fai
+   M /trunk/samtools/examples/ex1.sam.gz
+   M /trunk/samtools/faidx.c
+   A /trunk/samtools/glf.c (from /branches/dev/samtools/glf.c:108)
+   M /trunk/samtools/glf.h
+   M /trunk/samtools/misc/Makefile
+   M /trunk/samtools/misc/maq2sam.c
+   M /trunk/samtools/razf.c
+   M /trunk/samtools/source.dot
+
+ * Merge from branches/dev/
+ * all future development will happen here at trunk/
+
+------------------------------------------------------------------------
+r79 | bhandsaker | 2009-01-07 16:42:15 -0500 (Wed, 07 Jan 2009) | 2 lines
+Changed paths:
+   M /trunk/samtools/bam_maqcns.c
+   M /trunk/samtools/bam_tview.c
+
+Fix problem with compiling without curses.
+
+------------------------------------------------------------------------
+r63 | lh3lh3 | 2008-12-22 10:58:02 -0500 (Mon, 22 Dec 2008) | 2 lines
+Changed paths:
+   A /trunk/samtools (from /branches/dev/samtools:62)
+
+Create trunk copy
+
+------------------------------------------------------------------------
+r62 | lh3lh3 | 2008-12-22 10:55:13 -0500 (Mon, 22 Dec 2008) | 2 lines
+Changed paths:
+   A /branches/dev/samtools/NEWS
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/samtools.1
+
+Release samtools-0.1.1
+
+------------------------------------------------------------------------
+r61 | lh3lh3 | 2008-12-22 10:46:08 -0500 (Mon, 22 Dec 2008) | 10 lines
+Changed paths:
+   M /branches/dev/samtools/bam_aux.c
+   M /branches/dev/samtools/bam_index.c
+   M /branches/dev/samtools/bam_plcmd.c
+   M /branches/dev/samtools/bam_tview.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/razf.c
+   M /branches/dev/samtools/samtools.1
+
+ * samtools-0.1.0-66
+ * fixed a bug in razf.c: reset z_eof when razf_seek() is called
+ * fixed a memory leak in parsing a region
+ * changed pileup a little bit when -s is in use: output ^ and $
+ * when a bam is not indexed, output more meaningful error message
+ * fixed a bug in indexing for small alignment
+ * fixed a bug in the viewer when we come to the end of a reference file
+ * updated documentation
+ * prepare to release 0.1.1
+
+------------------------------------------------------------------------
+r60 | lh3lh3 | 2008-12-22 10:10:16 -0500 (Mon, 22 Dec 2008) | 2 lines
+Changed paths:
+   A /branches/dev/samtools/examples
+   A /branches/dev/samtools/examples/00README.txt
+   A /branches/dev/samtools/examples/ex1.fa
+   A /branches/dev/samtools/examples/ex1.fa.fai
+   A /branches/dev/samtools/examples/ex1.sam.gz
+
+example
+
+------------------------------------------------------------------------
+r59 | lh3lh3 | 2008-12-22 04:38:15 -0500 (Mon, 22 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/ChangeLog
+
+update ChangeLog
+
+------------------------------------------------------------------------
+r58 | lh3lh3 | 2008-12-20 18:06:00 -0500 (Sat, 20 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/misc/export2sam.pl
+
+ * added comments
+ * fixed several bugs 
+
+------------------------------------------------------------------------
+r57 | lh3lh3 | 2008-12-20 10:44:20 -0500 (Sat, 20 Dec 2008) | 2 lines
+Changed paths:
+   A /branches/dev/samtools/misc/export2sam.pl
+
+convert Export format to SAM; not thoroughly tested
+
+------------------------------------------------------------------------
+r56 | lh3lh3 | 2008-12-19 17:13:28 -0500 (Fri, 19 Dec 2008) | 6 lines
+Changed paths:
+   M /branches/dev/samtools/bam_import.c
+   M /branches/dev/samtools/bam_plcmd.c
+   M /branches/dev/samtools/bam_tview.c
+   M /branches/dev/samtools/bamtk.c
+   A /branches/dev/samtools/source.dot
+
+ * samtools-0.1.0-65
+ * pileup: generate maq-like simple output
+ * pileup: allow to output pileup at required sites
+ * source.dot: source file relationship graph
+ * tview: fixed a minor bug
+
+------------------------------------------------------------------------
+r55 | lh3lh3 | 2008-12-19 15:10:26 -0500 (Fri, 19 Dec 2008) | 2 lines
+Changed paths:
+   D /branches/dev/samtools/misc/all2sam.pl
+
+remove all2sam.pl
+
+------------------------------------------------------------------------
+r54 | lh3lh3 | 2008-12-16 17:34:25 -0500 (Tue, 16 Dec 2008) | 2 lines
+Changed paths:
+   A /branches/dev/samtools/COPYING
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/faidx.h
+   M /branches/dev/samtools/khash.h
+   M /branches/dev/samtools/kseq.h
+   M /branches/dev/samtools/ksort.h
+   M /branches/dev/samtools/samtools.1
+
+Added copyright information and a bit more documentation. No code change.
+
+------------------------------------------------------------------------
+r53 | lh3lh3 | 2008-12-16 08:40:18 -0500 (Tue, 16 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam.c
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/bam_index.c
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-64
+ * improved efficiency of the indel caller for spliced alignments
+
+------------------------------------------------------------------------
+r52 | lh3lh3 | 2008-12-16 05:28:20 -0500 (Tue, 16 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam.c
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/bam_aux.c
+   M /branches/dev/samtools/bam_index.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-63
+ * a bit code cleanup: reduce the dependency between source files
+
+------------------------------------------------------------------------
+r51 | lh3lh3 | 2008-12-15 09:29:32 -0500 (Mon, 15 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bam_plcmd.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-62
+ * fixed a memory leak
+
+------------------------------------------------------------------------
+r50 | lh3lh3 | 2008-12-15 09:00:13 -0500 (Mon, 15 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/ChangeLog
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/samtools.1
+
+update documentation, ChangeLog and a comment
+
+------------------------------------------------------------------------
+r49 | lh3lh3 | 2008-12-15 08:36:43 -0500 (Mon, 15 Dec 2008) | 6 lines
+Changed paths:
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bam_maqcns.h
+   M /branches/dev/samtools/bam_pileup.c
+   A /branches/dev/samtools/bam_plcmd.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/samtools.1
+
+ * samtools-0.1.0-61
+ * moved pileup command to a separate source file
+ * added indel caller
+ * added bam_cal_segend(). (NOT WORKING for spliced alignment!!!)
+ * updated documentation
+
+------------------------------------------------------------------------
+r48 | lh3lh3 | 2008-12-12 08:55:36 -0500 (Fri, 12 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-60
+ * fixed another bug in maqcns when there is a nearby deletion
+
+------------------------------------------------------------------------
+r47 | lh3lh3 | 2008-12-12 08:42:16 -0500 (Fri, 12 Dec 2008) | 5 lines
+Changed paths:
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bam_pileup.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-59
+ * pileup: outputing consensus is now optional
+ * fixed a bug in glfgen. This bug also exists in maq's glfgen. However,
+   I am not quite sure why the previous version may have problem.
+
+------------------------------------------------------------------------
+r46 | lh3lh3 | 2008-12-12 06:44:56 -0500 (Fri, 12 Dec 2008) | 6 lines
+Changed paths:
+   M /branches/dev/samtools/bam_pileup.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-58
+ * add maq consensus to pileup. However, I will move this part to a new
+   command as strictly speaking, consensus callin is not part of pileup,
+   and imposing it would make it harder to generate for other language
+   bindings.
+
+------------------------------------------------------------------------
+r45 | bhandsaker | 2008-12-11 15:43:56 -0500 (Thu, 11 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/bgzf.c
+
+Fix bug in tell() after reads that consume to the exact end of a block.
+
+------------------------------------------------------------------------
+r44 | lh3lh3 | 2008-12-11 04:36:53 -0500 (Thu, 11 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/samtools.1
+
+update manual
+
+------------------------------------------------------------------------
+r43 | lh3lh3 | 2008-12-11 04:25:36 -0500 (Thu, 11 Dec 2008) | 4 lines
+Changed paths:
+   M /branches/dev/samtools/bam_import.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-57
+ * fixed a bug in parser when there is auxiliary fields
+ * made the parser a bit more robust
+
+------------------------------------------------------------------------
+r42 | lh3lh3 | 2008-12-10 09:57:29 -0500 (Wed, 10 Dec 2008) | 5 lines
+Changed paths:
+   M /branches/dev/samtools/bam_index.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/bgzf.c
+
+ * samtools-0.1.0-56
+ * fixed a bug in bgzf (only reading is affected)
+ * fixed a typo in bam_index.c
+ * in bam_index.c, check potential bugs in the underlying I/O library
+
+------------------------------------------------------------------------
+r41 | lh3lh3 | 2008-12-10 07:53:08 -0500 (Wed, 10 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/samtools.1
+
+update manual
+
+------------------------------------------------------------------------
+r40 | lh3lh3 | 2008-12-10 06:52:10 -0500 (Wed, 10 Dec 2008) | 5 lines
+Changed paths:
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/bam_pileup.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-55
+ * tried to make pileup work with clipping (previously not), though NOT tested
+ * removed -v from pileup
+ * made pileup take the reference sequence
+
+------------------------------------------------------------------------
+r39 | lh3lh3 | 2008-12-09 06:59:28 -0500 (Tue, 09 Dec 2008) | 4 lines
+Changed paths:
+   M /branches/dev/samtools/bam_import.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/samtools.1
+
+ * samtools-0.1.0-54
+ * in parser, recognize "=", rather than ",", as a match
+ * in parser, correctl parse "=" at the MRNM field.
+
+------------------------------------------------------------------------
+r38 | lh3lh3 | 2008-12-09 06:39:07 -0500 (Tue, 09 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/misc/maq2sam.c
+
+fixed a bug in handling maq flag 64 and 192
+
+------------------------------------------------------------------------
+r37 | lh3lh3 | 2008-12-09 04:53:46 -0500 (Tue, 09 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/misc/md5fa.c
+
+also calculate unordered md5sum check
+
+------------------------------------------------------------------------
+r36 | lh3lh3 | 2008-12-09 04:46:21 -0500 (Tue, 09 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/misc/md5fa.c
+
+fixed a minor bug when there are space in the sequence
+
+------------------------------------------------------------------------
+r35 | lh3lh3 | 2008-12-09 04:40:45 -0500 (Tue, 09 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/misc/md5fa.c
+
+fixed a potential memory leak
+
+------------------------------------------------------------------------
+r34 | lh3lh3 | 2008-12-08 09:52:17 -0500 (Mon, 08 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/bam_import.c
+   M /branches/dev/samtools/bam_index.c
+   M /branches/dev/samtools/bamtk.c
+
+ * fixed a bug in import: bin is wrongly calculated
+
+------------------------------------------------------------------------
+r33 | lh3lh3 | 2008-12-08 09:08:01 -0500 (Mon, 08 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/misc/all2sam.pl
+
+nothing, really
+
+------------------------------------------------------------------------
+r32 | lh3lh3 | 2008-12-08 07:56:02 -0500 (Mon, 08 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/kseq.h
+   M /branches/dev/samtools/misc/Makefile
+   A /branches/dev/samtools/misc/md5.c
+   A /branches/dev/samtools/misc/md5.h
+   A /branches/dev/samtools/misc/md5fa.c
+
+ * fixed two warnings in kseq.h
+ * added md5sum utilities
+
+------------------------------------------------------------------------
+r31 | lh3lh3 | 2008-12-08 06:35:29 -0500 (Mon, 08 Dec 2008) | 5 lines
+Changed paths:
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/bam_import.c
+   M /branches/dev/samtools/bamtk.c
+   A /branches/dev/samtools/kseq.h
+   D /branches/dev/samtools/kstream.h
+
+ * samtools-0.1.0-52
+ * replace kstream with kseq. kseq is a superset of kstream. I need the
+   extra functions in kseq.h.
+ * also compile stand-alone faidx
+
+------------------------------------------------------------------------
+r30 | lh3lh3 | 2008-12-08 06:17:04 -0500 (Mon, 08 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/bam_sort.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-51
+ * sorting by read names is available
+
+------------------------------------------------------------------------
+r29 | lh3lh3 | 2008-12-08 05:29:02 -0500 (Mon, 08 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam.c
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/bam_import.c
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bam_pileup.c
+   M /branches/dev/samtools/bam_sort.c
+   M /branches/dev/samtools/bam_tview.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/misc/maq2sam.c
+
+ * samtools-0.1.0-50
+ * format change to meet the latest specification
+
+------------------------------------------------------------------------
+r28 | lh3lh3 | 2008-12-04 11:09:21 -0500 (Thu, 04 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/misc/maq2sam.c
+
+ * minor change in maqcns: special care when n==0
+ * change maq2sam to meet the latest specification
+
+------------------------------------------------------------------------
+r27 | lh3lh3 | 2008-12-04 10:55:44 -0500 (Thu, 04 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/razf.c
+   M /branches/dev/samtools/razf.h
+
+considerable code clean up in razf
+
+------------------------------------------------------------------------
+r26 | lh3lh3 | 2008-12-04 10:08:18 -0500 (Thu, 04 Dec 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/ChangeLog
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/faidx.c
+
+make RAZF optional in faidx.c
+
+------------------------------------------------------------------------
+r25 | lh3lh3 | 2008-12-01 10:27:22 -0500 (Mon, 01 Dec 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/bam_aux.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/samtools.1
+
+ * samtools-0.1.0-49
+ * added routines for retrieving aux data, NOT TESTED YET!
+
+------------------------------------------------------------------------
+r24 | lh3lh3 | 2008-12-01 09:29:43 -0500 (Mon, 01 Dec 2008) | 5 lines
+Changed paths:
+   M /branches/dev/samtools/bam.c
+   M /branches/dev/samtools/bam_import.c
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/bgzf.c
+   M /branches/dev/samtools/samtools.1
+
+ * samtools-0.1.0-48
+ * bgzf: fixed a potential integer overflow on 32-it machines
+ * maqcns: set the minimum combined quality as 0
+ * supporting hex strings
+
+------------------------------------------------------------------------
+r23 | lh3lh3 | 2008-11-27 12:14:37 -0500 (Thu, 27 Nov 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/bam_maqcns.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-47
+ * fixed the bug in maqcns
+
+------------------------------------------------------------------------
+r22 | lh3lh3 | 2008-11-27 12:08:11 -0500 (Thu, 27 Nov 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/bam.h
+   A /branches/dev/samtools/bam_maqcns.c
+   A /branches/dev/samtools/bam_maqcns.h
+   M /branches/dev/samtools/bam_tview.c
+   M /branches/dev/samtools/bamtk.c
+   A /branches/dev/samtools/glf.h
+
+ * samtools-0.1.0-46
+ * add MAQ consensus caller, currently BUGGY!
+
+------------------------------------------------------------------------
+r21 | lh3lh3 | 2008-11-27 08:51:28 -0500 (Thu, 27 Nov 2008) | 4 lines
+Changed paths:
+   M /branches/dev/samtools/bam_pileup.c
+   M /branches/dev/samtools/bam_tview.c
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-45
+ * tview: display padded alignment (but not P operation)
+ * better coordinates and reference sequence
+
+------------------------------------------------------------------------
+r19 | lh3lh3 | 2008-11-27 04:26:05 -0500 (Thu, 27 Nov 2008) | 2 lines
+Changed paths:
+   A /branches/dev/samtools/ChangeLog
+
+new ChangeLog
+
+------------------------------------------------------------------------
+r18 | lh3lh3 | 2008-11-27 04:24:45 -0500 (Thu, 27 Nov 2008) | 3 lines
+Changed paths:
+   D /branches/dev/samtools/ChangeLog
+   A /branches/dev/samtools/ChangeLog.old (from /branches/dev/samtools/ChangeLog:6)
+
+Rename ChangeLog to ChangeLog.old. This old ChangeLog is generated from
+the log of my personal SVN repository.
+
+------------------------------------------------------------------------
+r17 | lh3lh3 | 2008-11-27 04:22:55 -0500 (Thu, 27 Nov 2008) | 6 lines
+Changed paths:
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/bgzf.c
+
+ * samtools-0.1.0-44
+ * declare fseeko and ftello as some Linux may not do this by default and
+   missing these declarations will make bgzf buggy
+ * get rid of some harmless warings
+ * use BGZF by default, now
+
+------------------------------------------------------------------------
+r16 | lh3lh3 | 2008-11-26 16:19:11 -0500 (Wed, 26 Nov 2008) | 4 lines
+Changed paths:
+   M /branches/dev/samtools/bam_index.c
+   M /branches/dev/samtools/bamtk.c
+   M /branches/dev/samtools/razf.c
+
+ * samtools-0.1.0-43
+ * fixed a bug in razf_read()
+ * give more warnings when the file is truncated (or due to bugs in I/O library)
+
+------------------------------------------------------------------------
+r15 | lh3lh3 | 2008-11-26 15:41:39 -0500 (Wed, 26 Nov 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/bgzf.c
+
+fixed a bug in bgzf.c at the end of the file
+
+------------------------------------------------------------------------
+r14 | lh3lh3 | 2008-11-26 12:05:18 -0500 (Wed, 26 Nov 2008) | 4 lines
+Changed paths:
+   M /branches/dev/samtools/bamtk.c
+
+ * samtools-0.1.0-42
+ * a lot happened to RAZF, although samtools itself is untouched. Better
+   also update the version number anyway to avoid confusion
+
+------------------------------------------------------------------------
+r13 | lh3lh3 | 2008-11-26 12:03:48 -0500 (Wed, 26 Nov 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/razf.c
+
+a change from Jue, but I think it should not matter
+
+------------------------------------------------------------------------
+r12 | lh3lh3 | 2008-11-26 11:48:14 -0500 (Wed, 26 Nov 2008) | 3 lines
+Changed paths:
+   M /branches/dev/samtools/razf.c
+
+fixed a potential bug in razf. However, it seems still buggy, just
+rarely happens, very rarely.
+
+------------------------------------------------------------------------
+r11 | lh3lh3 | 2008-11-26 09:02:56 -0500 (Wed, 26 Nov 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/razf.c
+
+fixed a bug in razf, with the help of Jue
+
+------------------------------------------------------------------------
+r10 | lh3lh3 | 2008-11-26 06:55:32 -0500 (Wed, 26 Nov 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/bam_index.c
+
+remove a comment
+
+------------------------------------------------------------------------
+r9 | lh3lh3 | 2008-11-26 06:37:05 -0500 (Wed, 26 Nov 2008) | 2 lines
+Changed paths:
+   M /branches/dev/samtools/Makefile
+   M /branches/dev/samtools/bam.h
+   M /branches/dev/samtools/razf.c
+   M /branches/dev/samtools/razf.h
+
+ * Jue has updated razf to realize Bob's scheme
+
+------------------------------------------------------------------------
+r7 | lh3lh3 | 2008-11-25 15:37:37 -0500 (Tue, 25 Nov 2008) | 2 lines
+Changed paths:
+   A /branches/dev/samtools/samtools.1
+
+the manual page
+
+------------------------------------------------------------------------
+r6 | lh3lh3 | 2008-11-25 15:37:16 -0500 (Tue, 25 Nov 2008) | 3 lines
+Changed paths:
+   A /branches/dev/samtools/ChangeLog
+   A /branches/dev/samtools/Makefile
+   A /branches/dev/samtools/bam.c
+   A /branches/dev/samtools/bam.h
+   A /branches/dev/samtools/bam_aux.c
+   A /branches/dev/samtools/bam_endian.h
+   A /branches/dev/samtools/bam_import.c
+   A /branches/dev/samtools/bam_index.c
+   A /branches/dev/samtools/bam_lpileup.c
+   A /branches/dev/samtools/bam_pileup.c
+   A /branches/dev/samtools/bam_sort.c
+   A /branches/dev/samtools/bam_tview.c
+   A /branches/dev/samtools/bamtk.c
+   A /branches/dev/samtools/bgzf.c
+   A /branches/dev/samtools/bgzf.h
+   A /branches/dev/samtools/bgzip.c
+   A /branches/dev/samtools/faidx.c
+   A /branches/dev/samtools/faidx.h
+   A /branches/dev/samtools/khash.h
+   A /branches/dev/samtools/ksort.h
+   A /branches/dev/samtools/kstream.h
+   A /branches/dev/samtools/misc
+   A /branches/dev/samtools/misc/Makefile
+   A /branches/dev/samtools/misc/all2sam.pl
+   A /branches/dev/samtools/misc/maq2sam.c
+   A /branches/dev/samtools/razf.c
+   A /branches/dev/samtools/razf.h
+   A /branches/dev/samtools/razip.c
+   A /branches/dev/samtools/zutil.h
+
+The initial version of samtools, replicated from my local SVN repository.
+The current version is: 0.1.0-42. All future development will happen here.
+
+------------------------------------------------------------------------
+r5 | lh3lh3 | 2008-11-25 15:30:49 -0500 (Tue, 25 Nov 2008) | 2 lines
+Changed paths:
+   A /branches/dev/samtools
+
+samtools (C version)
+
+------------------------------------------------------------------------
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/INSTALL b/ext/samtools-0.1.7a_getUnique-0.1.3/INSTALL
new file mode 100644
index 0000000..f1cf7aa
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/INSTALL
@@ -0,0 +1,29 @@
+System Requirements
+===================
+
+SAMtools depends on the zlib library <http://www.zlib.net>. The latest
+version 1.2.3 is preferred and with the latest version you can compile
+razip and use it to compress a FASTA file. SAMtools' faidx is able to
+index a razip-compressed FASTA file to save diskspace. Older zlib also
+works with SAMtools, but razip cannot be compiled.
+
+The text-based viewer (tview) requires the GNU ncurses library
+<http://www.gnu.org/software/ncurses/>, which comes with Mac OS X and
+most of the modern Linux/Unix distributions. If you do not have this
+library installed, you can still compile the rest of SAMtools by
+manually modifying one line in Makefile.
+
+
+Compilation
+===========
+
+Type `make' to compile samtools. If you have zlib >= 1.2.2.1, you can
+compile razip with `make razip'.
+
+
+Installation
+============
+
+Simply copy `samtools' and other executables/scripts in `misc' to a
+location you want (e.g. a directory in your $PATH). No further
+configurations are required.
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/Makefile b/ext/samtools-0.1.7a_getUnique-0.1.3/Makefile
new file mode 100644
index 0000000..a7d3a48
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/Makefile
@@ -0,0 +1,76 @@
+C=			gcc
+CFLAGS=		-g -Wall -O2  #-m64 #-arch ppc
+CFLAGS_1= 	-Wall -g 
+DFLAGS=		-D_FILE_OFFSET_BITS=64 -D_USE_KNETFILE -D_CURSES_LIB=1
+
+LIBS = -lm
+
+LOBJS=		bgzf.o kstring.o bam_aux.o bam.o bam_import.o sam.o bam_index.o	\
+			bam_pileup.o bam_lpileup.o bam_md.o glf.o razf.o faidx.o knetfile.o	\
+			bam_sort.o sam_header.o getUniqueRead/getUniqueRead.o
+AOBJS=		bam_tview.o bam_maqcns.o bam_plcmd.o sam_view.o	\
+			bam_rmdup.o bam_rmdupse.o bam_mate.o bam_stat.o bam_color.o	\
+			bamtk.o kaln.o getUniqueRead/getUniqueRead.o
+PROG=		samtools
+INCLUDES=
+SUBDIRS=	. misc
+LIBPATH=
+LIBCURSES=	-lcurses # -lXCurses
+
+.SUFFIXES:.c .o
+
+.c.o:
+		$(CC) -c $(CFLAGS) $(DFLAGS) $(INCLUDES) $< -o $@
+
+all-recur lib-recur clean-recur cleanlocal-recur install-recur:
+		@target=`echo $@ | sed s/-recur//`; \
+		wdir=`pwd`; \
+		list='$(SUBDIRS)'; for subdir in $$list; do \
+			cd $$subdir; \
+			$(MAKE) CC="$(CC)" DFLAGS="$(DFLAGS)" CFLAGS="$(CFLAGS)" \
+				INCLUDES="$(INCLUDES)" LIBPATH="$(LIBPATH)" $$target || exit 1; \
+			cd $$wdir; \
+		done;
+
+all:$(PROG)
+
+lib:libbam.a
+
+libbam.a:$(LOBJS)
+		$(AR) -cru $@ $(LOBJS)
+
+samtools:lib $(AOBJS)
+		$(CC) $(CFLAGS) -o $@ $(AOBJS) -lm $(LIBPATH) $(LIBCURSES) -lz -L. -lbam
+
+razip:razip.o razf.o knetfile.o
+		$(CC) $(CFLAGS) -o $@ razf.o razip.o knetfile.o -lz
+
+bgzip:bgzip.o bgzf.o
+		$(CC) $(CFLAGS) -o $@ bgzf.o bgzip.o -lz
+
+razip.o:razf.h
+bam.o:bam.h razf.h bam_endian.h kstring.h sam_header.h
+sam.o:sam.h bam.h
+getUniqueRead/getUniqueRead.o:getUniqueRead/getUniqueRead.h bam.h
+bam_import.o:bam.h kseq.h khash.h razf.h
+bam_pileup.o:bam.h razf.h ksort.h
+bam_plcmd.o:bam.h faidx.h bam_maqcns.h glf.h
+bam_index.o:bam.h khash.h ksort.h razf.h bam_endian.h
+bam_lpileup.o:bam.h ksort.h
+bam_tview.o:bam.h faidx.h bam_maqcns.h
+bam_maqcns.o:bam.h ksort.h bam_maqcns.h
+bam_sort.o:bam.h ksort.h razf.h
+bam_md.o:bam.h faidx.h
+glf.o:glf.h
+sam_header.o:sam_header.h khash.h
+
+faidx.o:faidx.h razf.h khash.h
+faidx_main.o:faidx.h razf.h
+
+
+
+
+cleanlocal:
+		rm -fr gmon.out *.o a.out *.dSYM razip $(PROG) *~ *.a
+
+clean:cleanlocal-recur
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/Makefile.mingw b/ext/samtools-0.1.7a_getUnique-0.1.3/Makefile.mingw
new file mode 100644
index 0000000..f1ae1be
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/Makefile.mingw
@@ -0,0 +1,55 @@
+CC=			gcc.exe
+AR=			ar.exe
+CFLAGS=		-g -Wall -O2
+DFLAGS=		-D_CURSES_LIB=2 -D_USE_KNETFILE
+LOBJS=		bgzf.o kstring.o bam_aux.o bam.o bam_import.o sam.o bam_index.o	\
+			bam_pileup.o bam_lpileup.o bam_md.o glf.o razf.o faidx.o bam_sort.o \
+			knetfile.o
+AOBJS=		bam_tview.o bam_maqcns.o bam_plcmd.o sam_view.o	\
+			bam_rmdup.o bam_rmdupse.o bam_mate.o bam_stat.o bam_color.o	\
+			bamtk.o kaln.o sam_header.o
+PROG=		samtools
+INCLUDES=	-Iwin32
+SUBDIRS=	.
+LIBPATH=	
+
+.SUFFIXES:.c .o
+
+.c.o:
+		$(CC) -c $(CFLAGS) $(DFLAGS) $(INCLUDES) $< -o $@
+
+all:$(PROG)
+
+lib:libbam.a
+
+libbam.a:$(LOBJS)
+		$(AR) -cru $@ $(LOBJS)
+
+samtools:lib $(AOBJS)
+		$(CC) $(CFLAGS) -o $@ $(AOBJS) $(LIBPATH) -lm -L. -lbam -Lwin32 -lz -lcurses -lws2_32
+
+razip:razip.o razf.o knetfile.o
+		$(CC) $(CFLAGS) -o $@ razf.o razip.o knetfile.o -lz
+
+bgzip:bgzip.o bgzf.o
+		$(CC) $(CFLAGS) -o $@ bgzf.o bgzip.o -lz
+
+razip.o:razf.h
+bam.o:bam.h razf.h bam_endian.h kstring.h
+sam.o:sam.h bam.h
+bam_import.o:bam.h kseq.h khash.h razf.h
+bam_pileup.o:bam.h razf.h ksort.h
+bam_plcmd.o:bam.h faidx.h bam_maqcns.h glf.h
+bam_index.o:bam.h khash.h ksort.h razf.h bam_endian.h
+bam_lpileup.o:bam.h ksort.h
+bam_tview.o:bam.h faidx.h bam_maqcns.h
+bam_maqcns.o:bam.h ksort.h bam_maqcns.h
+bam_sort.o:bam.h ksort.h razf.h
+bam_md.o:bam.h faidx.h
+glf.o:glf.h
+
+faidx.o:faidx.h razf.h khash.h
+faidx_main.o:faidx.h razf.h
+
+clean:
+		rm -fr gmon.out *.o *.exe *.dSYM razip $(PROG) *~ *.a
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/NEWS b/ext/samtools-0.1.7a_getUnique-0.1.3/NEWS
new file mode 100644
index 0000000..8db0996
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/NEWS
@@ -0,0 +1,315 @@
+Beta Release 0.1.7 (10 November, 2009)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Notable changes:
+
+ * Improved the indel caller in complex scenariors, in particular for
+   long reads. The indel caller is now able to make reasonable indel
+   calls from Craig Venter capillary reads.
+
+ * Rewrote single-end duplicate removal with improved
+   performance. Paired-end reads are not touched.
+
+ * Duplicate removal is now library aware. Samtools remove potential
+   PCR/optical dupliates inside a library rather than across libraries.
+
+ * SAM header is now fully parsed, although this functionality is not
+   used in merging and so on.
+
+ * In samtools merge, optionally take the input file name as RG-ID and
+   attach the RG tag to each alignment.
+
+ * Added FTP support in the RAZF library. RAZF-compressed reference
+   sequence can be retrieved remotely.
+
+ * Improved network support for Win32.
+
+ * Samtools sort and merge are now stable.
+
+Changes in other utilities:
+
+ * Implemented sam2vcf.pl that converts the pileup format to the VCF
+   format.
+
+ * This release of samtools is known to work with the latest
+   Bio-Samtools Perl module.
+
+(0.1.7: 10 November 2009, r510)
+
+
+
+Beta Release 0.1.6 (2 September, 2009)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Notable changes:
+
+ * In tview, do not show a blank screen when no reads mapped to the
+   corresponding region.
+
+ * Implemented native HTTP support in the BGZF library. Samtools is now
+   able to directly open a BAM file on HTTP. HTTP proxy is also
+   supported via the "http_proxy" environmental variable.
+
+ * Samtools is now compitable with the MinGW (win32) compiler and the
+   PDCurses library.
+
+ * The calmd (or fillmd) command now calculates the NM tag and replaces
+   MD tags if they are wrong.
+
+ * The view command now recognizes and optionally prints FLAG in HEXs or
+   strings to make a SAM file more friendly to human eyes. This is a
+   samtools-C extension, not implemented in Picard for the time
+   being. Please type `samtools view -?' for more information.
+
+ * BAM files now have an end-of-file (EOF) marker to facilitate
+   truncation detection. A warning will be given if an on-disk BAM file
+   does not have this marker. The warning will be seen on BAM files
+   generated by an older version of samtools. It does NO harm.
+
+ * New key bindings in tview: `r' to show read names and `s' to show
+   reference skip (N operation) as deletions.
+
+ * Fixed a bug in `samtools merge -n'.
+
+ * Samtools merge now optionally copies the header of a user specified
+   SAM file to the resultant BAM output.
+
+ * Samtools pileup/tview works with a CIGAR with the first or the last
+   operation is an indel.
+
+ * Fixed a bug in bam_aux_get().
+
+
+Changes in other utilies:
+
+ * Fixed wrong FLAG in maq2sam.
+
+
+(0.1.6: 2 September 2009, r453)
+
+
+
+Beta Release 0.1.5 (7 July, 2009)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Notable changes:
+
+ * Support opening a BAM alignment on FTP. Users can now use "tview" to
+   view alignments at the NCBI ftp site. Please read manual for more
+   information.
+
+ * In library, propagate errors rather than exit or complain assertion
+   failure.
+
+ * Simplified the building system and fixed compiling errors caused by
+   zlib<1.2.2.1.
+
+ * Fixed an issue about lost header information when a SAM is imported
+   with "view -t".
+
+ * Implemented "samtool.pl varFilter" which filters both SNPs and short
+   indels. This command replaces "indelFilter".
+
+ * Implemented "samtools.pl pileup2fq" to generate FASTQ consensus from
+   pileup output.
+
+ * In pileup, cap mapping quality at 60. This helps filtering when
+   different aligners are in use.
+
+ * In pileup, allow to output variant sites only.
+
+ * Made pileup generate correct calls in repetitive region. At the same
+   time, I am considering to implement a simplified model in SOAPsnp,
+   although this has not happened yet.
+
+ * In view, added '-u' option to output BAM without compression. This
+   option is preferred when the output is piped to other commands.
+
+ * In view, added '-l' and '-r' to get the alignments for one library or
+   read group. The "@RG" header lines are now partially parsed.
+
+ * Do not include command line utilities to libbam.a.
+
+ * Fixed memory leaks in pileup and bam_view1().
+
+ * Made faidx more tolerant to empty lines right before or after FASTA >
+   lines.
+
+
+Changes in other utilities:
+
+ * Updated novo2sam.pl by Colin Hercus, the key developer of novoalign.
+
+
+This release involves several modifications to the key code base which
+may potentially introduce new bugs even though we have tried to minimize
+this by testing on several examples. Please let us know if you catch
+bugs.
+
+(0.1.5: 7 July 2009, r373)
+
+
+
+Beta Release 0.1.4 (21 May, 2009)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Notable changes:
+
+ * Added the 'rmdupse' command: removing duplicates for SE reads.
+
+ * Fixed a critical bug in the indel caller: clipped alignments are not
+   processed correctly.
+
+ * Fixed a bug in the tview: gapped alignment may be incorrectly
+   displayed.
+
+ * Unified the interface to BAM and SAM I/O. This is done by
+   implementing a wrapper on top of the old APIs and therefore old APIs
+   are still valid. The new I/O APIs also recognize the @SQ header
+   lines.
+
+ * Generate the MD tag.
+
+ * Generate "=" bases. However, the indel caller will not work when "="
+   bases are present.
+
+ * Enhanced support of color-read display (by Nils Homer).
+
+ * Implemented the GNU building system. However, currently the building
+   system does not generate libbam.a. We will improve this later. For
+   the time being, `make -f Makefile.generic' is preferred.
+
+ * Fixed a minor bug in pileup: the first read in a chromosome may be
+   skipped.
+
+ * Fixed bugs in bam_aux.c. These bugs do not affect other components as
+   they were not used previously.
+
+ * Output the 'SM' tag from maq2sam.
+
+(0.1.4: 21 May 2009, r297)
+
+
+
+Beta Release 0.1.3 (15 April, 2009)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Notable changes in SAMtools:
+
+ * SAMtools is more consistent with the specification: a) '*' in the
+   QUAL field is allowed; b) the field separator is TAB only and SPACE
+   is treated as a character in a field; c) empty header is allowed.
+
+ * Implemented GLFv3 support in pileup.
+
+ * Fixed a severe bug in fixmate: strand information is wrongly
+   overwritten.
+
+ * Fixed a bug in alignment retrieval: alignments bridging n*16384bp are
+   not correctly retrieved sometimes.
+
+ * Fixed a bug in rmdup: segfault if unmapped reads are present.
+
+ * Move indel_filter.pl to samtools.pl and improved the filtering by
+   checking the actual number of alignments containing indels. The indel
+   pileup line is also changed a little to make this filtration easier.
+
+ * Fixed a minor bug in indexing: the bin number of an unmapped read is
+   wrongly calculated.
+
+ * Added `flagstat' command to show statistics on the FLAG field.
+
+ * Improved indel caller by setting the maximum window size in local
+   realignment.
+
+Changes in other utilities:
+
+ * Fixed a bug in maq2sam: a tag name is obsolete.
+
+ * Improvement to wgsim: a) added support for SOLiD read simulation; b)
+   show the number of substitutions/indels/errors in read name; c)
+   considerable code clean up.
+
+ * Various converters: improved functionality in general.
+
+ * Updated the example SAM due to the previous bug in fixmate.
+
+(0.1.3: 15 April 2009, r227)
+
+
+
+Beta Release 0.1.2 (28 January, 2008)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Notable changes in SAMtools:
+
+ * Implemented a Bayesian indel caller. The new caller generate scores
+   and genotype and is potentially more accurate than Maq's indel
+   caller. The pileup format is also changed accordingly.
+
+ * Implemented rmdup command: remove potential PCR duplicates. Note that
+   this command ONLY works for FR orientation and requires ISIZE is
+   correctly set.
+
+ * Added fixmate command: fill in mate coordinates, ISIZE and mate
+   related flags from a name-sorted alignment.
+
+ * Fixed a bug in indexing: reads bridging 16x kbp were not retrieved.
+
+ * Allow to select reads shown in the pileup output with a mask.
+
+ * Generate GLFv2 from pileup.
+
+ * Added two more flags for flagging PCR/optical duplicates and for QC
+   failure.
+
+ * Fixed a bug in sort command: name sorting for large alignment did not
+   work.
+
+ * Allow to completely disable RAZF (using Makefile.lite) as some people
+   have problem to compile it.
+
+ * Fixed a bug in import command when there are reads without
+   coordinates.
+
+ * Fixed a bug in tview: clipping broke the alignment viewer.
+
+ * Fixed a compiling error when _NO_CURSES is applied.
+
+ * Fixed a bug in merge command.
+
+Changes in other utilities:
+
+ * Added wgsim, a paired-end reads simulator. Wgsim was adapted from
+   maq's reads simulator. Colin Hercus further improved it to allow
+   longer indels.
+
+ * Added wgsim_eval.pl, a script that evaluates the accuracy of
+   alignment on reads generated by wgsim.
+
+ * Added soap2sam.pl, a SOAP2->SAM converter. This converter does not
+   work properly when multiple hits are output.
+
+ * Added bowtie2sam.pl, a Bowtie->SAM converter. Only the top hit will
+   be retained when multiple hits are present.
+
+ * Fixed a bug in export2sam.pl for QC reads.
+
+ * Support RG tag at MAQ->SAM converter.
+
+ * Added novo2sam.pl, a NovoAlign->SAM converter. Multiple hits and
+   indel are not properly handled, though.
+
+ * Added zoom2sam.pl, a ZOOM->SAM converter. It only works with the
+   default Illumina output.
+
+(0.1.2: 28 January 2008; r116)
+
+
+
+Beta Release 0.1.1 (22 December, 2008)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The is the first public release of samtools. For more information,
+please check the manual page `samtools.1' and the samtools website
+http://samtools.sourceforge.net
\ No newline at end of file
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam.c
new file mode 100644
index 0000000..ee7642b
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam.c
@@ -0,0 +1,303 @@
+#include <stdio.h>
+#include <ctype.h>
+#include <errno.h>
+#include <assert.h>
+#include "bam.h"
+#include "bam_endian.h"
+#include "kstring.h"
+#include "sam_header.h"
+
+int bam_is_be = 0;
+char *bam_flag2char_table = "pPuUrR12sfd\0\0\0\0\0";
+
+/**************************
+ * CIGAR related routines *
+ **************************/
+
+uint32_t bam_calend(const bam1_core_t *c, const uint32_t *cigar)
+{
+	uint32_t k, end;
+	end = c->pos;
+	for (k = 0; k < c->n_cigar; ++k) {
+		int op = cigar[k] & BAM_CIGAR_MASK;
+		if (op == BAM_CMATCH || op == BAM_CDEL || op == BAM_CREF_SKIP)
+			end += cigar[k] >> BAM_CIGAR_SHIFT;
+	}
+	return end;
+}
+
+int32_t bam_cigar2qlen(const bam1_core_t *c, const uint32_t *cigar)
+{
+	uint32_t k;
+	int32_t l = 0;
+	for (k = 0; k < c->n_cigar; ++k) {
+		int op = cigar[k] & BAM_CIGAR_MASK;
+		if (op == BAM_CMATCH || op == BAM_CINS || op == BAM_CSOFT_CLIP)
+			l += cigar[k] >> BAM_CIGAR_SHIFT;
+	}
+	return l;
+}
+
+/********************
+ * BAM I/O routines *
+ ********************/
+
+bam_header_t *bam_header_init()
+{
+	bam_is_be = bam_is_big_endian();
+	return (bam_header_t*)calloc(1, sizeof(bam_header_t));
+}
+
+void bam_header_destroy(bam_header_t *header)
+{
+	int32_t i;
+	extern void bam_destroy_header_hash(bam_header_t *header);
+	if (header == 0) return;
+	if (header->target_name) {
+		for (i = 0; i < header->n_targets; ++i)
+			free(header->target_name[i]);
+		free(header->target_name);
+		free(header->target_len);
+	}
+	free(header->text);
+	if (header->dict) sam_header_free(header->dict);
+	if (header->rg2lib) sam_tbl_destroy(header->rg2lib);
+	bam_destroy_header_hash(header);
+	free(header);
+}
+
+bam_header_t *bam_header_read(bamFile fp)
+{
+	bam_header_t *header;
+	char buf[4];
+	int32_t i = 1, name_len;
+	// check EOF
+	i = bgzf_check_EOF(fp);
+	if (i < 0) {
+		// If the file is a pipe, checking the EOF marker will *always* fail
+		// with ESPIPE.  Suppress the error message in this case.
+		if (errno != ESPIPE) perror("[bam_header_read] bgzf_check_EOF");
+	}
+	else if (i == 0) fprintf(stderr, "[bam_header_read] EOF marker is absent.\n");
+	// read "BAM1"
+	if (bam_read(fp, buf, 4) != 4) return 0;
+	if (strncmp(buf, "BAM\001", 4)) {
+		fprintf(stderr, "[bam_header_read] wrong header\n");
+		return 0;
+	}
+	header = bam_header_init();
+	// read plain text and the number of reference sequences
+	bam_read(fp, &header->l_text, 4);
+	if (bam_is_be) bam_swap_endian_4p(&header->l_text);
+	header->text = (char*)calloc(header->l_text + 1, 1);
+	bam_read(fp, header->text, header->l_text);
+	bam_read(fp, &header->n_targets, 4);
+	if (bam_is_be) bam_swap_endian_4p(&header->n_targets);
+	// read reference sequence names and lengths
+	header->target_name = (char**)calloc(header->n_targets, sizeof(char*));
+	header->target_len = (uint32_t*)calloc(header->n_targets, 4);
+	for (i = 0; i != header->n_targets; ++i) {
+		bam_read(fp, &name_len, 4);
+		if (bam_is_be) bam_swap_endian_4p(&name_len);
+		header->target_name[i] = (char*)calloc(name_len, 1);
+		bam_read(fp, header->target_name[i], name_len);
+		bam_read(fp, &header->target_len[i], 4);
+		if (bam_is_be) bam_swap_endian_4p(&header->target_len[i]);
+	}
+	return header;
+}
+
+int bam_header_write(bamFile fp, const bam_header_t *header)
+{
+	char buf[4];
+	int32_t i, name_len, x;
+	// write "BAM1"
+	strncpy(buf, "BAM\001", 4);
+	bam_write(fp, buf, 4);
+	// write plain text and the number of reference sequences
+	if (bam_is_be) {
+		x = bam_swap_endian_4(header->l_text);
+		bam_write(fp, &x, 4);
+		if (header->l_text) bam_write(fp, header->text, header->l_text);
+		x = bam_swap_endian_4(header->n_targets);
+		bam_write(fp, &x, 4);
+	} else {
+		bam_write(fp, &header->l_text, 4);
+		if (header->l_text) bam_write(fp, header->text, header->l_text);
+		bam_write(fp, &header->n_targets, 4);
+	}
+	// write sequence names and lengths
+	for (i = 0; i != header->n_targets; ++i) {
+		char *p = header->target_name[i];
+		name_len = strlen(p) + 1;
+		if (bam_is_be) {
+			x = bam_swap_endian_4(name_len);
+			bam_write(fp, &x, 4);
+		} else bam_write(fp, &name_len, 4);
+		bam_write(fp, p, name_len);
+		if (bam_is_be) {
+			x = bam_swap_endian_4(header->target_len[i]);
+			bam_write(fp, &x, 4);
+		} else bam_write(fp, &header->target_len[i], 4);
+	}
+	return 0;
+}
+
+static void swap_endian_data(const bam1_core_t *c, int data_len, uint8_t *data)
+{
+	uint8_t *s;
+	uint32_t i, *cigar = (uint32_t*)(data + c->l_qname);
+	s = data + c->n_cigar*4 + c->l_qname + c->l_qseq + (c->l_qseq + 1)/2;
+	for (i = 0; i < c->n_cigar; ++i) bam_swap_endian_4p(&cigar[i]);
+	while (s < data + data_len) {
+		uint8_t type;
+		s += 2; // skip key
+		type = toupper(*s); ++s; // skip type
+		if (type == 'C' || type == 'A') ++s;
+		else if (type == 'S') { bam_swap_endian_2p(s); s += 2; }
+		else if (type == 'I' || type == 'F') { bam_swap_endian_4p(s); s += 4; }
+		else if (type == 'D') { bam_swap_endian_8p(s); s += 8; }
+		else if (type == 'Z' || type == 'H') { while (*s) ++s; ++s; }
+	}
+}
+
+int bam_read1(bamFile fp, bam1_t *b)
+{
+	bam1_core_t *c = &b->core;
+	int32_t block_len, ret, i;
+	uint32_t x[8];
+
+	assert(BAM_CORE_SIZE == 32);
+	if ((ret = bam_read(fp, &block_len, 4)) != 4) {
+		if (ret == 0) return -1; // normal end-of-file
+		else return -2; // truncated
+	}
+	if (bam_read(fp, x, BAM_CORE_SIZE) != BAM_CORE_SIZE) return -3;
+	if (bam_is_be) {
+		bam_swap_endian_4p(&block_len);
+		for (i = 0; i < 8; ++i) bam_swap_endian_4p(x + i);
+	}
+	c->tid = x[0]; c->pos = x[1];
+	c->bin = x[2]>>16; c->qual = x[2]>>8&0xff; c->l_qname = x[2]&0xff;
+	c->flag = x[3]>>16; c->n_cigar = x[3]&0xffff;
+	c->l_qseq = x[4];
+	c->mtid = x[5]; c->mpos = x[6]; c->isize = x[7];
+	b->data_len = block_len - BAM_CORE_SIZE;
+	if (b->m_data < b->data_len) {
+		b->m_data = b->data_len;
+		kroundup32(b->m_data);
+		b->data = (uint8_t*)realloc(b->data, b->m_data);
+	}
+	if (bam_read(fp, b->data, b->data_len) != b->data_len) return -4;
+	b->l_aux = b->data_len - c->n_cigar * 4 - c->l_qname - c->l_qseq - (c->l_qseq+1)/2;
+	if (bam_is_be) swap_endian_data(c, b->data_len, b->data);
+	return 4 + block_len;
+}
+
+inline int bam_write1_core(bamFile fp, const bam1_core_t *c, int data_len, uint8_t *data)
+{
+	uint32_t x[8], block_len = data_len + BAM_CORE_SIZE, y;
+	int i;
+	assert(BAM_CORE_SIZE == 32);
+	x[0] = c->tid;
+	x[1] = c->pos;
+	x[2] = (uint32_t)c->bin<<16 | c->qual<<8 | c->l_qname;
+	x[3] = (uint32_t)c->flag<<16 | c->n_cigar;
+	x[4] = c->l_qseq;
+	x[5] = c->mtid;
+	x[6] = c->mpos;
+	x[7] = c->isize;
+	if (bam_is_be) {
+		for (i = 0; i < 8; ++i) bam_swap_endian_4p(x + i);
+		y = block_len;
+		bam_write(fp, bam_swap_endian_4p(&y), 4);
+		swap_endian_data(c, data_len, data);
+	} else bam_write(fp, &block_len, 4);
+	bam_write(fp, x, BAM_CORE_SIZE);
+	bam_write(fp, data, data_len);
+	if (bam_is_be) swap_endian_data(c, data_len, data);
+	return 4 + block_len;
+}
+
+int bam_write1(bamFile fp, const bam1_t *b)
+{
+	return bam_write1_core(fp, &b->core, b->data_len, b->data);
+}
+
+char *bam_format1_core(const bam_header_t *header, const bam1_t *b, int of)
+{
+	uint8_t *s = bam1_seq(b), *t = bam1_qual(b);
+	int i;
+	const bam1_core_t *c = &b->core;
+	kstring_t str;
+	str.l = str.m = 0; str.s = 0;
+
+	ksprintf(&str, "%s\t", bam1_qname(b));
+	if (of == BAM_OFDEC) ksprintf(&str, "%d\t", c->flag);
+	else if (of == BAM_OFHEX) ksprintf(&str, "0x%x\t", c->flag);
+	else { // BAM_OFSTR
+		for (i = 0; i < 16; ++i)
+			if ((c->flag & 1<<i) && bam_flag2char_table[i])
+				kputc(bam_flag2char_table[i], &str);
+		kputc('\t', &str);
+	}
+	if (c->tid < 0) kputs("*\t", &str);
+	else ksprintf(&str, "%s\t", header->target_name[c->tid]);
+	ksprintf(&str, "%d\t%d\t", c->pos + 1, c->qual);
+	if (c->n_cigar == 0) kputc('*', &str);
+	else {
+		for (i = 0; i < c->n_cigar; ++i)
+			ksprintf(&str, "%d%c", bam1_cigar(b)[i]>>BAM_CIGAR_SHIFT, "MIDNSHP"[bam1_cigar(b)[i]&BAM_CIGAR_MASK]);
+	}
+	kputc('\t', &str);
+	if (c->mtid < 0) kputs("*\t", &str);
+	else if (c->mtid == c->tid) kputs("=\t", &str);
+	else ksprintf(&str, "%s\t", header->target_name[c->mtid]);
+	ksprintf(&str, "%d\t%d\t", c->mpos + 1, c->isize);
+	if (c->l_qseq) {
+		for (i = 0; i < c->l_qseq; ++i) kputc(bam_nt16_rev_table[bam1_seqi(s, i)], &str);
+		kputc('\t', &str);
+		if (t[0] == 0xff) kputc('*', &str);
+		else for (i = 0; i < c->l_qseq; ++i) kputc(t[i] + 33, &str);
+	} else ksprintf(&str, "*\t*");
+	s = bam1_aux(b);
+	while (s < b->data + b->data_len) {
+		uint8_t type, key[2];
+		key[0] = s[0]; key[1] = s[1];
+		s += 2; type = *s; ++s;
+		ksprintf(&str, "\t%c%c:", key[0], key[1]);
+		if (type == 'A') { ksprintf(&str, "A:%c", *s); ++s; }
+		else if (type == 'C') { ksprintf(&str, "i:%u", *s); ++s; }
+		else if (type == 'c') { ksprintf(&str, "i:%d", *s); ++s; }
+		else if (type == 'S') { ksprintf(&str, "i:%u", *(uint16_t*)s); s += 2; }
+		else if (type == 's') { ksprintf(&str, "i:%d", *(int16_t*)s); s += 2; }
+		else if (type == 'I') { ksprintf(&str, "i:%u", *(uint32_t*)s); s += 4; }
+		else if (type == 'i') { ksprintf(&str, "i:%d", *(int32_t*)s); s += 4; }
+		else if (type == 'f') { ksprintf(&str, "f:%g", *(float*)s); s += 4; }
+		else if (type == 'd') { ksprintf(&str, "d:%lg", *(double*)s); s += 8; }
+		else if (type == 'Z' || type == 'H') { ksprintf(&str, "%c:", type); while (*s) kputc(*s++, &str); ++s; }
+	}
+	return str.s;
+}
+
+char *bam_format1(const bam_header_t *header, const bam1_t *b)
+{
+	return bam_format1_core(header, b, BAM_OFDEC);
+}
+
+void bam_view1(const bam_header_t *header, const bam1_t *b)
+{
+	char *s = bam_format1(header, b);
+	printf("%s\n", s);
+	free(s);
+}
+
+// FIXME: we should also check the LB tag associated with each alignment
+const char *bam_get_library(bam_header_t *h, const bam1_t *b)
+{
+	const uint8_t *rg;
+	if (h->dict == 0) h->dict = sam_header_parse2(h->text);
+	if (h->rg2lib == 0) h->rg2lib = sam_header2tbl(h->dict, "RG", "ID", "LB");
+	rg = bam_aux_get(b, "RG");
+	return (rg == 0)? 0 : sam_tbl_get(h->rg2lib, (const char*)(rg + 1));
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam.h b/ext/samtools-0.1.7a_getUnique-0.1.3/bam.h
new file mode 100644
index 0000000..291b303
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam.h
@@ -0,0 +1,697 @@
+/* The MIT License
+
+   Copyright (c) 2008 Genome Research Ltd (GRL).
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Contact: Heng Li <lh3@sanger.ac.uk> */
+
+#ifndef BAM_BAM_H
+#define BAM_BAM_H
+
+/*!
+  @header
+
+  BAM library provides I/O and various operations on manipulating files
+  in the BAM (Binary Alignment/Mapping) or SAM (Sequence Alignment/Map)
+  format. It now supports importing from or exporting to TAM, sorting,
+  merging, generating pileup, and quickly retrieval of reads overlapped
+  with a specified region.
+
+  @copyright Genome Research Ltd.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#ifndef BAM_LITE
+#define BAM_VIRTUAL_OFFSET16
+#include "bgzf.h"
+/*! @abstract BAM file handler */
+typedef BGZF *bamFile;
+#define bam_open(fn, mode) bgzf_open(fn, mode)
+#define bam_dopen(fd, mode) bgzf_fdopen(fd, mode)
+#define bam_close(fp) bgzf_close(fp)
+#define bam_read(fp, buf, size) bgzf_read(fp, buf, size)
+#define bam_write(fp, buf, size) bgzf_write(fp, buf, size)
+#define bam_tell(fp) bgzf_tell(fp)
+#define bam_seek(fp, pos, dir) bgzf_seek(fp, pos, dir)
+#else
+#define BAM_TRUE_OFFSET
+#include <zlib.h>
+typedef gzFile bamFile;
+#define bam_open(fn, mode) gzopen(fn, mode)
+#define bam_dopen(fd, mode) gzdopen(fd, mode)
+#define bam_close(fp) gzclose(fp)
+#define bam_read(fp, buf, size) gzread(fp, buf, size)
+/* no bam_write/bam_tell/bam_seek() here */
+#endif
+
+/*! @typedef
+  @abstract Structure for the alignment header.
+  @field n_targets   number of reference sequences
+  @field target_name names of the reference sequences
+  @field target_len  lengths of the referene sequences
+  @field dict        header dictionary
+  @field hash        hash table for fast name lookup
+  @field rg2lib      hash table for @RG-ID -> LB lookup
+  @field l_text      length of the plain text in the header
+  @field text        plain text
+
+  @discussion Field hash points to null by default. It is a private
+  member.
+ */
+typedef struct {
+	int32_t n_targets;
+	char **target_name;
+	uint32_t *target_len;
+	void *dict, *hash, *rg2lib;
+	int l_text;
+	char *text;
+} bam_header_t;
+
+/*! @abstract the read is paired in sequencing, no matter whether it is mapped in a pair */
+#define BAM_FPAIRED        1
+/*! @abstract the read is mapped in a proper pair */
+#define BAM_FPROPER_PAIR   2
+/*! @abstract the read itself is unmapped; conflictive with BAM_FPROPER_PAIR */
+#define BAM_FUNMAP         4
+/*! @abstract the mate is unmapped */
+#define BAM_FMUNMAP        8
+/*! @abstract the read is mapped to the reverse strand */
+#define BAM_FREVERSE      16
+/*! @abstract the mate is mapped to the reverse strand */
+#define BAM_FMREVERSE     32
+/*! @abstract this is read1 */
+#define BAM_FREAD1        64
+/*! @abstract this is read2 */
+#define BAM_FREAD2       128
+/*! @abstract not primary alignment */
+#define BAM_FSECONDARY   256
+/*! @abstract QC failure */
+#define BAM_FQCFAIL      512
+/*! @abstract optical or PCR duplicate */
+#define BAM_FDUP        1024
+
+#define BAM_OFDEC          0
+#define BAM_OFHEX          1
+#define BAM_OFSTR          2
+
+/*! @abstract defautl mask for pileup */
+#define BAM_DEF_MASK (BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP)
+
+#define BAM_CORE_SIZE   sizeof(bam1_core_t)
+
+/**
+ * Describing how CIGAR operation/length is packed in a 32-bit integer.
+ */
+#define BAM_CIGAR_SHIFT 4
+#define BAM_CIGAR_MASK  ((1 << BAM_CIGAR_SHIFT) - 1)
+
+/*
+  CIGAR operations.
+ */
+/*! @abstract CIGAR: match */
+#define BAM_CMATCH      0
+/*! @abstract CIGAR: insertion to the reference */
+#define BAM_CINS        1
+/*! @abstract CIGAR: deletion from the reference */
+#define BAM_CDEL        2
+/*! @abstract CIGAR: skip on the reference (e.g. spliced alignment) */
+#define BAM_CREF_SKIP   3
+/*! @abstract CIGAR: clip on the read with clipped sequence present in qseq */
+#define BAM_CSOFT_CLIP  4
+/*! @abstract CIGAR: clip on the read with clipped sequence trimmed off */
+#define BAM_CHARD_CLIP  5
+/*! @abstract CIGAR: padding */
+#define BAM_CPAD        6
+
+/*! @typedef
+  @abstract Structure for core alignment information.
+  @field  tid     chromosome ID, defined by bam_header_t
+  @field  pos     0-based leftmost coordinate
+  @field  strand  strand; 0 for forward and 1 otherwise
+  @field  bin     bin calculated by bam_reg2bin()
+  @field  qual    mapping quality
+  @field  l_qname length of the query name
+  @field  flag    bitwise flag
+  @field  n_cigar number of CIGAR operations
+  @field  l_qseq  length of the query sequence (read)
+ */
+typedef struct {
+	int32_t tid;
+	int32_t pos;
+	uint32_t bin:16, qual:8, l_qname:8;
+	uint32_t flag:16, n_cigar:16;
+	int32_t l_qseq;
+	int32_t mtid;
+	int32_t mpos;
+	int32_t isize;
+} bam1_core_t;
+
+/*! @typedef
+  @abstract Structure for one alignment.
+  @field  core       core information about the alignment
+  @field  l_aux      length of auxiliary data
+  @field  data_len   current length of bam1_t::data
+  @field  m_data     maximum length of bam1_t::data
+  @field  data       all variable-length data, concatenated; structure: cigar-qname-seq-qual-aux
+
+  @discussion Notes:
+ 
+   1. qname is zero tailing and core.l_qname includes the tailing '\0'.
+   2. l_qseq is calculated from the total length of an alignment block
+      on reading or from CIGAR.
+ */
+typedef struct {
+	bam1_core_t core;
+	int l_aux, data_len, m_data;
+	uint8_t *data;
+} bam1_t;
+
+#define bam1_strand(b) (((b)->core.flag&BAM_FREVERSE) != 0)
+#define bam1_mstrand(b) (((b)->core.flag&BAM_FMREVERSE) != 0)
+
+/*! @function
+  @abstract  Get the CIGAR array
+  @param  b  pointer to an alignment
+  @return    pointer to the CIGAR array
+
+  @discussion In the CIGAR array, each element is a 32-bit integer. The
+  lower 4 bits gives a CIGAR operation and the higher 28 bits keep the
+  length of a CIGAR.
+ */
+#define bam1_cigar(b) ((uint32_t*)((b)->data + (b)->core.l_qname))
+
+/*! @function
+  @abstract  Get the name of the query
+  @param  b  pointer to an alignment
+  @return    pointer to the name string, null terminated
+ */
+#define bam1_qname(b) ((char*)((b)->data))
+
+/*! @function
+  @abstract  Get query sequence
+  @param  b  pointer to an alignment
+  @return    pointer to sequence
+
+  @discussion Each base is encoded in 4 bits: 1 for A, 2 for C, 4 for G,
+  8 for T and 15 for N. Two bases are packed in one byte with the base
+  at the higher 4 bits having smaller coordinate on the read. It is
+  recommended to use bam1_seqi() macro to get the base.
+ */
+#define bam1_seq(b) ((b)->data + (b)->core.n_cigar*4 + (b)->core.l_qname)
+
+/*! @function
+  @abstract  Get query quality
+  @param  b  pointer to an alignment
+  @return    pointer to quality string
+ */
+#define bam1_qual(b) ((b)->data + (b)->core.n_cigar*4 + (b)->core.l_qname + ((b)->core.l_qseq + 1)/2)
+
+/*! @function
+  @abstract  Get a base on read
+  @param  s  Query sequence returned by bam1_seq()
+  @param  i  The i-th position, 0-based
+  @return    4-bit integer representing the base.
+ */
+#define bam1_seqi(s, i) ((s)[(i)/2] >> 4*(1-(i)%2) & 0xf)
+
+/*! @function
+  @abstract  Get query sequence and quality
+  @param  b  pointer to an alignment
+  @return    pointer to the concatenated auxiliary data
+ */
+#define bam1_aux(b) ((b)->data + (b)->core.n_cigar*4 + (b)->core.l_qname + (b)->core.l_qseq + ((b)->core.l_qseq + 1)/2)
+
+#ifndef kroundup32
+/*! @function
+  @abstract  Round an integer to the next closest power-2 integer.
+  @param  x  integer to be rounded (in place)
+  @discussion x will be modified.
+ */
+#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
+#endif
+
+/*!
+  @abstract Whether the machine is big-endian; modified only in
+  bam_header_init().
+ */
+extern int bam_is_be;
+
+/*! @abstract Table for converting a nucleotide character to the 4-bit encoding. */
+extern unsigned char bam_nt16_table[256];
+
+/*! @abstract Table for converting a 4-bit encoded nucleotide to a letter. */
+extern char *bam_nt16_rev_table;
+
+extern char bam_nt16_nt4_table[];
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	/*! @abstract TAM file handler */
+	typedef struct __tamFile_t *tamFile;
+
+	/*!
+	  @abstract   Open a SAM file for reading, either uncompressed or compressed by gzip/zlib.
+	  @param  fn  SAM file name
+	  @return     SAM file handler
+	 */
+	tamFile sam_open(const char *fn);
+
+	/*!
+	  @abstract   Close a SAM file handler
+	  @param  fp  SAM file handler
+	 */
+	void sam_close(tamFile fp);
+
+	/*!
+	  @abstract      Read one alignment from a SAM file handler
+	  @param  fp     SAM file handler
+	  @param  header header information (ordered names of chromosomes)
+	  @param  b      read alignment; all members in b will be updated
+	  @return        0 if successful; otherwise negative
+	 */
+	int sam_read1(tamFile fp, bam_header_t *header, bam1_t *b);
+
+	/*!
+	  @abstract       Read header information from a TAB-delimited list file.
+	  @param  fn_list file name for the list
+	  @return         a pointer to the header structure
+
+	  @discussion Each line in this file consists of chromosome name and
+	  the length of chromosome.
+	 */
+	bam_header_t *sam_header_read2(const char *fn_list);
+
+	/*!
+	  @abstract       Read header from a SAM file (if present)
+	  @param  fp      SAM file handler
+	  @return         pointer to header struct; 0 if no @SQ lines available
+	 */
+	bam_header_t *sam_header_read(tamFile fp);
+
+	/*!
+	  @abstract       Parse @SQ lines a update a header struct
+	  @param  h       pointer to the header struct to be updated
+	  @return         number of target sequences
+
+	  @discussion bam_header_t::{n_targets,target_len,target_name} will
+	  be destroyed in the first place.
+	 */
+	int sam_header_parse(bam_header_t *h);
+
+	/*!
+	  @abstract       Parse @RG lines a update a header struct
+	  @param  h       pointer to the header struct to be updated
+	  @return         number of @RG lines
+
+	  @discussion bam_header_t::rg2lib will be destroyed in the first
+	  place.
+	 */
+	int sam_header_parse_rg(bam_header_t *h);
+
+#define sam_write1(header, b) bam_view1(header, b)
+
+	int bam_strmap_put(void *strmap, const char *rg, const char *lib);
+	const char *bam_strmap_get(const void *strmap, const char *rg);
+	void *bam_strmap_dup(const void*);
+	void *bam_strmap_init();
+	void bam_strmap_destroy(void *strmap);
+
+	/*!
+	  @abstract Initialize a header structure.
+	  @return   the pointer to the header structure
+
+	  @discussion This function also modifies the global variable
+	  bam_is_be.
+	 */
+	bam_header_t *bam_header_init();
+
+	/*!
+	  @abstract        Destroy a header structure.
+	  @param  header  pointer to the header
+	 */
+	void bam_header_destroy(bam_header_t *header);
+
+	/*!
+	  @abstract   Read a header structure from BAM.
+	  @param  fp  BAM file handler, opened by bam_open()
+	  @return     pointer to the header structure
+
+	  @discussion The file position indicator must be placed at the
+	  beginning of the file. Upon success, the position indicator will
+	  be set at the start of the first alignment.
+	 */
+	bam_header_t *bam_header_read(bamFile fp);
+
+	/*!
+	  @abstract      Write a header structure to BAM.
+	  @param  fp     BAM file handler
+	  @param  header pointer to the header structure
+	  @return        always 0 currently
+	 */
+	int bam_header_write(bamFile fp, const bam_header_t *header);
+
+	/*!
+	  @abstract   Read an alignment from BAM.
+	  @param  fp  BAM file handler
+	  @param  b   read alignment; all members are updated.
+	  @return     number of bytes read from the file
+
+	  @discussion The file position indicator must be
+	  placed right before an alignment. Upon success, this function
+	  will set the position indicator to the start of the next
+	  alignment. This function is not affected by the machine
+	  endianness.
+	 */
+	int bam_read1(bamFile fp, bam1_t *b);
+
+	/*!
+	  @abstract Write an alignment to BAM.
+	  @param  fp       BAM file handler
+	  @param  c        pointer to the bam1_core_t structure
+	  @param  data_len total length of variable size data related to
+	                   the alignment
+	  @param  data     pointer to the concatenated data
+	  @return          number of bytes written to the file
+
+	  @discussion This function is not affected by the machine
+	  endianness.
+	 */
+	int bam_write1_core(bamFile fp, const bam1_core_t *c, int data_len, uint8_t *data);
+
+	/*!
+	  @abstract   Write an alignment to BAM.
+	  @param  fp  BAM file handler
+	  @param  b   alignment to write
+	  @return     number of bytes written to the file
+
+	  @abstract It is equivalent to:
+	    bam_write1_core(fp, &b->core, b->data_len, b->data)
+	 */
+	int bam_write1(bamFile fp, const bam1_t *b);
+
+	/*! @function
+	  @abstract  Initiate a pointer to bam1_t struct
+	 */
+#define bam_init1() ((bam1_t*)calloc(1, sizeof(bam1_t)))
+
+	/*! @function
+	  @abstract  Free the memory allocated for an alignment.
+	  @param  b  pointer to an alignment
+	 */
+#define bam_destroy1(b) do {					\
+		if (b) { free((b)->data); free(b); }	\
+	} while (0)
+
+	/*!
+	  @abstract       Format a BAM record in the SAM format
+	  @param  header  pointer to the header structure
+	  @param  b       alignment to print
+	  @return         a pointer to the SAM string
+	 */
+	char *bam_format1(const bam_header_t *header, const bam1_t *b);
+
+	char *bam_format1_core(const bam_header_t *header, const bam1_t *b, int of);
+
+	const char *bam_get_library(bam_header_t *header, const bam1_t *b);
+
+	/*! @typedef
+	  @abstract Structure for one alignment covering the pileup position.
+	  @field  b      pointer to the alignment
+	  @field  qpos   position of the read base at the pileup site, 0-based
+	  @field  indel  indel length; 0 for no indel, positive for ins and negative for del
+	  @field  is_del 1 iff the base on the padded read is a deletion
+	  @field  level  the level of the read in the "viewer" mode
+
+	  @discussion See also bam_plbuf_push() and bam_lplbuf_push(). The
+	  difference between the two functions is that the former does not
+	  set bam_pileup1_t::level, while the later does. Level helps the
+	  implementation of alignment viewers, but calculating this has some
+	  overhead.
+	 */
+	typedef struct {
+		bam1_t *b;
+		int32_t qpos;
+		int indel, level;
+		uint32_t is_del:1, is_head:1, is_tail:1;
+	} bam_pileup1_t;
+
+	struct __bam_plbuf_t;
+	/*! @abstract pileup buffer */
+	typedef struct __bam_plbuf_t bam_plbuf_t;
+
+	void bam_plbuf_set_mask(bam_plbuf_t *buf, int mask);
+
+	/*! @typedef
+	  @abstract    Type of function to be called by bam_plbuf_push().
+	  @param  tid  chromosome ID as is defined in the header
+	  @param  pos  start coordinate of the alignment, 0-based
+	  @param  n    number of elements in pl array
+	  @param  pl   array of alignments
+	  @param  data user provided data
+	  @discussion  See also bam_plbuf_push(), bam_plbuf_init() and bam_pileup1_t.
+	 */
+	typedef int (*bam_pileup_f)(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data);
+
+	/*!
+	  @abstract     Reset a pileup buffer for another pileup process
+	  @param  buf   the pileup buffer to be reset
+	 */
+	void bam_plbuf_reset(bam_plbuf_t *buf);
+
+	/*!
+	  @abstract     Initialize a buffer for pileup.
+	  @param  func  fucntion to be called by bam_pileup_core()
+	  @param  data  user provided data
+	  @return       pointer to the pileup buffer
+	 */
+	bam_plbuf_t *bam_plbuf_init(bam_pileup_f func, void *data);
+
+	/*!
+	  @abstract    Destroy a pileup buffer.
+	  @param  buf  pointer to the pileup buffer
+	 */
+	void bam_plbuf_destroy(bam_plbuf_t *buf);
+
+	/*!
+	  @abstract    Push an alignment to the pileup buffer.
+	  @param  b    alignment to be pushed
+	  @param  buf  pileup buffer
+	  @see         bam_plbuf_init()
+	  @return      always 0 currently
+
+	  @discussion If all the alignments covering a particular site have
+	  been collected, this function will call the user defined function
+	  as is provided to bam_plbuf_init(). The coordinate of the site and
+	  all the alignments will be transferred to the user defined
+	  function as function parameters.
+	 
+	  When all the alignments are pushed to the buffer, this function
+	  needs to be called with b equal to NULL. This will flush the
+	  buffer. A pileup buffer can only be reused when bam_plbuf_reset()
+	  is called.
+	 */
+	int bam_plbuf_push(const bam1_t *b, bam_plbuf_t *buf);
+
+	int bam_pileup_file(bamFile fp, int mask, bam_pileup_f func, void *func_data);
+
+	struct __bam_lplbuf_t;
+	typedef struct __bam_lplbuf_t bam_lplbuf_t;
+
+	void bam_lplbuf_reset(bam_lplbuf_t *buf);
+
+	/*! @abstract  bam_plbuf_init() equivalent with level calculated. */
+	bam_lplbuf_t *bam_lplbuf_init(bam_pileup_f func, void *data);
+
+	/*! @abstract  bam_plbuf_destroy() equivalent with level calculated. */
+	void bam_lplbuf_destroy(bam_lplbuf_t *tv);
+
+	/*! @abstract  bam_plbuf_push() equivalent with level calculated. */
+	int bam_lplbuf_push(const bam1_t *b, bam_lplbuf_t *buf);
+
+	struct __bam_index_t;
+	typedef struct __bam_index_t bam_index_t;
+
+	/*!
+	  @abstract   Build index for a BAM file.
+	  @discussion Index file "fn.bai" will be created.
+	  @param  fn  name of the BAM file
+	  @return     always 0 currently
+	 */
+	int bam_index_build(const char *fn);
+
+	/*!
+	  @abstract   Load index from file "fn.bai".
+	  @param  fn  name of the BAM file (NOT the index file)
+	  @return     pointer to the index structure
+	 */
+	bam_index_t *bam_index_load(const char *fn);
+
+	/*!
+	  @abstract    Destroy an index structure.
+	  @param  idx  pointer to the index structure
+	 */
+	void bam_index_destroy(bam_index_t *idx);
+
+	/*! @typedef
+	  @abstract      Type of function to be called by bam_fetch().
+	  @param  b     the alignment
+	  @param  data  user provided data
+	 */
+	typedef int (*bam_fetch_f)(const bam1_t *b, void *data);
+
+	/*!
+	  @abstract Retrieve the alignments that are overlapped with the
+	  specified region.
+
+	  @discussion A user defined function will be called for each
+	  retrieved alignment ordered by its start position.
+
+	  @param  fp    BAM file handler
+	  @param  idx   pointer to the alignment index
+	  @param  tid   chromosome ID as is defined in the header
+	  @param  beg   start coordinate, 0-based
+	  @param  end   end coordinate, 0-based
+	  @param  data  user provided data (will be transferred to func)
+	  @param  func  user defined function
+	 */
+	int bam_fetch(bamFile fp, const bam_index_t *idx, int tid, int beg, int end, void *data, bam_fetch_f func);
+
+	/*!
+	  @abstract       Parse a region in the format: "chr2:100,000-200,000".
+	  @discussion     bam_header_t::hash will be initialized if empty.
+	  @param  header  pointer to the header structure
+	  @param  str     string to be parsed
+	  @param  ref_id  the returned chromosome ID
+	  @param  begin   the returned start coordinate
+	  @param  end     the returned end coordinate
+	  @return         0 on success; -1 on failure
+	 */
+	int bam_parse_region(bam_header_t *header, const char *str, int *ref_id, int *begin, int *end);
+
+	/*!
+	  @abstract       Retrieve data of a tag
+	  @param  b       pointer to an alignment struct
+	  @param  tag     two-character tag to be retrieved
+
+	  @return  pointer to the type and data. The first character is the
+	  type that can be 'iIsScCdfAZH'.
+
+	  @discussion  Use bam_aux2?() series to convert the returned data to
+	  the corresponding type.
+	*/
+	uint8_t *bam_aux_get(const bam1_t *b, const char tag[2]);
+
+	int32_t bam_aux2i(const uint8_t *s);
+	float bam_aux2f(const uint8_t *s);
+	double bam_aux2d(const uint8_t *s);
+	char bam_aux2A(const uint8_t *s);
+	char *bam_aux2Z(const uint8_t *s);
+
+	int bam_aux_del(bam1_t *b, uint8_t *s);
+	void bam_aux_append(bam1_t *b, const char tag[2], char type, int len, uint8_t *data);
+	uint8_t *bam_aux_get_core(bam1_t *b, const char tag[2]); // an alias of bam_aux_get()
+
+	/*!  
+	  @abstract Calculate the rightmost coordinate of an alignment on the
+	  reference genome.
+
+	  @param  c      pointer to the bam1_core_t structure
+	  @param  cigar  the corresponding CIGAR array (from bam1_t::cigar)
+	  @return        the rightmost coordinate, 0-based
+	*/
+	uint32_t bam_calend(const bam1_core_t *c, const uint32_t *cigar);
+
+	/*!
+	  @abstract      Calculate the length of the query sequence from CIGAR.
+	  @param  c      pointer to the bam1_core_t structure
+	  @param  cigar  the corresponding CIGAR array (from bam1_t::cigar)
+	  @return        length of the query sequence
+	*/
+	int32_t bam_cigar2qlen(const bam1_core_t *c, const uint32_t *cigar);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*!
+  @abstract    Calculate the minimum bin that contains a region [beg,end).
+  @param  beg  start of the region, 0-based
+  @param  end  end of the region, 0-based
+  @return      bin
+ */
+static inline int bam_reg2bin(uint32_t beg, uint32_t end)
+{
+	--end;
+	if (beg>>14 == end>>14) return 4681 + (beg>>14);
+	if (beg>>17 == end>>17) return  585 + (beg>>17);
+	if (beg>>20 == end>>20) return   73 + (beg>>20);
+	if (beg>>23 == end>>23) return    9 + (beg>>23);
+	if (beg>>26 == end>>26) return    1 + (beg>>26);
+	return 0;
+}
+
+/*!
+  @abstract     Copy an alignment
+  @param  bdst  destination alignment struct
+  @param  bsrc  source alignment struct
+  @return       pointer to the destination alignment struct
+ */
+static inline bam1_t *bam_copy1(bam1_t *bdst, const bam1_t *bsrc)
+{
+	uint8_t *data = bdst->data;
+	int m_data = bdst->m_data;   // backup data and m_data
+	if (m_data < bsrc->m_data) { // double the capacity
+		m_data = bsrc->m_data; kroundup32(m_data);
+		data = (uint8_t*)realloc(data, m_data);
+	}
+	memcpy(data, bsrc->data, bsrc->data_len); // copy var-len data
+	*bdst = *bsrc; // copy the rest
+	// restore the backup
+	bdst->m_data = m_data;
+	bdst->data = data;
+	return bdst;
+}
+
+/*!
+  @abstract     Duplicate an alignment
+  @param  src   source alignment struct
+  @return       pointer to the destination alignment struct
+ */
+static inline bam1_t *bam_dup1(const bam1_t *src)
+{
+	bam1_t *b;
+	b = bam_init1();
+	*b = *src;
+	b->m_data = b->data_len;
+	b->data = (uint8_t*)calloc(b->data_len, 1);
+	memcpy(b->data, src->data, b->data_len);
+	return b;
+}
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_aux.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_aux.c
new file mode 100644
index 0000000..89e99f2
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_aux.c
@@ -0,0 +1,182 @@
+#include <ctype.h>
+#include "bam.h"
+#include "khash.h"
+typedef char *str_p;
+KHASH_MAP_INIT_STR(s, int)
+KHASH_MAP_INIT_STR(r2l, str_p)
+
+void bam_aux_append(bam1_t *b, const char tag[2], char type, int len, uint8_t *data)
+{
+	int ori_len = b->data_len;
+	b->data_len += 3 + len;
+	b->l_aux += 3 + len;
+	if (b->m_data < b->data_len) {
+		b->m_data = b->data_len;
+		kroundup32(b->m_data);
+		b->data = (uint8_t*)realloc(b->data, b->m_data);
+	}
+	b->data[ori_len] = tag[0]; b->data[ori_len + 1] = tag[1];
+	b->data[ori_len + 2] = type;
+	memcpy(b->data + ori_len + 3, data, len);
+}
+
+uint8_t *bam_aux_get_core(bam1_t *b, const char tag[2])
+{
+	return bam_aux_get(b, tag);
+}
+
+#define __skip_tag(s) do { \
+		int type = toupper(*(s));										\
+		++(s);															\
+		if (type == 'C' || type == 'A') ++(s);							\
+		else if (type == 'S') (s) += 2;									\
+		else if (type == 'I' || type == 'F') (s) += 4;					\
+		else if (type == 'D') (s) += 8;									\
+		else if (type == 'Z' || type == 'H') { while (*(s)) ++(s); ++(s); } \
+	} while (0)
+
+uint8_t *bam_aux_get(const bam1_t *b, const char tag[2])
+{
+	uint8_t *s;
+	int y = tag[0]<<8 | tag[1];
+	s = bam1_aux(b);
+	while (s < b->data + b->data_len) {
+		int x = (int)s[0]<<8 | s[1];
+		s += 2;
+		if (x == y) return s;
+		__skip_tag(s);
+	}
+	return 0;
+}
+// s MUST BE returned by bam_aux_get()
+int bam_aux_del(bam1_t *b, uint8_t *s)
+{
+	uint8_t *p, *aux;
+	aux = bam1_aux(b);
+	p = s - 2;
+	__skip_tag(s);
+	memmove(p, s, b->l_aux - (s - aux));
+	b->data_len -= s - p;
+	b->l_aux -= s - p;
+	return 0;
+}
+
+void bam_init_header_hash(bam_header_t *header)
+{
+	if (header->hash == 0) {
+		int ret, i;
+		khiter_t iter;
+		khash_t(s) *h;
+		header->hash = h = kh_init(s);
+		for (i = 0; i < header->n_targets; ++i) {
+			iter = kh_put(s, h, header->target_name[i], &ret);
+			kh_value(h, iter) = i;
+		}
+	}
+}
+
+void bam_destroy_header_hash(bam_header_t *header)
+{
+	if (header->hash)
+		kh_destroy(s, (khash_t(s)*)header->hash);
+}
+
+int32_t bam_get_tid(const bam_header_t *header, const char *seq_name)
+{
+	khint_t k;
+	khash_t(s) *h = (khash_t(s)*)header->hash;
+	k = kh_get(s, h, seq_name);
+	return k == kh_end(h)? -1 : kh_value(h, k);
+}
+
+int bam_parse_region(bam_header_t *header, const char *str, int *ref_id, int *begin, int *end)
+{
+	char *s, *p;
+	int i, l, k;
+	khiter_t iter;
+	khash_t(s) *h;
+
+	bam_init_header_hash(header);
+	h = (khash_t(s)*)header->hash;
+
+	l = strlen(str);
+	p = s = (char*)malloc(l+1);
+	/* squeeze out "," */
+	for (i = k = 0; i != l; ++i)
+		if (str[i] != ',' && !isspace(str[i])) s[k++] = str[i];
+	s[k] = 0;
+	for (i = 0; i != k; ++i) if (s[i] == ':') break;
+	s[i] = 0;
+	iter = kh_get(s, h, s); /* get the ref_id */
+	if (iter == kh_end(h)) { // name not found
+		*ref_id = -1; free(s);
+		return -1;
+	}
+	*ref_id = kh_value(h, iter);
+	if (i == k) { /* dump the whole sequence */
+		*begin = 0; *end = 1<<29; free(s);
+		return -1;
+	}
+	for (p = s + i + 1; i != k; ++i) if (s[i] == '-') break;
+	*begin = atoi(p);
+	if (i < k) {
+		p = s + i + 1;
+		*end = atoi(p);
+	} else *end = 1<<29;
+	if (*begin > 0) --*begin;
+	free(s);
+	if (*begin > *end) {
+		fprintf(stderr, "[bam_parse_region] invalid region.\n");
+		return -1;
+	}
+	return 0;
+}
+
+int32_t bam_aux2i(const uint8_t *s)
+{
+	int type;
+	if (s == 0) return 0;
+	type = *s++;
+	if (type == 'c') return (int32_t)*(int8_t*)s;
+	else if (type == 'C') return (int32_t)*(uint8_t*)s;
+	else if (type == 's') return (int32_t)*(int16_t*)s;
+	else if (type == 'S') return (int32_t)*(uint16_t*)s;
+	else if (type == 'i' || type == 'I') return *(int32_t*)s;
+	else return 0;
+}
+
+float bam_aux2f(const uint8_t *s)
+{
+	int type;
+	type = *s++;
+	if (s == 0) return 0.0;
+	if (type == 'f') return *(float*)s;
+	else return 0.0;
+}
+
+double bam_aux2d(const uint8_t *s)
+{
+	int type;
+	type = *s++;
+	if (s == 0) return 0.0;
+	if (type == 'd') return *(double*)s;
+	else return 0.0;
+}
+
+char bam_aux2A(const uint8_t *s)
+{
+	int type;
+	type = *s++;
+	if (s == 0) return 0;
+	if (type == 'A') return *(char*)s;
+	else return 0;
+}
+
+char *bam_aux2Z(const uint8_t *s)
+{
+	int type;
+	type = *s++;
+	if (s == 0) return 0;
+	if (type == 'Z' || type == 'H') return (char*)s;
+	else return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_color.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_color.c
new file mode 100644
index 0000000..ce637f7
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_color.c
@@ -0,0 +1,127 @@
+#include <ctype.h>
+#include "bam.h"
+
+/*!
+ @abstract     Get the color encoding the previous and current base
+ @param b      pointer to an alignment
+ @param i      The i-th position, 0-based
+ @return       color
+
+ @discussion   Returns 0 no color information is found.
+ */
+char bam_aux_getCSi(bam1_t *b, int i)
+{
+	uint8_t *c = bam_aux_get(b, "CS");
+	char *cs = NULL;
+
+	// return the base if the tag was not found
+	if(0 == c) return 0;
+
+	cs = bam_aux2Z(c);
+	// adjust for strandedness and leading adaptor
+	if(bam1_strand(b)) i = strlen(cs) - 1 - i;
+	else i++;
+	return cs[i];
+}
+
+/*!
+ @abstract     Get the color quality of the color encoding the previous and current base
+ @param b      pointer to an alignment
+ @param i      The i-th position, 0-based
+ @return       color quality
+
+ @discussion   Returns 0 no color information is found.
+ */
+char bam_aux_getCQi(bam1_t *b, int i)
+{
+	uint8_t *c = bam_aux_get(b, "CQ");
+	char *cq = NULL;
+	
+	// return the base if the tag was not found
+	if(0 == c) return 0;
+
+	cq = bam_aux2Z(c);
+	// adjust for strandedness
+	if(bam1_strand(b)) i = strlen(cq) - 1 - i;
+	return cq[i];
+}
+
+char bam_aux_nt2int(char a)
+{
+	switch(toupper(a)) {
+		case 'A':
+			return 0;
+			break;
+		case 'C':
+			return 1;
+			break;
+		case 'G':
+			return 2;
+			break;
+		case 'T':
+			return 3;
+			break;
+		default:
+			return 4;
+			break;
+	}
+}
+
+char bam_aux_ntnt2cs(char a, char b)
+{
+	a = bam_aux_nt2int(a);
+	b = bam_aux_nt2int(b);
+	if(4 == a || 4 == b) return '4';
+	return "0123"[(int)(a ^ b)];
+}
+
+/*!
+ @abstract     Get the color error profile at the give position    
+ @param b      pointer to an alignment
+ @return       the original color if the color was an error, '-' (dash) otherwise
+
+ @discussion   Returns 0 no color information is found.
+ */
+char bam_aux_getCEi(bam1_t *b, int i)
+{
+	int cs_i;
+	uint8_t *c = bam_aux_get(b, "CS");
+	char *cs = NULL;
+	char prev_b, cur_b;
+	char cur_color, cor_color;
+
+	// return the base if the tag was not found
+	if(0 == c) return 0;
+	
+	cs = bam_aux2Z(c);
+
+	// adjust for strandedness and leading adaptor
+	if(bam1_strand(b)) { //reverse strand
+		cs_i = strlen(cs) - 1 - i;
+		// get current color
+		cur_color = cs[cs_i];
+		// get previous base.  Note: must rc adaptor
+		prev_b = (cs_i == 1) ? "TGCAN"[(int)bam_aux_nt2int(cs[0])] : bam_nt16_rev_table[bam1_seqi(bam1_seq(b), i+1)];
+		// get current base
+		cur_b = bam_nt16_rev_table[bam1_seqi(bam1_seq(b), i)]; 
+	}
+	else {
+		cs_i=i+1;
+		// get current color
+		cur_color = cs[cs_i];
+		// get previous base
+		prev_b = (0 == i) ? cs[0] : bam_nt16_rev_table[bam1_seqi(bam1_seq(b), i-1)];
+		// get current base
+		cur_b = bam_nt16_rev_table[bam1_seqi(bam1_seq(b), i)];
+	}
+
+	// corrected color
+	cor_color = bam_aux_ntnt2cs(prev_b, cur_b);
+
+	if(cur_color == cor_color) { 
+		return '-';
+	}
+	else {
+		return cur_color;
+	}
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_endian.h b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_endian.h
new file mode 100644
index 0000000..0fc74a8
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_endian.h
@@ -0,0 +1,42 @@
+#ifndef BAM_ENDIAN_H
+#define BAM_ENDIAN_H
+
+#include <stdint.h>
+
+static inline int bam_is_big_endian()
+{
+	long one= 1;
+	return !(*((char *)(&one)));
+}
+static inline uint16_t bam_swap_endian_2(uint16_t v)
+{
+	return (uint16_t)(((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8));
+}
+static inline void *bam_swap_endian_2p(void *x)
+{
+	*(uint16_t*)x = bam_swap_endian_2(*(uint16_t*)x);
+	return x;
+}
+static inline uint32_t bam_swap_endian_4(uint32_t v)
+{
+	v = ((v & 0x0000FFFFU) << 16) | (v >> 16);
+	return ((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8);
+}
+static inline void *bam_swap_endian_4p(void *x)
+{
+	*(uint32_t*)x = bam_swap_endian_4(*(uint32_t*)x);
+	return x;
+}
+static inline uint64_t bam_swap_endian_8(uint64_t v)
+{
+	v = ((v & 0x00000000FFFFFFFFLLU) << 32) | (v >> 32);
+	v = ((v & 0x0000FFFF0000FFFFLLU) << 16) | ((v & 0xFFFF0000FFFF0000LLU) >> 16);
+	return ((v & 0x00FF00FF00FF00FFLLU) << 8) | ((v & 0xFF00FF00FF00FF00LLU) >> 8);
+}
+static inline void *bam_swap_endian_8p(void *x)
+{
+	*(uint64_t*)x = bam_swap_endian_8(*(uint64_t*)x);
+	return x;
+}
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_import.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_import.c
new file mode 100644
index 0000000..9d463d1
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_import.c
@@ -0,0 +1,439 @@
+#include <zlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <assert.h>
+#ifdef _WIN32
+#include <fcntl.h>
+#endif
+#include "kstring.h"
+#include "bam.h"
+#include "sam_header.h"
+#include "kseq.h"
+#include "khash.h"
+
+KSTREAM_INIT(gzFile, gzread, 8192)
+KHASH_MAP_INIT_STR(ref, uint64_t)
+
+void bam_init_header_hash(bam_header_t *header);
+void bam_destroy_header_hash(bam_header_t *header);
+int32_t bam_get_tid(const bam_header_t *header, const char *seq_name);
+
+unsigned char bam_nt16_table[256] = {
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	 1, 2, 4, 8, 15,15,15,15, 15,15,15,15, 15, 0 /*=*/,15,15,
+	15, 1,14, 2, 13,15,15, 4, 11,15,15,12, 15, 3,15,15,
+	15,15, 5, 6,  8,15, 7, 9, 15,10,15,15, 15,15,15,15,
+	15, 1,14, 2, 13,15,15, 4, 11,15,15,12, 15, 3,15,15,
+	15,15, 5, 6,  8,15, 7, 9, 15,10,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
+	15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15
+};
+
+unsigned short bam_char2flag_table[256] = {
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,BAM_FREAD1,BAM_FREAD2,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	BAM_FPROPER_PAIR,0,BAM_FMREVERSE,0, 0,BAM_FMUNMAP,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, BAM_FDUP,0,BAM_FQCFAIL,0, 0,0,0,0, 0,0,0,0,
+	BAM_FPAIRED,0,BAM_FREVERSE,BAM_FSECONDARY, 0,BAM_FUNMAP,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
+};
+
+char *bam_nt16_rev_table = "=ACMGRSVTWYHKDBN";
+
+struct __tamFile_t {
+	gzFile fp;
+	kstream_t *ks;
+	kstring_t *str;
+	uint64_t n_lines;
+	int is_first;
+};
+
+char **__bam_get_lines(const char *fn, int *_n) // for bam_plcmd.c only
+{
+	char **list = 0, *s;
+	int n = 0, dret, m = 0;
+	gzFile fp = (strcmp(fn, "-") == 0)? gzdopen(fileno(stdin), "r") : gzopen(fn, "r");
+	kstream_t *ks;
+	kstring_t *str;
+	str = (kstring_t*)calloc(1, sizeof(kstring_t));
+	ks = ks_init(fp);
+	while (ks_getuntil(ks, '\n', str, &dret) > 0) {
+		if (n == m) {
+			m = m? m << 1 : 16;
+			list = (char**)realloc(list, m * sizeof(char*));
+		}
+		if (str->s[str->l-1] == '\r')
+			str->s[--str->l] = '\0';
+		s = list[n++] = (char*)calloc(str->l + 1, 1);
+		strcpy(s, str->s);
+	}
+	ks_destroy(ks);
+	gzclose(fp);
+	free(str->s); free(str);
+	*_n = n;
+	return list;
+}
+
+static bam_header_t *hash2header(const kh_ref_t *hash)
+{
+	bam_header_t *header;
+	khiter_t k;
+	header = bam_header_init();
+	header->n_targets = kh_size(hash);
+	header->target_name = (char**)calloc(kh_size(hash), sizeof(char*));
+	header->target_len = (uint32_t*)calloc(kh_size(hash), 4);
+	for (k = kh_begin(hash); k != kh_end(hash); ++k) {
+		if (kh_exist(hash, k)) {
+			int i = (int)kh_value(hash, k);
+			header->target_name[i] = (char*)kh_key(hash, k);
+			header->target_len[i] = kh_value(hash, k)>>32;
+		}
+	}
+	bam_init_header_hash(header);
+	return header;
+}
+bam_header_t *sam_header_read2(const char *fn)
+{
+	bam_header_t *header;
+	int c, dret, ret;
+	gzFile fp;
+	kstream_t *ks;
+	kstring_t *str;
+	kh_ref_t *hash;
+	khiter_t k;
+	if (fn == 0) return 0;
+	fp = (strcmp(fn, "-") == 0)? gzdopen(fileno(stdin), "r") : gzopen(fn, "r");
+	if (fp == 0) return 0;
+	hash = kh_init(ref);
+	ks = ks_init(fp);
+	str = (kstring_t*)calloc(1, sizeof(kstring_t));
+	while (ks_getuntil(ks, 0, str, &dret) > 0) {
+		char *s = strdup(str->s);
+		int len, i;
+		i = kh_size(hash);
+		ks_getuntil(ks, 0, str, &dret);
+		len = atoi(str->s);
+		k = kh_put(ref, hash, s, &ret);
+		kh_value(hash, k) = (uint64_t)len<<32 | i;
+		if (dret != '\n')
+			while ((c = ks_getc(ks)) != '\n' && c != -1);
+	}
+	ks_destroy(ks);
+	gzclose(fp);
+	free(str->s); free(str);
+	fprintf(stderr, "[sam_header_read2] %d sequences loaded.\n", kh_size(hash));
+	header = hash2header(hash);
+	kh_destroy(ref, hash);
+	return header;
+}
+static inline uint8_t *alloc_data(bam1_t *b, int size)
+{
+	if (b->m_data < size) {
+		b->m_data = size;
+		kroundup32(b->m_data);
+		b->data = (uint8_t*)realloc(b->data, b->m_data);
+	}
+	return b->data;
+}
+static inline void parse_error(int64_t n_lines, const char * __restrict msg)
+{
+	fprintf(stderr, "Parse error at line %lld: %s\n", (long long)n_lines, msg);
+	abort();
+}
+static inline void append_text(bam_header_t *header, kstring_t *str)
+{
+	int x = header->l_text, y = header->l_text + str->l + 2; // 2 = 1 byte dret + 1 byte null
+	kroundup32(x); kroundup32(y);
+	if (x < y) header->text = (char*)realloc(header->text, y);
+	strncpy(header->text + header->l_text, str->s, str->l+1); // we cannot use strcpy() here.
+	header->l_text += str->l + 1;
+	header->text[header->l_text] = 0;
+}
+
+int sam_header_parse(bam_header_t *h)
+{
+	char **tmp;
+	int i;
+	free(h->target_len); free(h->target_name);
+	h->n_targets = 0; h->target_len = 0; h->target_name = 0;
+	if (h->l_text < 3) return 0;
+	if (h->dict == 0) h->dict = sam_header_parse2(h->text);
+	tmp = sam_header2list(h->dict, "SQ", "SN", &h->n_targets);
+	if (h->n_targets == 0) return 0;
+	h->target_name = calloc(h->n_targets, sizeof(void*));
+	for (i = 0; i < h->n_targets; ++i)
+		h->target_name[i] = strdup(tmp[i]);
+	free(tmp);
+	tmp = sam_header2list(h->dict, "SQ", "LN", &h->n_targets);
+	h->target_len = calloc(h->n_targets, 4);
+	for (i = 0; i < h->n_targets; ++i)
+		h->target_len[i] = atoi(tmp[i]);
+	free(tmp);
+	return h->n_targets;
+}
+
+bam_header_t *sam_header_read(tamFile fp)
+{
+	int ret, dret;
+	bam_header_t *header = bam_header_init();
+	kstring_t *str = fp->str;
+	while ((ret = ks_getuntil(fp->ks, KS_SEP_TAB, str, &dret)) >= 0 && str->s[0] == '@') { // skip header
+		str->s[str->l] = dret; // note that str->s is NOT null terminated!!
+		append_text(header, str);
+		if (dret != '\n') {
+			ret = ks_getuntil(fp->ks, '\n', str, &dret);
+			str->s[str->l] = '\n'; // NOT null terminated!!
+			append_text(header, str);
+		}
+		++fp->n_lines;
+	}
+	sam_header_parse(header);
+	bam_init_header_hash(header);
+	fp->is_first = 1;
+	return header;
+}
+
+int sam_read1(tamFile fp, bam_header_t *header, bam1_t *b)
+{
+	int ret, doff, doff0, dret, z = 0;
+	bam1_core_t *c = &b->core;
+	kstring_t *str = fp->str;
+	kstream_t *ks = fp->ks;
+
+	if (fp->is_first) {
+		fp->is_first = 0;
+		ret = str->l;
+	} else {
+		do { // special consideration for empty lines
+			ret = ks_getuntil(fp->ks, KS_SEP_TAB, str, &dret);
+			if (ret >= 0) z += str->l + 1;
+		} while (ret == 0);
+	}
+	if (ret < 0) return -1;
+	++fp->n_lines;
+	doff = 0;
+
+	{ // name
+		c->l_qname = strlen(str->s) + 1;
+		memcpy(alloc_data(b, doff + c->l_qname) + doff, str->s, c->l_qname);
+		doff += c->l_qname;
+	}
+	{ // flag
+		long flag;
+		char *s;
+		ret = ks_getuntil(ks, KS_SEP_TAB, str, &dret); z += str->l + 1;
+		flag = strtol((char*)str->s, &s, 0);
+		if (*s) { // not the end of the string
+			flag = 0;
+			for (s = str->s; *s; ++s)
+				flag |= bam_char2flag_table[(int)*s];
+		}
+		c->flag = flag;
+	}
+	{ // tid, pos, qual
+		ret = ks_getuntil(ks, KS_SEP_TAB, str, &dret); z += str->l + 1; c->tid = bam_get_tid(header, str->s);
+		if (c->tid < 0 && strcmp(str->s, "*")) {
+			if (header->n_targets == 0) {
+				fprintf(stderr, "[sam_read1] missing header? Abort!\n");
+				exit(1);
+			} else fprintf(stderr, "[sam_read1] reference '%s' is recognized as '*'.\n", str->s);
+		}
+		ret = ks_getuntil(ks, KS_SEP_TAB, str, &dret); z += str->l + 1; c->pos = isdigit(str->s[0])? atoi(str->s) - 1 : -1;
+		ret = ks_getuntil(ks, KS_SEP_TAB, str, &dret); z += str->l + 1; c->qual = isdigit(str->s[0])? atoi(str->s) : 0;
+		if (ret < 0) return -2;
+	}
+	{ // cigar
+		char *s, *t;
+		int i, op;
+		long x;
+		c->n_cigar = 0;
+		if (ks_getuntil(ks, KS_SEP_TAB, str, &dret) < 0) return -3;
+		z += str->l + 1;
+		if (str->s[0] != '*') {
+			for (s = str->s; *s; ++s) {
+				if (isalpha(*s)) ++c->n_cigar;
+				else if (!isdigit(*s)) parse_error(fp->n_lines, "invalid CIGAR character");
+			}
+			b->data = alloc_data(b, doff + c->n_cigar * 4);
+			for (i = 0, s = str->s; i != c->n_cigar; ++i) {
+				x = strtol(s, &t, 10);
+				op = toupper(*t);
+				if (op == 'M' || op == '=' || op == 'X') op = BAM_CMATCH;
+				else if (op == 'I') op = BAM_CINS;
+				else if (op == 'D') op = BAM_CDEL;
+				else if (op == 'N') op = BAM_CREF_SKIP;
+				else if (op == 'S') op = BAM_CSOFT_CLIP;
+				else if (op == 'H') op = BAM_CHARD_CLIP;
+				else if (op == 'P') op = BAM_CPAD;
+				else parse_error(fp->n_lines, "invalid CIGAR operation");
+				s = t + 1;
+				bam1_cigar(b)[i] = x << BAM_CIGAR_SHIFT | op;
+			}
+			if (*s) parse_error(fp->n_lines, "unmatched CIGAR operation");
+			c->bin = bam_reg2bin(c->pos, bam_calend(c, bam1_cigar(b)));
+			doff += c->n_cigar * 4;
+		} else {
+			if (!(c->flag&BAM_FUNMAP)) {
+				fprintf(stderr, "Parse warning at line %lld: mapped sequence without CIGAR\n", (long long)fp->n_lines);
+				c->flag |= BAM_FUNMAP;
+			}
+			c->bin = bam_reg2bin(c->pos, c->pos + 1);
+		}
+	}
+	{ // mtid, mpos, isize
+		ret = ks_getuntil(ks, KS_SEP_TAB, str, &dret); z += str->l + 1;
+		c->mtid = strcmp(str->s, "=")? bam_get_tid(header, str->s) : c->tid;
+		ret = ks_getuntil(ks, KS_SEP_TAB, str, &dret); z += str->l + 1;
+		c->mpos = isdigit(str->s[0])? atoi(str->s) - 1 : -1;
+		ret = ks_getuntil(ks, KS_SEP_TAB, str, &dret); z += str->l + 1;
+		c->isize = (str->s[0] == '-' || isdigit(str->s[0]))? atoi(str->s) : 0;
+		if (ret < 0) return -4;
+	}
+	{ // seq and qual
+		int i;
+		uint8_t *p = 0;
+		if (ks_getuntil(ks, KS_SEP_TAB, str, &dret) < 0) return -5; // seq
+		z += str->l + 1;
+		if (strcmp(str->s, "*")) {
+			c->l_qseq = strlen(str->s);
+			if (c->n_cigar && c->l_qseq != (int32_t)bam_cigar2qlen(c, bam1_cigar(b)))
+				parse_error(fp->n_lines, "CIGAR and sequence length are inconsistent");
+			p = (uint8_t*)alloc_data(b, doff + c->l_qseq + (c->l_qseq+1)/2) + doff;
+			memset(p, 0, (c->l_qseq+1)/2);
+			for (i = 0; i < c->l_qseq; ++i)
+				p[i/2] |= bam_nt16_table[(int)str->s[i]] << 4*(1-i%2);
+		} else c->l_qseq = 0;
+		if (ks_getuntil(ks, KS_SEP_TAB, str, &dret) < 0) return -6; // qual
+		z += str->l + 1;
+		if (strcmp(str->s, "*") && c->l_qseq != strlen(str->s))
+			parse_error(fp->n_lines, "sequence and quality are inconsistent");
+		p += (c->l_qseq+1)/2;
+		if (strcmp(str->s, "*") == 0) for (i = 0; i < c->l_qseq; ++i) p[i] = 0xff;
+		else for (i = 0; i < c->l_qseq; ++i) p[i] = str->s[i] - 33;
+		doff += c->l_qseq + (c->l_qseq+1)/2;
+	}
+	doff0 = doff;
+	if (dret != '\n' && dret != '\r') { // aux
+		while (ks_getuntil(ks, KS_SEP_TAB, str, &dret) >= 0) {
+			uint8_t *s, type, key[2];
+			z += str->l + 1;
+			if (str->l < 6 || str->s[2] != ':' || str->s[4] != ':')
+				parse_error(fp->n_lines, "missing colon in auxiliary data");
+			key[0] = str->s[0]; key[1] = str->s[1];
+			type = str->s[3];
+			s = alloc_data(b, doff + 3) + doff;
+			s[0] = key[0]; s[1] = key[1]; s += 2; doff += 2;
+			if (type == 'A' || type == 'a' || type == 'c' || type == 'C') { // c and C for backward compatibility
+				s = alloc_data(b, doff + 2) + doff;
+				*s++ = 'A'; *s = str->s[5];
+				doff += 2;
+			} else if (type == 'I' || type == 'i') {
+				long long x;
+				s = alloc_data(b, doff + 5) + doff;
+				x = (long long)atoll(str->s + 5);
+				if (x < 0) {
+					if (x >= -127) {
+						*s++ = 'c'; *(int8_t*)s = (int8_t)x;
+						s += 1; doff += 2;
+					} else if (x >= -32767) {
+						*s++ = 's'; *(int16_t*)s = (int16_t)x;
+						s += 2; doff += 3;
+					} else {
+						*s++ = 'i'; *(int32_t*)s = (int32_t)x;
+						s += 4; doff += 5;
+						if (x < -2147483648ll)
+							fprintf(stderr, "Parse warning at line %lld: integer %lld is out of range.",
+									(long long)fp->n_lines, x);
+					}
+				} else {
+					if (x <= 255) {
+						*s++ = 'C'; *s++ = (uint8_t)x;
+						doff += 2;
+					} else if (x <= 65535) {
+						*s++ = 'S'; *(uint16_t*)s = (uint16_t)x;
+						s += 2; doff += 3;
+					} else {
+						*s++ = 'I'; *(uint32_t*)s = (uint32_t)x;
+						s += 4; doff += 5;
+						if (x > 4294967295ll)
+							fprintf(stderr, "Parse warning at line %lld: integer %lld is out of range.",
+									(long long)fp->n_lines, x);
+					}
+				}
+			} else if (type == 'f') {
+				s = alloc_data(b, doff + 5) + doff;
+				*s++ = 'f';
+				*(float*)s = (float)atof(str->s + 5);
+				s += 4; doff += 5;
+			} else if (type == 'd') {
+				s = alloc_data(b, doff + 9) + doff;
+				*s++ = 'd';
+				*(float*)s = (float)atof(str->s + 9);
+				s += 8; doff += 9;
+			} else if (type == 'Z' || type == 'H') {
+				int size = 1 + (str->l - 5) + 1;
+				if (type == 'H') { // check whether the hex string is valid
+					int i;
+					if ((str->l - 5) % 2 == 1) parse_error(fp->n_lines, "length of the hex string not even");
+					for (i = 0; i < str->l - 5; ++i) {
+						int c = toupper(str->s[5 + i]);
+						if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F')))
+							parse_error(fp->n_lines, "invalid hex character");
+					}
+				}
+				s = alloc_data(b, doff + size) + doff;
+				*s++ = type;
+				memcpy(s, str->s + 5, str->l - 5);
+				s[str->l - 5] = 0;
+				doff += size;
+			} else parse_error(fp->n_lines, "unrecognized type");
+			if (dret == '\n' || dret == '\r') break;
+		}
+	}
+	b->l_aux = doff - doff0;
+	b->data_len = doff;
+	return z;
+}
+
+tamFile sam_open(const char *fn)
+{
+	tamFile fp;
+	gzFile gzfp = (strcmp(fn, "-") == 0)? gzdopen(fileno(stdin), "rb") : gzopen(fn, "rb");
+	if (gzfp == 0) return 0;
+	fp = (tamFile)calloc(1, sizeof(struct __tamFile_t));
+	fp->str = (kstring_t*)calloc(1, sizeof(kstring_t));
+	fp->fp = gzfp;
+	fp->ks = ks_init(fp->fp);
+	return fp;
+}
+
+void sam_close(tamFile fp)
+{
+	if (fp) {
+		ks_destroy(fp->ks);
+		gzclose(fp->fp);
+		free(fp->str->s); free(fp->str);
+		free(fp);
+	}
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_index.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_index.c
new file mode 100644
index 0000000..a627884
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_index.c
@@ -0,0 +1,574 @@
+#include <ctype.h>
+#include <assert.h>
+#include "bam.h"
+#include "khash.h"
+#include "ksort.h"
+#include "bam_endian.h"
+#ifdef _USE_KNETFILE
+#include "knetfile.h"
+#endif
+
+/*!
+  @header
+
+  Alignment indexing. Before indexing, BAM must be sorted based on the
+  leftmost coordinate of alignments. In indexing, BAM uses two indices:
+  a UCSC binning index and a simple linear index. The binning index is
+  efficient for alignments spanning long distance, while the auxiliary
+  linear index helps to reduce unnecessary seek calls especially for
+  short alignments.
+
+  The UCSC binning scheme was suggested by Richard Durbin and Lincoln
+  Stein and is explained by Kent et al. (2002). In this scheme, each bin
+  represents a contiguous genomic region which can be fully contained in
+  another bin; each alignment is associated with a bin which represents
+  the smallest region containing the entire alignment. The binning
+  scheme is essentially another representation of R-tree. A distinct bin
+  uniquely corresponds to a distinct internal node in a R-tree. Bin A is
+  a child of Bin B if region A is contained in B.
+
+  In BAM, each bin may span 2^29, 2^26, 2^23, 2^20, 2^17 or 2^14 bp. Bin
+  0 spans a 512Mbp region, bins 1-8 span 64Mbp, 9-72 8Mbp, 73-584 1Mbp,
+  585-4680 128Kbp and bins 4681-37449 span 16Kbp regions. If we want to
+  find the alignments overlapped with a region [rbeg,rend), we need to
+  calculate the list of bins that may be overlapped the region and test
+  the alignments in the bins to confirm the overlaps. If the specified
+  region is short, typically only a few alignments in six bins need to
+  be retrieved. The overlapping alignments can be quickly fetched.
+
+ */
+
+#define BAM_MIN_CHUNK_GAP 32768
+// 1<<14 is the size of minimum bin.
+#define BAM_LIDX_SHIFT    14
+
+typedef struct {
+	uint64_t u, v;
+} pair64_t;
+
+#define pair64_lt(a,b) ((a).u < (b).u)
+KSORT_INIT(off, pair64_t, pair64_lt)
+
+typedef struct {
+	uint32_t m, n;
+	pair64_t *list;
+} bam_binlist_t;
+
+typedef struct {
+	int32_t n, m;
+	uint64_t *offset;
+} bam_lidx_t;
+
+KHASH_MAP_INIT_INT(i, bam_binlist_t)
+
+struct __bam_index_t {
+	int32_t n;
+	khash_t(i) **index;
+	bam_lidx_t *index2;
+};
+
+// requirement: len <= LEN_MASK
+static inline void insert_offset(khash_t(i) *h, int bin, uint64_t beg, uint64_t end)
+{
+	khint_t k;
+	bam_binlist_t *l;
+	int ret;
+	k = kh_put(i, h, bin, &ret);
+	l = &kh_value(h, k);
+	if (ret) { // not present
+		l->m = 1; l->n = 0;
+		l->list = (pair64_t*)calloc(l->m, 16);
+	}
+	if (l->n == l->m) {
+		l->m <<= 1;
+		l->list = (pair64_t*)realloc(l->list, l->m * 16);
+	}
+	l->list[l->n].u = beg; l->list[l->n++].v = end;
+}
+
+static inline void insert_offset2(bam_lidx_t *index2, bam1_t *b, uint64_t offset)
+{
+	int i, beg, end;
+	beg = b->core.pos >> BAM_LIDX_SHIFT;
+	end = (bam_calend(&b->core, bam1_cigar(b)) - 1) >> BAM_LIDX_SHIFT;
+	if (index2->m < end + 1) {
+		int old_m = index2->m;
+		index2->m = end + 1;
+		kroundup32(index2->m);
+		index2->offset = (uint64_t*)realloc(index2->offset, index2->m * 8);
+		memset(index2->offset + old_m, 0, 8 * (index2->m - old_m));
+	}
+	for (i = beg + 1; i <= end; ++i)
+		if (index2->offset[i] == 0) index2->offset[i] = offset;
+	index2->n = end + 1;
+}
+
+static void merge_chunks(bam_index_t *idx)
+{
+#if defined(BAM_TRUE_OFFSET) || defined(BAM_VIRTUAL_OFFSET16)
+	khash_t(i) *index;
+	int i, l, m;
+	khint_t k;
+	for (i = 0; i < idx->n; ++i) {
+		index = idx->index[i];
+		for (k = kh_begin(index); k != kh_end(index); ++k) {
+			bam_binlist_t *p;
+			if (!kh_exist(index, k)) continue;
+			p = &kh_value(index, k);
+			m = 0;
+			for (l = 1; l < p->n; ++l) {
+#ifdef BAM_TRUE_OFFSET
+				if (p->list[m].v + BAM_MIN_CHUNK_GAP > p->list[l].u) p->list[m].v = p->list[l].v;
+#else
+				if (p->list[m].v>>16 == p->list[l].u>>16) p->list[m].v = p->list[l].v;
+#endif
+				else p->list[++m] = p->list[l];
+			} // ~for(l)
+			p->n = m + 1;
+		} // ~for(k)
+	} // ~for(i)
+#endif // defined(BAM_TRUE_OFFSET) || defined(BAM_BGZF)
+}
+
+bam_index_t *bam_index_core(bamFile fp)
+{
+	bam1_t *b;
+	bam_header_t *h;
+	int i, ret;
+	bam_index_t *idx;
+	uint32_t last_bin, save_bin;
+	int32_t last_coor, last_tid, save_tid;
+	bam1_core_t *c;
+	uint64_t save_off, last_off;
+
+	idx = (bam_index_t*)calloc(1, sizeof(bam_index_t));
+	b = (bam1_t*)calloc(1, sizeof(bam1_t));
+	h = bam_header_read(fp);
+	c = &b->core;
+
+	idx->n = h->n_targets;
+	bam_header_destroy(h);
+	idx->index = (khash_t(i)**)calloc(idx->n, sizeof(void*));
+	for (i = 0; i < idx->n; ++i) idx->index[i] = kh_init(i);
+	idx->index2 = (bam_lidx_t*)calloc(idx->n, sizeof(bam_lidx_t));
+
+	save_bin = save_tid = last_tid = last_bin = 0xffffffffu;
+	save_off = last_off = bam_tell(fp); last_coor = 0xffffffffu;
+	while ((ret = bam_read1(fp, b)) >= 0) {
+		if (last_tid != c->tid) { // change of chromosomes
+			last_tid = c->tid;
+			last_bin = 0xffffffffu;
+		} else if (last_coor > c->pos) {
+			fprintf(stderr, "[bam_index_core] the alignment is not sorted (%s): %u > %u in %d-th chr\n",
+					bam1_qname(b), last_coor, c->pos, c->tid+1);
+			exit(1);
+		}
+		if (b->core.tid >= 0 && b->core.bin < 4681) insert_offset2(&idx->index2[b->core.tid], b, last_off);
+		if (c->bin != last_bin) { // then possibly write the binning index
+			if (save_bin != 0xffffffffu) // save_bin==0xffffffffu only happens to the first record
+				insert_offset(idx->index[save_tid], save_bin, save_off, last_off);
+			save_off = last_off;
+			save_bin = last_bin = c->bin;
+			save_tid = c->tid;
+			if (save_tid < 0) break;
+		}
+		if (bam_tell(fp) <= last_off) {
+			fprintf(stderr, "[bam_index_core] bug in BGZF/RAZF: %llx < %llx\n",
+					(unsigned long long)bam_tell(fp), (unsigned long long)last_off);
+			exit(1);
+		}
+		last_off = bam_tell(fp);
+		last_coor = b->core.pos;
+	}
+	if (save_tid >= 0) insert_offset(idx->index[save_tid], save_bin, save_off, bam_tell(fp));
+	merge_chunks(idx);
+	if (ret < -1) fprintf(stderr, "[bam_index_core] truncated file? Continue anyway. (%d)\n", ret);
+	free(b->data); free(b);
+	return idx;
+}
+
+void bam_index_destroy(bam_index_t *idx)
+{
+	khint_t k;
+	int i;
+	if (idx == 0) return;
+	for (i = 0; i < idx->n; ++i) {
+		khash_t(i) *index = idx->index[i];
+		bam_lidx_t *index2 = idx->index2 + i;
+		for (k = kh_begin(index); k != kh_end(index); ++k) {
+			if (kh_exist(index, k))
+				free(kh_value(index, k).list);
+		}
+		kh_destroy(i, index);
+		free(index2->offset);
+	}
+	free(idx->index); free(idx->index2);
+	free(idx);
+}
+
+void bam_index_save(const bam_index_t *idx, FILE *fp)
+{
+	int32_t i, size;
+	khint_t k;
+	fwrite("BAI\1", 1, 4, fp);
+	if (bam_is_be) {
+		uint32_t x = idx->n;
+		fwrite(bam_swap_endian_4p(&x), 4, 1, fp);
+	} else fwrite(&idx->n, 4, 1, fp);
+	for (i = 0; i < idx->n; ++i) {
+		khash_t(i) *index = idx->index[i];
+		bam_lidx_t *index2 = idx->index2 + i;
+		// write binning index
+		size = kh_size(index);
+		if (bam_is_be) { // big endian
+			uint32_t x = size;
+			fwrite(bam_swap_endian_4p(&x), 4, 1, fp);
+		} else fwrite(&size, 4, 1, fp);
+		for (k = kh_begin(index); k != kh_end(index); ++k) {
+			if (kh_exist(index, k)) {
+				bam_binlist_t *p = &kh_value(index, k);
+				if (bam_is_be) { // big endian
+					uint32_t x;
+					x = kh_key(index, k); fwrite(bam_swap_endian_4p(&x), 4, 1, fp);
+					x = p->n; fwrite(bam_swap_endian_4p(&x), 4, 1, fp);
+					for (x = 0; (int)x < p->n; ++x) {
+						bam_swap_endian_8p(&p->list[x].u);
+						bam_swap_endian_8p(&p->list[x].v);
+					}
+					fwrite(p->list, 16, p->n, fp);
+					for (x = 0; (int)x < p->n; ++x) {
+						bam_swap_endian_8p(&p->list[x].u);
+						bam_swap_endian_8p(&p->list[x].v);
+					}
+				} else {
+					fwrite(&kh_key(index, k), 4, 1, fp);
+					fwrite(&p->n, 4, 1, fp);
+					fwrite(p->list, 16, p->n, fp);
+				}
+			}
+		}
+		// write linear index (index2)
+		if (bam_is_be) {
+			int x = index2->n;
+			fwrite(bam_swap_endian_4p(&x), 4, 1, fp);
+		} else fwrite(&index2->n, 4, 1, fp);
+		if (bam_is_be) { // big endian
+			int x;
+			for (x = 0; (int)x < index2->n; ++x)
+				bam_swap_endian_8p(&index2->offset[x]);
+			fwrite(index2->offset, 8, index2->n, fp);
+			for (x = 0; (int)x < index2->n; ++x)
+				bam_swap_endian_8p(&index2->offset[x]);
+		} else fwrite(index2->offset, 8, index2->n, fp);
+	}
+	fflush(fp);
+}
+
+static bam_index_t *bam_index_load_core(FILE *fp)
+{
+	int i;
+	char magic[4];
+	bam_index_t *idx;
+	if (fp == 0) {
+		fprintf(stderr, "[bam_index_load_core] fail to load index.\n");
+		return 0;
+	}
+	fread(magic, 1, 4, fp);
+	if (strncmp(magic, "BAI\1", 4)) {
+		fprintf(stderr, "[bam_index_load] wrong magic number.\n");
+		fclose(fp);
+		return 0;
+	}
+	idx = (bam_index_t*)calloc(1, sizeof(bam_index_t));	
+	fread(&idx->n, 4, 1, fp);
+	if (bam_is_be) bam_swap_endian_4p(&idx->n);
+	idx->index = (khash_t(i)**)calloc(idx->n, sizeof(void*));
+	idx->index2 = (bam_lidx_t*)calloc(idx->n, sizeof(bam_lidx_t));
+	for (i = 0; i < idx->n; ++i) {
+		khash_t(i) *index;
+		bam_lidx_t *index2 = idx->index2 + i;
+		uint32_t key, size;
+		khint_t k;
+		int j, ret;
+		bam_binlist_t *p;
+		index = idx->index[i] = kh_init(i);
+		// load binning index
+		fread(&size, 4, 1, fp);
+		if (bam_is_be) bam_swap_endian_4p(&size);
+		for (j = 0; j < (int)size; ++j) {
+			fread(&key, 4, 1, fp);
+			if (bam_is_be) bam_swap_endian_4p(&key);
+			k = kh_put(i, index, key, &ret);
+			p = &kh_value(index, k);
+			fread(&p->n, 4, 1, fp);
+			if (bam_is_be) bam_swap_endian_4p(&p->n);
+			p->m = p->n;
+			p->list = (pair64_t*)malloc(p->m * 16);
+			fread(p->list, 16, p->n, fp);
+			if (bam_is_be) {
+				int x;
+				for (x = 0; x < p->n; ++x) {
+					bam_swap_endian_8p(&p->list[x].u);
+					bam_swap_endian_8p(&p->list[x].v);
+				}
+			}
+		}
+		// load linear index
+		fread(&index2->n, 4, 1, fp);
+		if (bam_is_be) bam_swap_endian_4p(&index2->n);
+		index2->m = index2->n;
+		index2->offset = (uint64_t*)calloc(index2->m, 8);
+		fread(index2->offset, index2->n, 8, fp);
+		if (bam_is_be)
+			for (j = 0; j < index2->n; ++j) bam_swap_endian_8p(&index2->offset[j]);
+	}
+	return idx;
+}
+
+bam_index_t *bam_index_load_local(const char *_fn)
+{
+	FILE *fp;
+	char *fnidx, *fn;
+
+	if (strstr(_fn, "ftp://") == _fn || strstr(_fn, "http://") == _fn) {
+		const char *p;
+		int l = strlen(_fn);
+		for (p = _fn + l - 1; p >= _fn; --p)
+			if (*p == '/') break;
+		fn = strdup(p + 1);
+	} else fn = strdup(_fn);
+	fnidx = (char*)calloc(strlen(fn) + 5, 1);
+	strcpy(fnidx, fn); strcat(fnidx, ".bai");
+	fp = fopen(fnidx, "r");
+	if (fp == 0) { // try "{base}.bai"
+		char *s = strstr(fn, "bam");
+		if (s == fn + strlen(fn) - 3) {
+			strcpy(fnidx, fn);
+			fnidx[strlen(fn)-1] = 'i';
+			fp = fopen(fnidx, "r");
+		}
+	}
+	free(fnidx); free(fn);
+	if (fp) {
+		bam_index_t *idx = bam_index_load_core(fp);
+		fclose(fp);
+		return idx;
+	} else return 0;
+}
+
+#ifdef _USE_KNETFILE
+static void download_from_remote(const char *url)
+{
+	const int buf_size = 1 * 1024 * 1024;
+	char *fn;
+	FILE *fp;
+	uint8_t *buf;
+	knetFile *fp_remote;
+	int l;
+	if (strstr(url, "ftp://") != url && strstr(url, "http://") != url) return;
+	l = strlen(url);
+	for (fn = (char*)url + l - 1; fn >= url; --fn)
+		if (*fn == '/') break;
+	++fn; // fn now points to the file name
+	fp_remote = knet_open(url, "r");
+	if (fp_remote == 0) {
+		fprintf(stderr, "[download_from_remote] fail to open remote file.\n");
+		return;
+	}
+	if ((fp = fopen(fn, "w")) == 0) {
+		fprintf(stderr, "[download_from_remote] fail to create file in the working directory.\n");
+		knet_close(fp_remote);
+		return;
+	}
+	buf = (uint8_t*)calloc(buf_size, 1);
+	while ((l = knet_read(fp_remote, buf, buf_size)) != 0)
+		fwrite(buf, 1, l, fp);
+	free(buf);
+	fclose(fp);
+	knet_close(fp_remote);
+}
+#else
+static void download_from_remote(const char *url)
+{
+	return;
+}
+#endif
+
+bam_index_t *bam_index_load(const char *fn)
+{
+	bam_index_t *idx;
+	idx = bam_index_load_local(fn);
+	if (idx == 0 && (strstr(fn, "ftp://") == fn || strstr(fn, "http://") == fn)) {
+		char *fnidx = calloc(strlen(fn) + 5, 1);
+		strcat(strcpy(fnidx, fn), ".bai");
+		fprintf(stderr, "[bam_index_load] attempting to download the remote index file.\n");
+		download_from_remote(fnidx);
+		idx = bam_index_load_local(fn);
+	}
+	if (idx == 0) fprintf(stderr, "[bam_index_load] fail to load BAM index.\n");
+	return idx;
+}
+
+int bam_index_build2(const char *fn, const char *_fnidx)
+{
+	char *fnidx;
+	FILE *fpidx;
+	bamFile fp;
+	bam_index_t *idx;
+	if ((fp = bam_open(fn, "r")) == 0) {
+		fprintf(stderr, "[bam_index_build2] fail to open the BAM file.\n");
+		return -1;
+	}
+	idx = bam_index_core(fp);
+	bam_close(fp);
+	if (_fnidx == 0) {
+		fnidx = (char*)calloc(strlen(fn) + 5, 1);
+		strcpy(fnidx, fn); strcat(fnidx, ".bai");
+	} else fnidx = strdup(_fnidx);
+	fpidx = fopen(fnidx, "w");
+	if (fpidx == 0) {
+		fprintf(stderr, "[bam_index_build2] fail to create the index file.\n");
+		free(fnidx);
+		return -1;
+	}
+	bam_index_save(idx, fpidx);
+	bam_index_destroy(idx);
+	fclose(fpidx);
+	free(fnidx);
+	return 0;
+}
+
+int bam_index_build(const char *fn)
+{
+	return bam_index_build2(fn, 0);
+}
+
+int bam_index(int argc, char *argv[])
+{
+	if (argc < 2) {
+		fprintf(stderr, "Usage: samtools index <in.bam> [<out.index>]\n");
+		return 1;
+	}
+	if (argc >= 3) bam_index_build2(argv[1], argv[2]);
+	else bam_index_build(argv[1]);
+	return 0;
+}
+
+#define MAX_BIN 37450 // =(8^6-1)/7+1
+
+static inline int reg2bins(uint32_t beg, uint32_t end, uint16_t list[MAX_BIN])
+{
+	int i = 0, k;
+	--end;
+	list[i++] = 0;
+	for (k =    1 + (beg>>26); k <=    1 + (end>>26); ++k) list[i++] = k;
+	for (k =    9 + (beg>>23); k <=    9 + (end>>23); ++k) list[i++] = k;
+	for (k =   73 + (beg>>20); k <=   73 + (end>>20); ++k) list[i++] = k;
+	for (k =  585 + (beg>>17); k <=  585 + (end>>17); ++k) list[i++] = k;
+	for (k = 4681 + (beg>>14); k <= 4681 + (end>>14); ++k) list[i++] = k;
+	return i;
+}
+
+static inline int is_overlap(uint32_t beg, uint32_t end, const bam1_t *b)
+{
+	uint32_t rbeg = b->core.pos;
+	uint32_t rend = b->core.n_cigar? bam_calend(&b->core, bam1_cigar(b)) : b->core.pos + 1;
+	return (rend > beg && rbeg < end);
+}
+
+// bam_fetch helper function retrieves 
+pair64_t * get_chunk_coordinates(const bam_index_t *idx, int tid, int beg, int end, int* cnt_off)
+{
+	uint16_t *bins;
+	int i, n_bins, n_off;
+	pair64_t *off;
+	khint_t k;
+	khash_t(i) *index;
+	uint64_t min_off;
+
+	bins = (uint16_t*)calloc(MAX_BIN, 2);
+	n_bins = reg2bins(beg, end, bins);
+	index = idx->index[tid];
+	min_off = (beg>>BAM_LIDX_SHIFT >= idx->index2[tid].n)? 0 : idx->index2[tid].offset[beg>>BAM_LIDX_SHIFT];
+	for (i = n_off = 0; i < n_bins; ++i) {
+		if ((k = kh_get(i, index, bins[i])) != kh_end(index))
+			n_off += kh_value(index, k).n;
+	}
+	if (n_off == 0) {
+		free(bins); return 0;
+	}
+	off = (pair64_t*)calloc(n_off, 16);
+	for (i = n_off = 0; i < n_bins; ++i) {
+		if ((k = kh_get(i, index, bins[i])) != kh_end(index)) {
+			int j;
+			bam_binlist_t *p = &kh_value(index, k);
+			for (j = 0; j < p->n; ++j)
+				if (p->list[j].v > min_off) off[n_off++] = p->list[j];
+		}
+	}
+	free(bins);
+	{
+		bam1_t *b = (bam1_t*)calloc(1, sizeof(bam1_t));
+		int l;
+		ks_introsort(off, n_off, off);
+		// resolve completely contained adjacent blocks
+		for (i = 1, l = 0; i < n_off; ++i)
+			if (off[l].v < off[i].v)
+				off[++l] = off[i];
+		n_off = l + 1;
+		// resolve overlaps between adjacent blocks; this may happen due to the merge in indexing
+		for (i = 1; i < n_off; ++i)
+			if (off[i-1].v >= off[i].u) off[i-1].v = off[i].u;
+		{ // merge adjacent blocks
+#if defined(BAM_TRUE_OFFSET) || defined(BAM_VIRTUAL_OFFSET16)
+			for (i = 1, l = 0; i < n_off; ++i) {
+#ifdef BAM_TRUE_OFFSET
+				if (off[l].v + BAM_MIN_CHUNK_GAP > off[i].u) off[l].v = off[i].v;
+#else
+				if (off[l].v>>16 == off[i].u>>16) off[l].v = off[i].v;
+#endif
+				else off[++l] = off[i];
+			}
+			n_off = l + 1;
+#endif
+		}
+		bam_destroy1(b);
+	}
+	*cnt_off = n_off;
+	return off;
+}
+
+int bam_fetch(bamFile fp, const bam_index_t *idx, int tid, int beg, int end, void *data, bam_fetch_f func)
+{
+	int n_off;
+	pair64_t *off = get_chunk_coordinates(idx, tid, beg, end, &n_off);
+	if (off == 0) return 0;
+	{
+		// retrive alignments
+		uint64_t curr_off;
+		int i, ret, n_seeks;
+		n_seeks = 0; i = -1; curr_off = 0;
+		bam1_t *b = (bam1_t*)calloc(1, sizeof(bam1_t));
+		for (;;) {
+			if (curr_off == 0 || curr_off >= off[i].v) { // then jump to the next chunk
+				if (i == n_off - 1) break; // no more chunks
+				if (i >= 0) assert(curr_off == off[i].v); // otherwise bug
+				if (i < 0 || off[i].v != off[i+1].u) { // not adjacent chunks; then seek
+					bam_seek(fp, off[i+1].u, SEEK_SET);
+					curr_off = bam_tell(fp);
+					++n_seeks;
+				}
+				++i;
+			}
+			if ((ret = bam_read1(fp, b)) > 0) {
+				curr_off = bam_tell(fp);
+				if (b->core.tid != tid || b->core.pos >= end) break; // no need to proceed
+				else if (is_overlap(beg, end, b)) func(b, data);
+			} else break; // end of file
+		}
+//		fprintf(stderr, "[bam_fetch] # seek calls: %d\n", n_seeks);
+		bam_destroy1(b);
+	}
+	free(off);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_lpileup.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_lpileup.c
new file mode 100644
index 0000000..d4dd63b
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_lpileup.c
@@ -0,0 +1,198 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include "bam.h"
+#include "ksort.h"
+
+#define TV_GAP 2
+
+typedef struct __freenode_t {
+	uint32_t level:28, cnt:4;
+	struct __freenode_t *next;
+} freenode_t, *freenode_p;
+
+#define freenode_lt(a,b) ((a)->cnt < (b)->cnt || ((a)->cnt == (b)->cnt && (a)->level < (b)->level))
+KSORT_INIT(node, freenode_p, freenode_lt)
+
+/* Memory pool, similar to the one in bam_pileup.c */
+typedef struct {
+	int cnt, n, max;
+	freenode_t **buf;
+} mempool_t;
+
+static mempool_t *mp_init()
+{
+	return (mempool_t*)calloc(1, sizeof(mempool_t));
+}
+static void mp_destroy(mempool_t *mp)
+{
+	int k;
+	for (k = 0; k < mp->n; ++k) free(mp->buf[k]);
+	free(mp->buf); free(mp);
+}
+static inline freenode_t *mp_alloc(mempool_t *mp)
+{
+	++mp->cnt;
+	if (mp->n == 0) return (freenode_t*)calloc(1, sizeof(freenode_t));
+	else return mp->buf[--mp->n];
+}
+static inline void mp_free(mempool_t *mp, freenode_t *p)
+{
+	--mp->cnt; p->next = 0; p->cnt = TV_GAP;
+	if (mp->n == mp->max) {
+		mp->max = mp->max? mp->max<<1 : 256;
+		mp->buf = (freenode_t**)realloc(mp->buf, sizeof(freenode_t*) * mp->max);
+	}
+	mp->buf[mp->n++] = p;
+}
+
+/* core part */
+struct __bam_lplbuf_t {
+	int max, n_cur, n_pre;
+	int max_level, *cur_level, *pre_level;
+	mempool_t *mp;
+	freenode_t **aux, *head, *tail;
+	int n_nodes, m_aux;
+	bam_pileup_f func;
+	void *user_data;
+	bam_plbuf_t *plbuf;
+};
+
+void bam_lplbuf_reset(bam_lplbuf_t *buf)
+{
+	freenode_t *p, *q;
+	bam_plbuf_reset(buf->plbuf);
+	for (p = buf->head; p->next;) {
+		q = p->next;
+		mp_free(buf->mp, p);
+		p = q;
+	}
+	buf->head = buf->tail;
+	buf->max_level = 0;
+	buf->n_cur = buf->n_pre = 0;
+	buf->n_nodes = 0;
+}
+
+static int tview_func(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data)
+{
+	bam_lplbuf_t *tv = (bam_lplbuf_t*)data;
+	freenode_t *p;
+	int i, l, max_level;
+	// allocate memory if necessary
+	if (tv->max < n) { // enlarge
+		tv->max = n;
+		kroundup32(tv->max);
+		tv->cur_level = (int*)realloc(tv->cur_level, sizeof(int) * tv->max);
+		tv->pre_level = (int*)realloc(tv->pre_level, sizeof(int) * tv->max);
+	}
+	tv->n_cur = n;
+	// update cnt
+	for (p = tv->head; p->next; p = p->next)
+		if (p->cnt > 0) --p->cnt;
+	// calculate cur_level[]
+	max_level = 0;
+	for (i = l = 0; i < n; ++i) {
+		const bam_pileup1_t *p = pl + i;
+		if (p->is_head) {
+			if (tv->head->next && tv->head->cnt == 0) { // then take a free slot
+				freenode_t *p = tv->head->next;
+				tv->cur_level[i] = tv->head->level;
+				mp_free(tv->mp, tv->head);
+				tv->head = p;
+				--tv->n_nodes;
+			} else tv->cur_level[i] = ++tv->max_level;
+		} else {
+			tv->cur_level[i] = tv->pre_level[l++];
+			if (p->is_tail) { // then return a free slot
+				tv->tail->level = tv->cur_level[i];
+				tv->tail->next = mp_alloc(tv->mp);
+				tv->tail = tv->tail->next;
+				++tv->n_nodes;
+			}
+		}
+		if (tv->cur_level[i] > max_level) max_level = tv->cur_level[i];
+		((bam_pileup1_t*)p)->level = tv->cur_level[i];
+	}
+	assert(l == tv->n_pre);
+	tv->func(tid, pos, n, pl, tv->user_data);
+	// sort the linked list
+	if (tv->n_nodes) {
+		freenode_t *q;
+		if (tv->n_nodes + 1 > tv->m_aux) { // enlarge
+			tv->m_aux = tv->n_nodes + 1;
+			kroundup32(tv->m_aux);
+			tv->aux = (freenode_t**)realloc(tv->aux, sizeof(void*) * tv->m_aux);
+		}
+		for (p = tv->head, i = l = 0; p->next;) {
+			if (p->level > max_level) { // then discard this entry
+				q = p->next;
+				mp_free(tv->mp, p);
+				p = q;
+			} else {
+				tv->aux[i++] = p;
+				p = p->next;
+			}
+		}
+		tv->aux[i] = tv->tail; // add a proper tail for the loop below
+		tv->n_nodes = i;
+		if (tv->n_nodes) {
+			ks_introsort(node, tv->n_nodes, tv->aux);
+			for (i = 0; i < tv->n_nodes; ++i) tv->aux[i]->next = tv->aux[i+1];
+			tv->head = tv->aux[0];
+		} else tv->head = tv->tail;
+	}
+	// clean up
+	tv->max_level = max_level;
+	memcpy(tv->pre_level, tv->cur_level, tv->n_cur * 4);
+	// squeeze out terminated levels
+	for (i = l = 0; i < n; ++i) {
+		const bam_pileup1_t *p = pl + i;
+		if (!p->is_tail)
+			tv->pre_level[l++] = tv->pre_level[i];
+	}
+	tv->n_pre = l;
+/*
+	fprintf(stderr, "%d\t", pos+1);
+	for (i = 0; i < n; ++i) {
+		const bam_pileup1_t *p = pl + i;
+		if (p->is_head) fprintf(stderr, "^");
+		if (p->is_tail) fprintf(stderr, "$");
+		fprintf(stderr, "%d,", p->level);
+	}
+	fprintf(stderr, "\n");
+*/
+	return 0;
+}
+
+bam_lplbuf_t *bam_lplbuf_init(bam_pileup_f func, void *data)
+{
+	bam_lplbuf_t *tv;
+	tv = (bam_lplbuf_t*)calloc(1, sizeof(bam_lplbuf_t));
+	tv->mp = mp_init();
+	tv->head = tv->tail = mp_alloc(tv->mp);
+	tv->func = func;
+	tv->user_data = data;
+	tv->plbuf = bam_plbuf_init(tview_func, tv);
+	return (bam_lplbuf_t*)tv;
+}
+
+void bam_lplbuf_destroy(bam_lplbuf_t *tv)
+{
+	freenode_t *p, *q;
+	free(tv->cur_level); free(tv->pre_level);
+	bam_plbuf_destroy(tv->plbuf);
+	free(tv->aux);
+	for (p = tv->head; p->next;) {
+		q = p->next;
+		mp_free(tv->mp, p); p = q;
+	}
+	mp_free(tv->mp, p);
+	assert(tv->mp->cnt == 0);
+	mp_destroy(tv->mp);
+	free(tv);
+}
+
+int bam_lplbuf_push(const bam1_t *b, bam_lplbuf_t *tv)
+{
+	return bam_plbuf_push(b, tv->plbuf);
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_maqcns.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_maqcns.c
new file mode 100644
index 0000000..71c2185
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_maqcns.c
@@ -0,0 +1,601 @@
+#include <math.h>
+#include <assert.h>
+#include "bam.h"
+#include "bam_maqcns.h"
+#include "ksort.h"
+#include "kaln.h"
+KSORT_INIT_GENERIC(uint32_t)
+
+#define INDEL_WINDOW_SIZE 50
+#define INDEL_EXT_DEP 0.9
+
+typedef struct __bmc_aux_t {
+	int max;
+	uint32_t *info;
+} bmc_aux_t;
+
+typedef struct {
+	float esum[4], fsum[4];
+	uint32_t c[4];
+	uint32_t rms_mapQ;
+} glf_call_aux_t;
+
+char bam_nt16_nt4_table[] = { 4, 0, 1, 4, 2, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4 };
+
+/*
+  P(<b1,b2>) = \theta \sum_{i=1}^{N-1} 1/i
+  P(D|<b1,b2>) = \sum_{k=1}^{N-1} p_k 1/2 [(k/N)^n_2(1-k/N)^n_1 + (k/N)^n1(1-k/N)^n_2]
+  p_k = 1/k / \sum_{i=1}^{N-1} 1/i
+ */
+static void cal_het(bam_maqcns_t *aa)
+{
+	int k, n1, n2;
+	double sum_harmo; // harmonic sum
+	double poly_rate;
+
+	free(aa->lhet);
+	aa->lhet = (double*)calloc(256 * 256, sizeof(double));
+	sum_harmo = 0.0;
+	for (k = 1; k <= aa->n_hap - 1; ++k)
+		sum_harmo += 1.0 / k;
+	for (n1 = 0; n1 < 256; ++n1) {
+		for (n2 = 0; n2 < 256; ++n2) {
+			long double sum = 0.0;
+			double lC = aa->is_soap? 0 : lgamma(n1+n2+1) - lgamma(n1+1) - lgamma(n2+1); // \binom{n1+n2}{n1}
+			for (k = 1; k <= aa->n_hap - 1; ++k) {
+				double pk = 1.0 / k / sum_harmo;
+				double log1 = log((double)k/aa->n_hap);
+				double log2 = log(1.0 - (double)k/aa->n_hap);
+				sum += pk * 0.5 * (expl(log1*n2) * expl(log2*n1) + expl(log1*n1) * expl(log2*n2));
+			}
+			aa->lhet[n1<<8|n2] = lC + logl(sum);
+		}
+	}
+	poly_rate = aa->het_rate * sum_harmo;
+	aa->q_r = -4.343 * log(2.0 * poly_rate / (1.0 - poly_rate));
+}
+
+/** initialize the helper structure */
+static void cal_coef(bam_maqcns_t *aa)
+{
+	int k, n, q;
+	long double sum_a[257], b[256], q_c[256], tmp[256], fk2[256];
+	double *lC;
+
+	// aa->lhet will be allocated and initialized 
+	free(aa->fk); free(aa->coef);
+	aa->coef = 0;
+	aa->fk = (double*)calloc(256, sizeof(double));
+	aa->fk[0] = fk2[0] = 1.0;
+	for (n = 1; n != 256; ++n) {
+		aa->fk[n] = pow(aa->theta, n) * (1.0 - aa->eta) + aa->eta;
+		fk2[n] = aa->fk[n>>1]; // this is an approximation, assuming reads equally likely come from both strands
+	}
+	if (aa->is_soap) return;
+	aa->coef = (double*)calloc(256*256*64, sizeof(double));
+	lC = (double*)calloc(256 * 256, sizeof(double));
+	for (n = 1; n != 256; ++n)
+		for (k = 1; k <= n; ++k)
+			lC[n<<8|k] = lgamma(n+1) - lgamma(k+1) - lgamma(n-k+1);
+	for (q = 1; q != 64; ++q) {
+		double e = pow(10.0, -q/10.0);
+		double le = log(e);
+		double le1 = log(1.0-e);
+		for (n = 1; n != 256; ++n) {
+			double *coef = aa->coef + (q<<16|n<<8);
+			sum_a[n+1] = 0.0;
+			for (k = n; k >= 0; --k) { // a_k = \sum_{i=k}^n C^n_k \epsilon^k (1-\epsilon)^{n-k}
+				sum_a[k] = sum_a[k+1] + expl(lC[n<<8|k] + k*le + (n-k)*le1);
+				b[k] = sum_a[k+1] / sum_a[k];
+				if (b[k] > 0.99) b[k] = 0.99;
+			}
+			for (k = 0; k != n; ++k) // log(\bar\beta_{nk}(\bar\epsilon)^{f_k})
+				q_c[k] = -4.343 * fk2[k] * logl(b[k] / e);
+			for (k = 1; k != n; ++k) q_c[k] += q_c[k-1]; // \prod_{i=0}^k c_i
+			for (k = 0; k <= n; ++k) { // powl() in 64-bit mode seems broken on my Mac OS X 10.4.9
+				tmp[k] = -4.343 * logl(1.0 - expl(fk2[k] * logl(b[k])));
+				coef[k] = (k? q_c[k-1] : 0) + tmp[k]; // this is the final c_{nk}
+			}
+		}
+	}
+	free(lC);
+}
+
+bam_maqcns_t *bam_maqcns_init()
+{
+	bam_maqcns_t *bm;
+	bm = (bam_maqcns_t*)calloc(1, sizeof(bam_maqcns_t));
+	bm->aux = (bmc_aux_t*)calloc(1, sizeof(bmc_aux_t));
+	bm->het_rate = 0.001;
+	bm->theta = 0.85;
+	bm->n_hap = 2;
+	bm->eta = 0.03;
+	bm->cap_mapQ = 60;
+	return bm;
+}
+
+void bam_maqcns_prepare(bam_maqcns_t *bm)
+{
+	cal_coef(bm); cal_het(bm);
+}
+
+void bam_maqcns_destroy(bam_maqcns_t *bm)
+{
+	if (bm == 0) return;
+	free(bm->lhet); free(bm->fk); free(bm->coef); free(bm->aux->info);
+	free(bm->aux); free(bm);
+}
+
+glf1_t *bam_maqcns_glfgen(int _n, const bam_pileup1_t *pl, uint8_t ref_base, bam_maqcns_t *bm)
+{
+	glf_call_aux_t *b;
+	int i, j, k, w[8], c, n;
+	glf1_t *g = (glf1_t*)calloc(1, sizeof(glf1_t));
+	float p[16], min_p = 1e30;
+	uint64_t rms;
+
+	g->ref_base = ref_base;
+	if (_n == 0) return g;
+
+	// construct aux array
+	if (bm->aux->max < _n) {
+		bm->aux->max = _n;
+		kroundup32(bm->aux->max);
+		bm->aux->info = (uint32_t*)realloc(bm->aux->info, 4 * bm->aux->max);
+	}
+	for (i = n = 0; i < _n; ++i) {
+		const bam_pileup1_t *p = pl + i;
+		uint32_t q, x = 0, qq;
+		if (p->is_del || (p->b->core.flag&BAM_FUNMAP)) continue;
+		q = (uint32_t)bam1_qual(p->b)[p->qpos];
+		x |= (uint32_t)bam1_strand(p->b) << 18 | q << 8 | p->b->core.qual;
+		if (p->b->core.qual < q) q = p->b->core.qual;
+		x |= q << 24;
+		qq = bam1_seqi(bam1_seq(p->b), p->qpos);
+		q = bam_nt16_nt4_table[qq? qq : ref_base];
+		if (!p->is_del && q < 4) x |= 1 << 21 | q << 16;
+		bm->aux->info[n++] = x;
+	}
+	ks_introsort(uint32_t, n, bm->aux->info);
+	// generate esum and fsum
+	b = (glf_call_aux_t*)calloc(1, sizeof(glf_call_aux_t));
+	for (k = 0; k != 8; ++k) w[k] = 0;
+	rms = 0;
+	for (j = n - 1; j >= 0; --j) { // calculate esum and fsum
+		uint32_t info = bm->aux->info[j];
+		int tmp;
+		if (info>>24 < 4 && (info>>8&0x3f) != 0) info = 4<<24 | (info&0xffffff);
+		k = info>>16&7;
+		if (info>>24 > 0) {
+			b->esum[k&3] += bm->fk[w[k]] * (info>>24);
+			b->fsum[k&3] += bm->fk[w[k]];
+			if (w[k] < 0xff) ++w[k];
+			++b->c[k&3];
+		}
+		tmp = (int)(info&0xff) < bm->cap_mapQ? (int)(info&0xff) : bm->cap_mapQ;
+		rms += tmp * tmp;
+	}
+	b->rms_mapQ = (uint8_t)(sqrt((double)rms / n) + .499);
+	// rescale ->c[]
+	for (j = c = 0; j != 4; ++j) c += b->c[j];
+	if (c > 255) {
+		for (j = 0; j != 4; ++j) b->c[j] = (int)(254.0 * b->c[j] / c + 0.5);
+		for (j = c = 0; j != 4; ++j) c += b->c[j];
+	}
+	if (!bm->is_soap) {
+		// generate likelihood
+		for (j = 0; j != 4; ++j) {
+			// homozygous
+			float tmp1, tmp3;
+			int tmp2, bar_e;
+			for (k = 0, tmp1 = tmp3 = 0.0, tmp2 = 0; k != 4; ++k) {
+				if (j == k) continue;
+				tmp1 += b->esum[k]; tmp2 += b->c[k]; tmp3 += b->fsum[k];
+			}
+			if (tmp2) {
+				bar_e = (int)(tmp1 / tmp3 + 0.5);
+				if (bar_e < 4) bar_e = 4; // should not happen
+				if (bar_e > 63) bar_e = 63;
+				p[j<<2|j] = tmp1 + bm->coef[bar_e<<16|c<<8|tmp2];
+			} else p[j<<2|j] = 0.0; // all the bases are j
+			// heterozygous
+			for (k = j + 1; k < 4; ++k) {
+				for (i = 0, tmp2 = 0, tmp1 = tmp3 = 0.0; i != 4; ++i) {
+					if (i == j || i == k) continue;
+					tmp1 += b->esum[i]; tmp2 += b->c[i]; tmp3 += b->fsum[i];
+				}
+				if (tmp2) {
+					bar_e = (int)(tmp1 / tmp3 + 0.5);
+					if (bar_e < 4) bar_e = 4;
+					if (bar_e > 63) bar_e = 63;
+					p[j<<2|k] = p[k<<2|j] = -4.343 * bm->lhet[b->c[j]<<8|b->c[k]] + tmp1 + bm->coef[bar_e<<16|c<<8|tmp2];
+				} else p[j<<2|k] = p[k<<2|j] = -4.343 * bm->lhet[b->c[j]<<8|b->c[k]]; // all the bases are either j or k
+			}
+			//
+			for (k = 0; k != 4; ++k)
+				if (p[j<<2|k] < 0.0) p[j<<2|k] = 0.0;
+		}
+
+		{ // fix p[k<<2|k]
+			float max1, max2, min1, min2;
+			int max_k, min_k;
+			max_k = min_k = -1;
+			max1 = max2 = -1.0; min1 = min2 = 1e30;
+			for (k = 0; k < 4; ++k) {
+				if (b->esum[k] > max1) {
+					max2 = max1; max1 = b->esum[k]; max_k = k;
+				} else if (b->esum[k] > max2) max2 = b->esum[k];
+			}
+			for (k = 0; k < 4; ++k) {
+				if (p[k<<2|k] < min1) {
+					min2 = min1; min1 = p[k<<2|k]; min_k = k;
+				} else if (p[k<<2|k] < min2) min2 = p[k<<2|k];
+			}
+			if (max1 > max2 && (min_k != max_k || min1 + 1.0 > min2))
+				p[max_k<<2|max_k] = min1 > 1.0? min1 - 1.0 : 0.0;
+		}
+	} else { // apply the SOAP model
+		// generate likelihood
+		for (j = 0; j != 4; ++j) {
+			float tmp;
+			// homozygous
+			for (k = 0, tmp = 0.0; k != 4; ++k)
+				if (j != k) tmp += b->esum[k];
+			p[j<<2|j] = tmp;
+			// heterozygous
+			for (k = j + 1; k < 4; ++k) {
+				for (i = 0, tmp = 0.0; i != 4; ++i)
+					if (i != j && i != k) tmp += b->esum[i];
+				p[j<<2|k] = p[k<<2|j] = -4.343 * bm->lhet[b->c[j]<<8|b->c[k]] + tmp;
+			}
+		}
+	}
+
+	// convert necessary information to glf1_t
+	g->ref_base = ref_base; g->max_mapQ = b->rms_mapQ;
+	g->depth = n > 16777215? 16777215 : n;
+	for (j = 0; j != 4; ++j)
+		for (k = j; k < 4; ++k)
+			if (p[j<<2|k] < min_p) min_p = p[j<<2|k];
+	g->min_lk = min_p > 255.0? 255 : (int)(min_p + 0.5);
+	for (j = c = 0; j != 4; ++j)
+		for (k = j; k < 4; ++k)
+			g->lk[c++] = p[j<<2|k]-min_p > 255.0? 255 : (int)(p[j<<2|k]-min_p + 0.5);
+
+	free(b);
+	return g;
+}
+
+uint32_t glf2cns(const glf1_t *g, int q_r)
+{
+	int i, j, k, tmp[16], min = 10000, min2 = 10000, min3 = 10000, min_g = -1, min_g2 = -1;
+	uint32_t x = 0;
+	for (i = k = 0; i < 4; ++i)
+		for (j = i; j < 4; ++j) {
+			tmp[j<<2|i] = -1;
+			tmp[i<<2|j] = g->lk[k++] + (i == j? 0 : q_r);
+		}
+	for (i = 0; i < 16; ++i) {
+		if (tmp[i] < 0) continue;
+		if (tmp[i] < min) {
+			min3 = min2; min2 = min; min = tmp[i]; min_g2 = min_g; min_g = i;
+		} else if (tmp[i] < min2) {
+			min3 = min2; min2 = tmp[i]; min_g2 = i;
+		} else if (tmp[i] < min3) min3 = tmp[i];
+	}
+	x = min_g >= 0? (1U<<(min_g>>2&3) | 1U<<(min_g&3)) << 28 : 0xf << 28;
+	x |= min_g2 >= 0? (1U<<(min_g2>>2&3) | 1U<<(min_g2&3)) << 24 : 0xf << 24;
+	x |= (uint32_t)g->max_mapQ << 16;
+	x |= min2 < 10000? (min2 - min < 256? min2 - min : 255) << 8 : 0xff << 8;
+	x |= min2 < 10000 && min3 < 10000? (min3 - min2 < 256? min3 - min2 : 255) : 0xff;
+	return x;
+}
+
+uint32_t bam_maqcns_call(int n, const bam_pileup1_t *pl, bam_maqcns_t *bm)
+{
+	glf1_t *g;
+	uint32_t x;
+	if (n) {
+		g = bam_maqcns_glfgen(n, pl, 0xf, bm);
+		x = glf2cns(g, (int)(bm->q_r + 0.5));
+		free(g);
+	} else x = 0xfU<<28 | 0xfU<<24;
+	return x;
+}
+
+/************** *****************/
+
+bam_maqindel_opt_t *bam_maqindel_opt_init()
+{
+	bam_maqindel_opt_t *mi = (bam_maqindel_opt_t*)calloc(1, sizeof(bam_maqindel_opt_t));
+	mi->q_indel = 40;
+	mi->r_indel = 0.00015;
+	//
+	mi->mm_penalty = 3;
+	mi->indel_err = 4;
+	mi->ambi_thres = 10;
+	return mi;
+}
+
+void bam_maqindel_ret_destroy(bam_maqindel_ret_t *mir)
+{
+	if (mir == 0) return;
+	free(mir->s[0]); free(mir->s[1]); free(mir);
+}
+
+int bam_tpos2qpos(const bam1_core_t *c, const uint32_t *cigar, int32_t tpos, int is_left, int32_t *_tpos)
+{
+	int k, x = c->pos, y = 0, last_y = 0;
+	*_tpos = c->pos;
+	for (k = 0; k < c->n_cigar; ++k) {
+		int op = cigar[k] & BAM_CIGAR_MASK;
+		int l = cigar[k] >> BAM_CIGAR_SHIFT;
+		if (op == BAM_CMATCH) {
+			if (c->pos > tpos) return y;
+			if (x + l > tpos) {
+				*_tpos = tpos;
+				return y + (tpos - x);
+			}
+			x += l; y += l;
+			last_y = y;
+		} else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) y += l;
+		else if (op == BAM_CDEL || op == BAM_CREF_SKIP) {
+			if (x + l > tpos) {
+				*_tpos = is_left? x : x + l;
+				return y;
+			}
+			x += l;
+		}
+	}
+	*_tpos = x;
+	return last_y;
+}
+
+#define MINUS_CONST 0x10000000
+
+bam_maqindel_ret_t *bam_maqindel(int n, int pos, const bam_maqindel_opt_t *mi, const bam_pileup1_t *pl, const char *ref,
+								 int _n_types, int *_types)
+{
+	int i, j, n_types, *types, left, right, max_rd_len = 0;
+	bam_maqindel_ret_t *ret = 0;
+	// if there is no proposed indel, check if there is an indel from the alignment
+	if (_n_types == 0) {
+		for (i = 0; i < n; ++i) {
+			const bam_pileup1_t *p = pl + i;
+			if (!(p->b->core.flag&BAM_FUNMAP) && p->indel != 0) break;
+		}
+		if (i == n) return 0; // no indel
+	}
+	{ // calculate how many types of indels are available (set n_types and types)
+		int m;
+		uint32_t *aux;
+		aux = (uint32_t*)calloc(n + _n_types + 1, 4);
+		m = 0;
+		aux[m++] = MINUS_CONST; // zero indel is always a type
+		for (i = 0; i < n; ++i) {
+			const bam_pileup1_t *p = pl + i;
+			if (!(p->b->core.flag&BAM_FUNMAP) && p->indel != 0)
+				aux[m++] = MINUS_CONST + p->indel;
+			j = bam_cigar2qlen(&p->b->core, bam1_cigar(p->b));
+			if (j > max_rd_len) max_rd_len = j;
+		}
+		if (_n_types) // then also add this to aux[]
+			for (i = 0; i < _n_types; ++i)
+				if (_types[i]) aux[m++] = MINUS_CONST + _types[i];
+		ks_introsort(uint32_t, m, aux);
+		// squeeze out identical types
+		for (i = 1, n_types = 1; i < m; ++i)
+			if (aux[i] != aux[i-1]) ++n_types;
+		types = (int*)calloc(n_types, sizeof(int));
+		j = 0;
+		types[j++] = aux[0] - MINUS_CONST; 
+		for (i = 1; i < m; ++i) {
+			if (aux[i] != aux[i-1])
+				types[j++] = aux[i] - MINUS_CONST;
+		}
+		free(aux);
+	}
+	{ // calculate left and right boundary
+		left = pos > INDEL_WINDOW_SIZE? pos - INDEL_WINDOW_SIZE : 0;
+		right = pos + INDEL_WINDOW_SIZE;
+		if (types[0] < 0) right -= types[0];
+		// in case the alignments stand out the reference
+		for (i = pos; i < right; ++i)
+			if (ref[i] == 0) break;
+		right = i;
+	}
+	{ // the core part
+		char *ref2, *rs, *inscns = 0;
+		int k, l, *score, *pscore, max_ins = types[n_types-1];
+		if (max_ins > 0) { // get the consensus of inserted sequences
+			int *inscns_aux = (int*)calloc(4 * n_types * max_ins, sizeof(int));
+			// count occurrences
+			for (i = 0; i < n_types; ++i) {
+				if (types[i] <= 0) continue; // not insertion
+				for (j = 0; j < n; ++j) {
+					const bam_pileup1_t *p = pl + j;
+					if (!(p->b->core.flag&BAM_FUNMAP) && p->indel == types[i]) {
+						for (k = 1; k <= p->indel; ++k) {
+							int c = bam_nt16_nt4_table[bam1_seqi(bam1_seq(p->b), p->qpos + k)];
+							if (c < 4) ++inscns_aux[i*max_ins*4 + (k-1)*4 + c];
+						}
+					}
+				}
+			}
+			// construct the consensus of inserted sequence
+			inscns = (char*)calloc(n_types * max_ins, sizeof(char));
+			for (i = 0; i < n_types; ++i) {
+				for (j = 0; j < types[i]; ++j) {
+					int max = 0, max_k = -1, *ia = inscns_aux + i*max_ins*4 + j*4;
+					for (k = 0; k < 4; ++k) {
+						if (ia[k] > max) {
+							max = ia[k];
+							max_k = k;
+						}
+					}
+					inscns[i*max_ins + j] = max? 1<<max_k : 15;
+				}
+			}
+			free(inscns_aux);
+		}
+		// calculate score
+		ref2 = (char*)calloc(right - left + types[n_types-1] + 2, 1);
+		rs   = (char*)calloc(right - left + max_rd_len + types[n_types-1] + 2, 1);
+		score = (int*)calloc(n_types * n, sizeof(int));
+		pscore = (int*)calloc(n_types * n, sizeof(int));
+		for (i = 0; i < n_types; ++i) {
+			ka_param_t ap = ka_param_blast;
+			ap.band_width = 2 * types[n_types - 1] + 2;
+			// write ref2
+			for (k = 0, j = left; j <= pos; ++j)
+				ref2[k++] = bam_nt16_nt4_table[bam_nt16_table[(int)ref[j]]];
+			if (types[i] <= 0) j += -types[i];
+			else for (l = 0; l < types[i]; ++l)
+					 ref2[k++] = bam_nt16_nt4_table[(int)inscns[i*max_ins + l]];
+			for (; j < right && ref[j]; ++j)
+				ref2[k++] = bam_nt16_nt4_table[bam_nt16_table[(int)ref[j]]];
+			if (j < right) right = j;
+			// calculate score for each read
+			for (j = 0; j < n; ++j) {
+				const bam_pileup1_t *p = pl + j;
+				int qbeg, qend, tbeg, tend;
+				if (p->b->core.flag & BAM_FUNMAP) continue;
+				qbeg = bam_tpos2qpos(&p->b->core, bam1_cigar(p->b), left,  0, &tbeg);
+				qend = bam_tpos2qpos(&p->b->core, bam1_cigar(p->b), right, 1, &tend);
+				assert(tbeg >= left);
+				for (l = qbeg; l < qend; ++l)
+					rs[l - qbeg] = bam_nt16_nt4_table[bam1_seqi(bam1_seq(p->b), l)];
+				{
+					int x, y, n_acigar, ps;
+					uint32_t *acigar;
+					ps = 0;
+					if (tend - tbeg + types[i] <= 0) {
+						score[i*n+j] = -(1<<20);
+						pscore[i*n+j] = 1<<20;
+						continue;
+					}
+					acigar = ka_global_core((uint8_t*)ref2 + tbeg - left, tend - tbeg + types[i], (uint8_t*)rs, qend - qbeg, &ap, &score[i*n+j], &n_acigar);
+					x = tbeg - left; y = 0;
+					for (l = 0; l < n_acigar; ++l) {
+						int op = acigar[l]&0xf;
+						int len = acigar[l]>>4;
+						if (op == BAM_CMATCH) {
+							int k;
+							for (k = 0; k < len; ++k)
+								if (ref2[x+k] != rs[y+k]) ps += bam1_qual(p->b)[y+k];
+							x += len; y += len;
+						} else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) {
+							if (op == BAM_CINS) ps += mi->q_indel * len;
+							y += len;
+						} else if (op == BAM_CDEL) {
+							ps += mi->q_indel * len;
+							x += len;
+						}
+					}
+					pscore[i*n+j] = ps;
+					/*if (pos == 2618517) { // for debugging only
+						fprintf(stderr, "pos=%d, type=%d, j=%d, score=%d, psore=%d, %d, %d, %d, %d, ", pos+1, types[i], j, score[i*n+j], pscore[i*n+j], tbeg, tend, qbeg, qend);
+						for (l = 0; l < n_acigar; ++l) fprintf(stderr, "%d%c", acigar[l]>>4, "MIDS"[acigar[l]&0xf]); fprintf(stderr, "\n");
+						for (l = 0; l < tend - tbeg + types[i]; ++l) fputc("ACGTN"[ref2[l]], stderr); fputc('\n', stderr);
+						for (l = 0; l < qend - qbeg; ++l) fputc("ACGTN"[rs[l]], stderr); fputc('\n', stderr);
+						}*/
+					free(acigar);
+				}
+			}
+		}
+		{ // get final result
+			int *sum, max1, max2, max1_i, max2_i;
+			// pick up the best two score
+			sum = (int*)calloc(n_types, sizeof(int));
+			for (i = 0; i < n_types; ++i)
+				for (j = 0; j < n; ++j)
+					sum[i] += -pscore[i*n+j];
+			max1 = max2 = -0x7fffffff; max1_i = max2_i = -1;
+			for (i = 0; i < n_types; ++i) {
+				if (sum[i] > max1) {
+					max2 = max1; max2_i = max1_i; max1 = sum[i]; max1_i = i;
+				} else if (sum[i] > max2) {
+					max2 = sum[i]; max2_i = i;
+				}
+			}
+			free(sum);
+			// write ret
+			ret = (bam_maqindel_ret_t*)calloc(1, sizeof(bam_maqindel_ret_t));
+			ret->indel1 = types[max1_i]; ret->indel2 = types[max2_i];
+			ret->s[0] = (char*)calloc(abs(ret->indel1) + 2, 1);
+			ret->s[1] = (char*)calloc(abs(ret->indel2) + 2, 1);
+			// write indel sequence
+			if (ret->indel1 > 0) {
+				ret->s[0][0] = '+';
+				for (k = 0; k < ret->indel1; ++k)
+					ret->s[0][k+1] = bam_nt16_rev_table[(int)inscns[max1_i*max_ins + k]];
+			} else if (ret->indel1 < 0) {
+				ret->s[0][0] = '-';
+				for (k = 0; k < -ret->indel1 && ref[pos + k + 1]; ++k)
+					ret->s[0][k+1] = ref[pos + k + 1];
+			} else ret->s[0][0] = '*';
+			if (ret->indel2 > 0) {
+				ret->s[1][0] = '+';
+				for (k = 0; k < ret->indel2; ++k)
+					ret->s[1][k+1] = bam_nt16_rev_table[(int)inscns[max2_i*max_ins + k]];
+			} else if (ret->indel2 < 0) {
+				ret->s[1][0] = '-';
+				for (k = 0; k < -ret->indel2 && ref[pos + k + 1]; ++k)
+					ret->s[1][k+1] = ref[pos + k + 1];
+			} else ret->s[1][0] = '*';
+			// write count
+			for (i = 0; i < n; ++i) {
+				const bam_pileup1_t *p = pl + i;
+				if (p->indel == ret->indel1) ++ret->cnt1;
+				else if (p->indel == ret->indel2) ++ret->cnt2;
+				else ++ret->cnt_anti;
+			}
+			{ // write gl[]
+				int tmp, seq_err = 0;
+				double x = 1.0;
+				tmp = max1_i - max2_i;
+				if (tmp < 0) tmp = -tmp;
+				for (j = 0; j < tmp + 1; ++j) x *= INDEL_EXT_DEP;
+				seq_err = mi->q_indel * (1.0 - x) / (1.0 - INDEL_EXT_DEP);
+				ret->gl[0] = ret->gl[1] = 0;
+				for (j = 0; j < n; ++j) {
+					int s1 = pscore[max1_i*n + j], s2 = pscore[max2_i*n + j];
+					//printf("%d, %d, %d, %d, %d\n", pl[j].b->core.pos+1, max1_i, max2_i, s1, s2);
+					if (s1 > s2) ret->gl[0] += s1 - s2 < seq_err? s1 - s2 : seq_err;
+					else ret->gl[1] += s2 - s1 < seq_err? s2 - s1 : seq_err;
+				}
+			}
+			// write cnt_ref and cnt_ambi
+			if (max1_i != 0 && max2_i != 0) {
+				for (j = 0; j < n; ++j) {
+					int diff1 = score[j] - score[max1_i * n + j];
+					int diff2 = score[j] - score[max2_i * n + j];
+					if (diff1 > 0 && diff2 > 0) ++ret->cnt_ref;
+					else if (diff1 == 0 || diff2 == 0) ++ret->cnt_ambi;
+				}
+			}
+		}
+		free(score); free(pscore); free(ref2); free(rs); free(inscns);
+	}
+	{ // call genotype
+		int q[3], qr_indel = (int)(-4.343 * log(mi->r_indel) + 0.5);
+		int min1, min2, min1_i;
+		q[0] = ret->gl[0] + (ret->s[0][0] != '*'? 0 : 0) * qr_indel;
+		q[1] = ret->gl[1] + (ret->s[1][0] != '*'? 0 : 0) * qr_indel;
+		q[2] = n * 3 + (ret->s[0][0] == '*' || ret->s[1][0] == '*'? 1 : 1) * qr_indel;
+		min1 = min2 = 0x7fffffff; min1_i = -1;
+		for (i = 0; i < 3; ++i) {
+			if (q[i] < min1) {
+				min2 = min1; min1 = q[i]; min1_i = i;
+			} else if (q[i] < min2) min2 = q[i];
+		}
+		ret->gt = min1_i;
+		ret->q_cns = min2 - min1;
+		// set q_ref
+		if (ret->gt < 2) ret->q_ref = (ret->s[ret->gt][0] == '*')? 0 : q[1-ret->gt] - q[ret->gt] - qr_indel - 3;
+		else ret->q_ref = (ret->s[0][0] == '*')? q[0] - q[2] : q[1] - q[2];
+		if (ret->q_ref < 0) ret->q_ref = 0;
+	}
+	free(types);
+	return ret;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_maqcns.h b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_maqcns.h
new file mode 100644
index 0000000..fa5489d
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_maqcns.h
@@ -0,0 +1,56 @@
+#ifndef BAM_MAQCNS_H
+#define BAM_MAQCNS_H
+
+#include "glf.h"
+
+struct __bmc_aux_t;
+
+typedef struct {
+	float het_rate, theta;
+	int n_hap, cap_mapQ, is_soap;
+
+	float eta, q_r;
+	double *fk, *coef;
+	double *lhet;
+	struct __bmc_aux_t *aux;
+} bam_maqcns_t;
+
+typedef struct {
+	int q_indel;
+	float r_indel;
+	// hidden parameters, unchangeable from command line
+	int mm_penalty, indel_err, ambi_thres;
+} bam_maqindel_opt_t;
+
+typedef struct {
+	int indel1, indel2;
+	int cnt1, cnt2, cnt_anti;
+	int cnt_ref, cnt_ambi;
+	char *s[2];
+	//
+	int gt, gl[2];
+	int q_cns, q_ref;
+} bam_maqindel_ret_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	bam_maqcns_t *bam_maqcns_init();
+	void bam_maqcns_prepare(bam_maqcns_t *bm);
+	void bam_maqcns_destroy(bam_maqcns_t *bm);
+	glf1_t *bam_maqcns_glfgen(int n, const bam_pileup1_t *pl, uint8_t ref_base, bam_maqcns_t *bm);
+	uint32_t bam_maqcns_call(int n, const bam_pileup1_t *pl, bam_maqcns_t *bm);
+	// return: cns<<28 | cns2<<24 | mapQ<<16 | cnsQ<<8 | cnsQ2
+	uint32_t glf2cns(const glf1_t *g, int q_r);
+
+	bam_maqindel_opt_t *bam_maqindel_opt_init();
+	bam_maqindel_ret_t *bam_maqindel(int n, int pos, const bam_maqindel_opt_t *mi, const bam_pileup1_t *pl, const char *ref,
+									 int _n_types, int *_types);
+	void bam_maqindel_ret_destroy(bam_maqindel_ret_t*);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_mate.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_mate.c
new file mode 100644
index 0000000..61f808a
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_mate.c
@@ -0,0 +1,70 @@
+#include <stdlib.h>
+#include <string.h>
+#include "bam.h"
+
+// currently, this function ONLY works if each read has one hit
+void bam_mating_core(bamFile in, bamFile out)
+{
+	bam_header_t *header;
+	bam1_t *b[2];
+	int curr, has_prev;
+
+	header = bam_header_read(in);
+	bam_header_write(out, header);
+
+	b[0] = bam_init1();
+	b[1] = bam_init1();
+	curr = 0; has_prev = 0;
+	while (bam_read1(in, b[curr]) >= 0) {
+		bam1_t *cur = b[curr], *pre = b[1-curr];
+		if (has_prev) {
+			if (strcmp(bam1_qname(cur), bam1_qname(pre)) == 0) { // identical pair name
+				cur->core.mtid = pre->core.tid; cur->core.mpos = pre->core.pos;
+				pre->core.mtid = cur->core.tid; pre->core.mpos = cur->core.pos;
+				if (pre->core.tid == cur->core.tid && !(cur->core.flag&(BAM_FUNMAP|BAM_FMUNMAP))
+					&& !(pre->core.flag&(BAM_FUNMAP|BAM_FMUNMAP)))
+				{
+					uint32_t cur5, pre5;
+					cur5 = (cur->core.flag&BAM_FREVERSE)? bam_calend(&cur->core, bam1_cigar(cur)) : cur->core.pos;
+					pre5 = (pre->core.flag&BAM_FREVERSE)? bam_calend(&pre->core, bam1_cigar(pre)) : pre->core.pos;
+					cur->core.isize = pre5 - cur5; pre->core.isize = cur5 - pre5;
+				} else cur->core.isize = pre->core.isize = 0;
+				if (pre->core.flag&BAM_FREVERSE) cur->core.flag |= BAM_FMREVERSE;
+				else cur->core.flag &= ~BAM_FMREVERSE;
+				if (cur->core.flag&BAM_FREVERSE) pre->core.flag |= BAM_FMREVERSE;
+				else pre->core.flag &= ~BAM_FMREVERSE;
+				if (cur->core.flag & BAM_FUNMAP) { pre->core.flag |= BAM_FMUNMAP; pre->core.flag &= ~BAM_FPROPER_PAIR; }
+				if (pre->core.flag & BAM_FUNMAP) { cur->core.flag |= BAM_FMUNMAP; cur->core.flag &= ~BAM_FPROPER_PAIR; }
+				bam_write1(out, pre);
+				bam_write1(out, cur);
+				has_prev = 0;
+			} else { // unpaired or singleton
+				pre->core.mtid = -1; pre->core.mpos = -1; pre->core.isize = 0;
+				if (pre->core.flag & BAM_FPAIRED) {
+					pre->core.flag |= BAM_FMUNMAP;
+					pre->core.flag &= ~BAM_FMREVERSE & ~BAM_FPROPER_PAIR;
+				}
+				bam_write1(out, pre);
+			}
+		} else has_prev = 1;
+		curr = 1 - curr;
+	}
+	if (has_prev) bam_write1(out, b[1-curr]);
+	bam_header_destroy(header);
+	bam_destroy1(b[0]);
+	bam_destroy1(b[1]);
+}
+
+int bam_mating(int argc, char *argv[])
+{
+	bamFile in, out;
+	if (argc < 3) {
+		fprintf(stderr, "samtools fixmate <in.nameSrt.bam> <out.nameSrt.bam>\n");
+		return 1;
+	}
+	in = (strcmp(argv[1], "-") == 0)? bam_dopen(fileno(stdin), "r") : bam_open(argv[1], "r");
+    out = (strcmp(argv[2], "-") == 0)? bam_dopen(fileno(stdout), "w") : bam_open(argv[2], "w");
+	bam_mating_core(in, out);
+	bam_close(in); bam_close(out);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_md.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_md.c
new file mode 100644
index 0000000..3ca7309
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_md.c
@@ -0,0 +1,149 @@
+#include <unistd.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include "faidx.h"
+#include "sam.h"
+#include "kstring.h"
+
+void bam_fillmd1(bam1_t *b, char *ref, int is_equal)
+{
+	uint8_t *seq = bam1_seq(b);
+	uint32_t *cigar = bam1_cigar(b);
+	bam1_core_t *c = &b->core;
+	int i, x, y, u = 0;
+	kstring_t *str;
+	uint8_t *old_md, *old_nm;
+	int32_t old_nm_i = -1, nm = 0;
+
+	str = (kstring_t*)calloc(1, sizeof(kstring_t));
+	for (i = y = 0, x = c->pos; i < c->n_cigar; ++i) {
+		int j, l = cigar[i]>>4, op = cigar[i]&0xf;
+		if (op == BAM_CMATCH) {
+			for (j = 0; j < l; ++j) {
+				int z = y + j;
+				int c1 = bam1_seqi(seq, z), c2 = bam_nt16_table[(int)ref[x+j]];
+				if (ref[x+j] == 0) break; // out of boundary
+				if ((c1 == c2 && c1 != 15 && c2 != 15) || c1 == 0) { // a match
+					if (is_equal) seq[z/2] &= (z&1)? 0xf0 : 0x0f;
+					++u;
+				} else {
+					ksprintf(str, "%d", u);
+					kputc(ref[x+j], str);
+					u = 0; ++nm;
+				}
+			}
+			if (j < l) break;
+			x += l; y += l;
+		} else if (op == BAM_CDEL) {
+			ksprintf(str, "%d", u);
+			kputc('^', str);
+			for (j = 0; j < l; ++j) {
+				if (ref[x+j] == 0) break;
+				kputc(ref[x+j], str);
+			}
+			u = 0;
+			if (j < l) break;
+			x += l; nm += l;
+		} else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) {
+			y += l;
+			if (op == BAM_CINS) nm += l;
+		} else if (op == BAM_CREF_SKIP) {
+			x += l;
+		}
+	}
+	ksprintf(str, "%d", u);
+	// update NM
+	old_nm = bam_aux_get(b, "NM");
+	if (c->flag & BAM_FUNMAP) return;
+	if (old_nm) old_nm_i = bam_aux2i(old_nm);
+	if (!old_nm) bam_aux_append(b, "NM", 'i', 4, (uint8_t*)&nm);
+	else if (nm != old_nm_i) {
+		fprintf(stderr, "[bam_fillmd1] different NM for read '%s': %d -> %d\n", bam1_qname(b), old_nm_i, nm);
+		bam_aux_del(b, old_nm);
+		bam_aux_append(b, "NM", 'i', 4, (uint8_t*)&nm);
+	}
+	// update MD
+	old_md = bam_aux_get(b, "MD");
+	if (!old_md) bam_aux_append(b, "MD", 'Z', str->l + 1, (uint8_t*)str->s);
+	else {
+		int is_diff = 0;
+		if (strlen((char*)old_md+1) == str->l) {
+			for (i = 0; i < str->l; ++i)
+				if (toupper(old_md[i+1]) != toupper(str->s[i]))
+					break;
+			if (i < str->l) is_diff = 1;
+		} else is_diff = 1;
+		if (is_diff) {
+			fprintf(stderr, "[bam_fillmd1] different MD for read '%s': '%s' -> '%s'\n", bam1_qname(b), old_md+1, str->s);
+			bam_aux_del(b, old_md);
+			bam_aux_append(b, "MD", 'Z', str->l + 1, (uint8_t*)str->s);
+		}
+	}
+	free(str->s); free(str);
+}
+
+int bam_fillmd(int argc, char *argv[])
+{
+	int c, is_equal = 0, tid = -2, ret, len, is_bam_out, is_sam_in, is_uncompressed;
+	samfile_t *fp, *fpout = 0;
+	faidx_t *fai;
+	char *ref = 0, mode_w[8], mode_r[8];
+	bam1_t *b;
+
+	is_bam_out = is_sam_in = is_uncompressed = 0;
+	mode_w[0] = mode_r[0] = 0;
+	strcpy(mode_r, "r"); strcpy(mode_w, "w");
+	while ((c = getopt(argc, argv, "eubS")) >= 0) {
+		switch (c) {
+		case 'e': is_equal = 1; break;
+		case 'b': is_bam_out = 1; break;
+		case 'u': is_uncompressed = is_bam_out = 1; break;
+		case 'S': is_sam_in = 1; break;
+		default: fprintf(stderr, "[bam_fillmd] unrecognized option '-%c'\n", c); return 1;
+		}
+	}
+	if (!is_sam_in) strcat(mode_r, "b");
+	if (is_bam_out) strcat(mode_w, "b");
+	else strcat(mode_w, "h");
+	if (is_uncompressed) strcat(mode_w, "u");
+	if (optind + 1 >= argc) {
+		fprintf(stderr, "\n");
+		fprintf(stderr, "Usage:   samtools fillmd [-eubS] <aln.bam> <ref.fasta>\n\n");
+		fprintf(stderr, "Options: -e       change identical bases to '='\n");
+		fprintf(stderr, "         -u       uncompressed BAM output (for piping)\n");
+		fprintf(stderr, "         -b       compressed BAM output\n");
+		fprintf(stderr, "         -S       the input is SAM with header\n\n");
+		return 1;
+	}
+	fp = samopen(argv[optind], mode_r, 0);
+	if (fp == 0) return 1;
+	if (is_sam_in && (fp->header == 0 || fp->header->n_targets == 0)) {
+		fprintf(stderr, "[bam_fillmd] input SAM does not have header. Abort!\n");
+		return 1;
+	}
+	fpout = samopen("-", mode_w, fp->header);
+	fai = fai_load(argv[optind+1]);
+
+	b = bam_init1();
+	while ((ret = samread(fp, b)) >= 0) {
+		if (b->core.tid >= 0) {
+			if (tid != b->core.tid) {
+				free(ref);
+				ref = fai_fetch(fai, fp->header->target_name[b->core.tid], &len);
+				tid = b->core.tid;
+				if (ref == 0)
+					fprintf(stderr, "[bam_fillmd] fail to find sequence '%s' in the reference.\n",
+							fp->header->target_name[tid]);
+			}
+			if (ref) bam_fillmd1(b, ref, is_equal);
+		}
+		samwrite(fpout, b);
+	}
+	bam_destroy1(b);
+
+	free(ref);
+	fai_destroy(fai);
+	samclose(fp); samclose(fpout);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_pileup.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_pileup.c
new file mode 100644
index 0000000..f68f400
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_pileup.c
@@ -0,0 +1,238 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <assert.h>
+#include "sam.h"
+
+typedef struct __linkbuf_t {
+	bam1_t b;
+	uint32_t beg, end;
+	struct __linkbuf_t *next;
+} lbnode_t;
+
+/* --- BEGIN: Memory pool */
+
+typedef struct {
+	int cnt, n, max;
+	lbnode_t **buf;
+} mempool_t;
+
+static mempool_t *mp_init()
+{
+	mempool_t *mp;
+	mp = (mempool_t*)calloc(1, sizeof(mempool_t));
+	return mp;
+}
+static void mp_destroy(mempool_t *mp)
+{
+	int k;
+	for (k = 0; k < mp->n; ++k) {
+		free(mp->buf[k]->b.data);
+		free(mp->buf[k]);
+	}
+	free(mp->buf);
+	free(mp);
+}
+static inline lbnode_t *mp_alloc(mempool_t *mp)
+{
+	++mp->cnt;
+	if (mp->n == 0) return (lbnode_t*)calloc(1, sizeof(lbnode_t));
+	else return mp->buf[--mp->n];
+}
+static inline void mp_free(mempool_t *mp, lbnode_t *p)
+{
+	--mp->cnt; p->next = 0; // clear lbnode_t::next here
+	if (mp->n == mp->max) {
+		mp->max = mp->max? mp->max<<1 : 256;
+		mp->buf = (lbnode_t**)realloc(mp->buf, sizeof(lbnode_t*) * mp->max);
+	}
+	mp->buf[mp->n++] = p;
+}
+
+/* --- END: Memory pool */
+
+/* --- BEGIN: Auxiliary functions */
+
+static inline int resolve_cigar(bam_pileup1_t *p, uint32_t pos)
+{
+	unsigned k;
+	bam1_t *b = p->b;
+	bam1_core_t *c = &b->core;
+	uint32_t x = c->pos, y = 0;
+	int ret = 1, is_restart = 1;
+
+	if (c->flag&BAM_FUNMAP) return 0; // unmapped read
+	assert(x <= pos); // otherwise a bug
+	p->qpos = -1; p->indel = 0; p->is_del = p->is_head = p->is_tail = 0;
+	for (k = 0; k < c->n_cigar; ++k) {
+		int op = bam1_cigar(b)[k] & BAM_CIGAR_MASK; // operation
+		int l = bam1_cigar(b)[k] >> BAM_CIGAR_SHIFT; // length
+		if (op == BAM_CMATCH) { // NOTE: this assumes the first and the last operation MUST BE a match or a clip
+			if (x + l > pos) { // overlap with pos
+				p->indel = p->is_del = 0;
+				p->qpos = y + (pos - x);
+				if (x == pos && is_restart) p->is_head = 1;
+				if (x + l - 1 == pos) { // come to the end of a match
+					if (k < c->n_cigar - 1) { // there are additional operation(s)
+						uint32_t cigar = bam1_cigar(b)[k+1]; // next CIGAR
+						int op_next = cigar&BAM_CIGAR_MASK; // next CIGAR operation
+						if (op_next == BAM_CDEL) p->indel = -(int32_t)(cigar>>BAM_CIGAR_SHIFT); // del
+						else if (op_next == BAM_CINS) p->indel = cigar>>BAM_CIGAR_SHIFT; // ins
+						if (op_next == BAM_CDEL || op_next == BAM_CINS) {
+							if (k + 2 < c->n_cigar) op_next = bam1_cigar(b)[k+2]&BAM_CIGAR_MASK;
+							else p->is_tail = 1;
+						}
+						if (op_next == BAM_CSOFT_CLIP || op_next == BAM_CREF_SKIP || op_next == BAM_CHARD_CLIP)
+							p->is_tail = 1; // tail
+					} else p->is_tail = 1; // this is the last operation; set tail
+				}
+			}
+			x += l; y += l;
+		} else if (op == BAM_CDEL) { // then set ->is_del
+			if (x + l > pos) {
+				p->indel = 0; p->is_del = 1;
+				p->qpos = y + (pos - x);
+			}
+			x += l;
+		} else if (op == BAM_CREF_SKIP) x += l;
+		else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) y += l;
+		is_restart = (op == BAM_CREF_SKIP || op == BAM_CSOFT_CLIP || op == BAM_CHARD_CLIP);
+		if (x > pos) {
+			if (op == BAM_CREF_SKIP) ret = 0; // then do not put it into pileup at all
+			break;
+		}
+	}
+	assert(x > pos); // otherwise a bug
+	return ret;
+}
+
+/* --- END: Auxiliary functions */
+
+struct __bam_plbuf_t {
+	mempool_t *mp;
+	lbnode_t *head, *tail, *dummy;
+	bam_pileup_f func;
+	void *func_data;
+	int32_t tid, pos, max_tid, max_pos;
+	int max_pu, is_eof;
+	bam_pileup1_t *pu;
+	int flag_mask;
+};
+
+void bam_plbuf_reset(bam_plbuf_t *buf)
+{
+	lbnode_t *p, *q;
+	buf->max_tid = buf->max_pos = -1;
+	buf->tid = buf->pos = 0;
+	buf->is_eof = 0;
+	for (p = buf->head; p->next;) {
+		q = p->next;
+		mp_free(buf->mp, p);
+		p = q;
+	}
+	buf->head = buf->tail;
+}
+
+void bam_plbuf_set_mask(bam_plbuf_t *buf, int mask)
+{
+	if (mask < 0) buf->flag_mask = BAM_DEF_MASK;
+	else buf->flag_mask = BAM_FUNMAP | mask;
+}
+
+bam_plbuf_t *bam_plbuf_init(bam_pileup_f func, void *data)
+{
+	bam_plbuf_t *buf;
+	buf = (bam_plbuf_t*)calloc(1, sizeof(bam_plbuf_t));
+	buf->func = func; buf->func_data = data;
+	buf->mp = mp_init();
+	buf->head = buf->tail = mp_alloc(buf->mp);
+	buf->dummy = mp_alloc(buf->mp);
+	buf->max_tid = buf->max_pos = -1;
+	buf->flag_mask = BAM_DEF_MASK;
+	return buf;
+}
+
+void bam_plbuf_destroy(bam_plbuf_t *buf)
+{
+	mp_free(buf->mp, buf->dummy);
+	mp_free(buf->mp, buf->head);
+	if (buf->mp->cnt != 0)
+		fprintf(stderr, "[bam_plbuf_destroy] memory leak: %d. Continue anyway.\n", buf->mp->cnt);
+	mp_destroy(buf->mp);
+	free(buf->pu);
+	free(buf);
+}
+
+int bam_plbuf_push(const bam1_t *b, bam_plbuf_t *buf)
+{
+	if (b) { // fill buffer
+		if (b->core.tid < 0) return 0;
+		if (b->core.flag & buf->flag_mask) return 0;
+		bam_copy1(&buf->tail->b, b);
+		buf->tail->beg = b->core.pos; buf->tail->end = bam_calend(&b->core, bam1_cigar(b));
+		if (b->core.tid < buf->max_tid) {
+			fprintf(stderr, "[bam_pileup_core] the input is not sorted (chromosomes out of order)\n");
+			return -1;
+		}
+		if ((b->core.tid == buf->max_tid) && (buf->tail->beg < buf->max_pos)) {
+			fprintf(stderr, "[bam_pileup_core] the input is not sorted (reads out of order)\n");
+			return -1;
+		}
+		buf->max_tid = b->core.tid; buf->max_pos = buf->tail->beg;
+		if (buf->tail->end > buf->pos || buf->tail->b.core.tid > buf->tid) {
+			buf->tail->next = mp_alloc(buf->mp);
+			buf->tail = buf->tail->next;
+		}
+	} else buf->is_eof = 1;
+	while (buf->is_eof || buf->max_tid > buf->tid || (buf->max_tid == buf->tid && buf->max_pos > buf->pos)) {
+		int n_pu = 0;
+		lbnode_t *p, *q;
+		buf->dummy->next = buf->head;
+		for (p = buf->head, q = buf->dummy; p->next; q = p, p = p->next) {
+			if (p->b.core.tid < buf->tid || (p->b.core.tid == buf->tid && p->end <= buf->pos)) { // then remove from the list
+				q->next = p->next; mp_free(buf->mp, p); p = q;
+			} else if (p->b.core.tid == buf->tid && p->beg <= buf->pos) { // here: p->end > pos; then add to pileup
+				if (n_pu == buf->max_pu) { // then double the capacity
+					buf->max_pu = buf->max_pu? buf->max_pu<<1 : 256;
+					buf->pu = (bam_pileup1_t*)realloc(buf->pu, sizeof(bam_pileup1_t) * buf->max_pu);
+				}
+				buf->pu[n_pu].b = &p->b;
+				if (resolve_cigar(buf->pu + n_pu, buf->pos)) ++n_pu; // skip the read if we are looking at BAM_CREF_SKIP
+			}
+		}
+		buf->head = buf->dummy->next; // dummy->next may be changed
+		if (n_pu) { // then call user defined function
+			buf->func(buf->tid, buf->pos, n_pu, buf->pu, buf->func_data);
+		}
+		// update tid and pos
+		if (buf->head->next) {
+			if (buf->tid > buf->head->b.core.tid) {
+				fprintf(stderr, "[bam_plbuf_push] unsorted input. Pileup aborts.\n");
+				return 1;
+			}
+		}
+		if (buf->tid < buf->head->b.core.tid) { // come to a new reference sequence
+			buf->tid = buf->head->b.core.tid; buf->pos = buf->head->beg; // jump to the next reference
+		} else if (buf->pos < buf->head->beg) { // here: tid == head->b.core.tid
+			buf->pos = buf->head->beg; // jump to the next position
+		} else ++buf->pos; // scan contiguously
+		if (buf->is_eof && buf->head->next == 0) break;
+	}
+	return 0;
+}
+
+int bam_pileup_file(bamFile fp, int mask, bam_pileup_f func, void *func_data)
+{
+	bam_plbuf_t *buf;
+	int ret;
+	bam1_t *b;
+	b = bam_init1();
+	buf = bam_plbuf_init(func, func_data);
+	bam_plbuf_set_mask(buf, mask);
+	while ((ret = bam_read1(fp, b)) >= 0)
+		bam_plbuf_push(b, buf);
+	bam_plbuf_push(0, buf);
+	bam_plbuf_destroy(buf);
+	bam_destroy1(b);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_plcmd.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_plcmd.c
new file mode 100644
index 0000000..ba787a9
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_plcmd.c
@@ -0,0 +1,392 @@
+#include <math.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <ctype.h>
+#include "sam.h"
+#include "faidx.h"
+#include "bam_maqcns.h"
+#include "khash.h"
+#include "glf.h"
+#include "kstring.h"
+
+typedef int *indel_list_t;
+KHASH_MAP_INIT_INT64(64, indel_list_t)
+
+#define BAM_PLF_SIMPLE     0x01
+#define BAM_PLF_CNS        0x02
+#define BAM_PLF_INDEL_ONLY 0x04
+#define BAM_PLF_GLF        0x08
+#define BAM_PLF_VAR_ONLY   0x10
+#define BAM_PLF_2ND        0x20
+
+typedef struct {
+	bam_header_t *h;
+	bam_maqcns_t *c;
+	bam_maqindel_opt_t *ido;
+	faidx_t *fai;
+	khash_t(64) *hash;
+	uint32_t format;
+	int tid, len, last_pos;
+	int mask;
+	char *ref;
+	glfFile fp_glf; // for glf output only
+} pu_data_t;
+
+char **__bam_get_lines(const char *fn, int *_n);
+void bam_init_header_hash(bam_header_t *header);
+int32_t bam_get_tid(const bam_header_t *header, const char *seq_name);
+
+static khash_t(64) *load_pos(const char *fn, bam_header_t *h)
+{
+	char **list;
+	int i, j, n, *fields, max_fields;
+	khash_t(64) *hash;
+	bam_init_header_hash(h);
+	list = __bam_get_lines(fn, &n);
+	hash = kh_init(64);
+	max_fields = 0; fields = 0;
+	for (i = 0; i < n; ++i) {
+		char *str = list[i];
+		int chr, n_fields, ret;
+		khint_t k;
+		uint64_t x;
+		n_fields = ksplit_core(str, 0, &max_fields, &fields);
+		if (n_fields < 2) continue;
+		chr = bam_get_tid(h, str + fields[0]);
+		if (chr < 0) {
+			fprintf(stderr, "[load_pos] unknown reference sequence name: %s\n", str + fields[0]);
+			continue;
+		}
+		x = (uint64_t)chr << 32 | (atoi(str + fields[1]) - 1);
+		k = kh_put(64, hash, x, &ret);
+		if (ret == 0) {
+			fprintf(stderr, "[load_pos] position %s:%s has been loaded.\n", str+fields[0], str+fields[1]);
+			continue;
+		}
+		kh_val(hash, k) = 0;
+		if (n_fields > 2) {
+			// count
+			for (j = 2; j < n_fields; ++j) {
+				char *s = str + fields[j];
+				if ((*s != '+' && *s != '-') || !isdigit(s[1])) break;
+ 			}
+			if (j > 2) { // update kh_val()
+				int *q, y, z;
+				q = kh_val(hash, k) = (int*)calloc(j - 1, sizeof(int));
+				q[0] = j - 2; z = j; y = 1;
+				for (j = 2; j < z; ++j)
+					q[y++] = atoi(str + fields[j]);
+			}
+		}
+		free(str);
+	}
+	free(list); free(fields);
+	return hash;
+}
+
+// an analogy to pileup_func() below
+static int glt3_func(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pu, void *data)
+{
+	pu_data_t *d = (pu_data_t*)data;
+	bam_maqindel_ret_t *r = 0;
+	int rb, *proposed_indels = 0;
+	glf1_t *g;
+	glf3_t *g3;
+
+	if (d->fai == 0) {
+		fprintf(stderr, "[glt3_func] reference sequence is required for generating GLT. Abort!\n");
+		exit(1);
+	}
+	if (d->hash) { // only output a list of sites
+		khint_t k = kh_get(64, d->hash, (uint64_t)tid<<32|pos);
+		if (k == kh_end(d->hash)) return 0;
+		proposed_indels = kh_val(d->hash, k);
+	}
+	g3 = glf3_init1();
+	if (d->fai && (int)tid != d->tid) {
+		if (d->ref) { // then write the end mark
+			g3->rtype = GLF3_RTYPE_END;
+			glf3_write1(d->fp_glf, g3);
+		}
+		glf3_ref_write(d->fp_glf, d->h->target_name[tid], d->h->target_len[tid]); // write reference
+		free(d->ref);
+		d->ref = fai_fetch(d->fai, d->h->target_name[tid], &d->len);
+		d->tid = tid;
+		d->last_pos = 0;
+	}
+	rb = (d->ref && (int)pos < d->len)? d->ref[pos] : 'N';
+	g = bam_maqcns_glfgen(n, pu, bam_nt16_table[rb], d->c);
+	memcpy(g3, g, sizeof(glf1_t));
+	g3->rtype = GLF3_RTYPE_SUB;
+	g3->offset = pos - d->last_pos;
+	d->last_pos = pos;
+	glf3_write1(d->fp_glf, g3);
+	if (pos < d->len) {
+		if (proposed_indels)
+			r = bam_maqindel(n, pos, d->ido, pu, d->ref, proposed_indels[0], proposed_indels+1);
+		else r = bam_maqindel(n, pos, d->ido, pu, d->ref, 0, 0);
+	}
+	if (r) { // then write indel line
+		int het = 3 * n, min;
+		min = het;
+		if (min > r->gl[0]) min = r->gl[0];
+		if (min > r->gl[1]) min = r->gl[1];
+		g3->ref_base = 0;
+		g3->rtype = GLF3_RTYPE_INDEL;
+		memset(g3->lk, 0, 10);
+		g3->lk[0] = r->gl[0] - min < 255? r->gl[0] - min : 255;
+		g3->lk[1] = r->gl[1] - min < 255? r->gl[1] - min : 255;
+		g3->lk[2] = het - min < 255? het - min : 255;
+		g3->offset = 0;
+		g3->indel_len[0] = r->indel1;
+		g3->indel_len[1] = r->indel2;
+		g3->min_lk = min < 255? min : 255;
+		g3->max_len = (abs(r->indel1) > abs(r->indel2)? abs(r->indel1) : abs(r->indel2)) + 1;
+		g3->indel_seq[0] = strdup(r->s[0]+1);
+		g3->indel_seq[1] = strdup(r->s[1]+1);
+		glf3_write1(d->fp_glf, g3);
+		bam_maqindel_ret_destroy(r);
+	}
+	free(g);
+	glf3_destroy1(g3);
+	return 0;
+}
+
+static int pileup_func(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pu, void *data)
+{
+	pu_data_t *d = (pu_data_t*)data;
+	bam_maqindel_ret_t *r = 0;
+	int i, j, rb, rms_mapq = -1, *proposed_indels = 0;
+	uint64_t rms_aux;
+	uint32_t cns = 0;
+
+	// if GLF is required, suppress -c completely
+	if (d->format & BAM_PLF_GLF) return glt3_func(tid, pos, n, pu, data);
+	// if d->hash is initialized, only output the sites in the hash table
+	if (d->hash) {
+		khint_t k = kh_get(64, d->hash, (uint64_t)tid<<32|pos);
+		if (k == kh_end(d->hash)) return 0;
+		proposed_indels = kh_val(d->hash, k);
+	}
+	// update d->ref if necessary
+	if (d->fai && (int)tid != d->tid) {
+		free(d->ref);
+		d->ref = fai_fetch(d->fai, d->h->target_name[tid], &d->len);
+		d->tid = tid;
+	}
+	rb = (d->ref && (int)pos < d->len)? d->ref[pos] : 'N';
+	// when the indel-only mode is asked for, return if no reads mapped with indels
+	if (d->format & BAM_PLF_INDEL_ONLY) {
+		for (i = 0; i < n; ++i)
+			if (pu[i].indel != 0) break;
+		if (i == n) return 0;
+	}
+	// call the consensus and indel
+	if (d->format & BAM_PLF_CNS) // call consensus
+		cns = bam_maqcns_call(n, pu, d->c);
+	if ((d->format & (BAM_PLF_CNS|BAM_PLF_INDEL_ONLY)) && d->ref && pos < d->len) { // call indels
+		if (proposed_indels) // the first element gives the size of the array
+			r = bam_maqindel(n, pos, d->ido, pu, d->ref, proposed_indels[0], proposed_indels+1);
+		else r = bam_maqindel(n, pos, d->ido, pu, d->ref, 0, 0);
+	}
+	// when only variant sites are asked for, test if the site is a variant
+	if ((d->format & BAM_PLF_CNS) && (d->format & BAM_PLF_VAR_ONLY)) {
+		if (!(bam_nt16_table[rb] != 15 && cns>>28 != bam_nt16_table[rb])) { // not a SNP
+			if (!(r && (r->gt == 2 || strcmp(r->s[r->gt], "*")))) { // not an indel
+				if (r) bam_maqindel_ret_destroy(r);
+				return 0;
+			}
+		}
+	}
+	// print the first 3 columns
+	printf("%s\t%d\t%c\t", d->h->target_name[tid], pos + 1, rb);
+	// print consensus information if required
+	if (d->format & BAM_PLF_CNS) {
+		int ref_q, rb4 = bam_nt16_table[rb];
+		ref_q = 0;
+		if (rb4 != 15 && cns>>28 != 15 && cns>>28 != rb4) { // a SNP
+			ref_q = ((cns>>24&0xf) == rb4)? cns>>8&0xff : (cns>>8&0xff) + (cns&0xff);
+			if (ref_q > 255) ref_q = 255;
+		}
+		rms_mapq = cns>>16&0xff;
+		printf("%c\t%d\t%d\t%d\t", bam_nt16_rev_table[cns>>28], cns>>8&0xff, ref_q, rms_mapq);
+	}
+	// print pileup sequences
+	printf("%d\t", n);
+	rms_aux = 0; // we need to recalculate rms_mapq when -c is not flagged on the command line
+	for (i = 0; i < n; ++i) {
+		const bam_pileup1_t *p = pu + i;
+		int tmp = p->b->core.qual < d->c->cap_mapQ? p->b->core.qual : d->c->cap_mapQ;
+		rms_aux += tmp * tmp;
+		if (p->is_head) printf("^%c", p->b->core.qual > 93? 126 : p->b->core.qual + 33);
+		if (!p->is_del) {
+			int c = bam_nt16_rev_table[bam1_seqi(bam1_seq(p->b), p->qpos)];
+			if (c == '=' || toupper(c) == toupper(rb)) c = bam1_strand(p->b)? ',' : '.';
+			else c = bam1_strand(p->b)? tolower(c) : toupper(c);
+			putchar(c);
+			if (p->indel > 0) {
+				printf("+%d", p->indel);
+				for (j = 1; j <= p->indel; ++j) {
+					c = bam_nt16_rev_table[bam1_seqi(bam1_seq(p->b), p->qpos + j)];
+					putchar(bam1_strand(p->b)? tolower(c) : toupper(c));
+				}
+			} else if (p->indel < 0) {
+				printf("%d", p->indel);
+				for (j = 1; j <= -p->indel; ++j) {
+					c = (d->ref && (int)pos+j < d->len)? d->ref[pos+j] : 'N';
+					putchar(bam1_strand(p->b)? tolower(c) : toupper(c));
+				}
+			}
+		} else putchar('*');
+		if (p->is_tail) putchar('$');
+	}
+	// finalize rms_mapq
+	rms_aux = (uint64_t)(sqrt((double)rms_aux / n) + .499);
+	if (rms_mapq < 0) rms_mapq = rms_aux;
+	putchar('\t');
+	// print quality
+	for (i = 0; i < n; ++i) {
+		const bam_pileup1_t *p = pu + i;
+		int c = bam1_qual(p->b)[p->qpos] + 33;
+		if (c > 126) c = 126;
+		putchar(c);
+	}
+	if (d->format & BAM_PLF_2ND) { // print 2nd calls and qualities
+		const unsigned char *q;
+		putchar('\t');
+		for (i = 0; i < n; ++i) {
+			const bam_pileup1_t *p = pu + i;
+			q = bam_aux_get(p->b, "E2");
+			putchar(q? q[p->qpos + 1] : 'N');
+		}
+		putchar('\t');
+		for (i = 0; i < n; ++i) {
+			const bam_pileup1_t *p = pu + i;
+			q = bam_aux_get(p->b, "U2");
+			putchar(q? q[p->qpos + 1] : '!');
+		}
+	}
+	// print mapping quality if -s is flagged on the command line
+	if (d->format & BAM_PLF_SIMPLE) {
+		putchar('\t');
+		for (i = 0; i < n; ++i) {
+			int c = pu[i].b->core.qual + 33;
+			if (c > 126) c = 126;
+			putchar(c);
+		}
+	}
+	putchar('\n');
+	// print the indel line if r has been calculated. This only happens if:
+	// a) -c or -i are flagged, AND b) the reference sequence is available
+	if (r) {
+		printf("%s\t%d\t*\t", d->h->target_name[tid], pos + 1);
+		if (r->gt < 2) printf("%s/%s\t", r->s[r->gt], r->s[r->gt]);
+		else printf("%s/%s\t", r->s[0], r->s[1]);
+		printf("%d\t%d\t", r->q_cns, r->q_ref);
+		printf("%d\t%d\t", rms_mapq, n);
+		printf("%s\t%s\t", r->s[0], r->s[1]);
+		//printf("%d\t%d\t", r->gl[0], r->gl[1]);
+		printf("%d\t%d\t%d\t", r->cnt1, r->cnt2, r->cnt_anti);
+		printf("%d\t%d\n", r->cnt_ref, r->cnt_ambi);
+		bam_maqindel_ret_destroy(r);
+	}
+	return 0;
+}
+
+int bam_pileup(int argc, char *argv[])
+{
+	int c, is_SAM = 0;
+	char *fn_list = 0, *fn_fa = 0, *fn_pos = 0;
+	pu_data_t *d = (pu_data_t*)calloc(1, sizeof(pu_data_t));
+	d->tid = -1; d->mask = BAM_DEF_MASK;
+	d->c = bam_maqcns_init();
+	d->ido = bam_maqindel_opt_init();
+	while ((c = getopt(argc, argv, "st:f:cT:N:r:l:im:gI:G:vM:S2a")) >= 0) {
+		switch (c) {
+		case 'a': d->c->is_soap = 1; break;
+		case 's': d->format |= BAM_PLF_SIMPLE; break;
+		case 't': fn_list = strdup(optarg); break;
+		case 'l': fn_pos = strdup(optarg); break;
+		case 'f': fn_fa = strdup(optarg); break;
+		case 'T': d->c->theta = atof(optarg); break;
+		case 'N': d->c->n_hap = atoi(optarg); break;
+		case 'r': d->c->het_rate = atof(optarg); break;
+		case 'M': d->c->cap_mapQ = atoi(optarg); break;
+		case 'c': d->format |= BAM_PLF_CNS; break;
+		case 'i': d->format |= BAM_PLF_INDEL_ONLY; break;
+		case 'v': d->format |= BAM_PLF_VAR_ONLY; break;
+		case 'm': d->mask = strtol(optarg, 0, 0); break;
+		case 'g': d->format |= BAM_PLF_GLF; break;
+		case '2': d->format |= BAM_PLF_2ND; break;
+		case 'I': d->ido->q_indel = atoi(optarg); break;
+		case 'G': d->ido->r_indel = atof(optarg); break;
+		case 'S': is_SAM = 1; break;
+		default: fprintf(stderr, "Unrecognizd option '-%c'.\n", c); return 1;
+		}
+	}
+	if (fn_list) is_SAM = 1;
+	if (optind == argc) {
+		fprintf(stderr, "\n");
+		fprintf(stderr, "Usage:  samtools pileup [options] <in.bam>|<in.sam>\n\n");
+		fprintf(stderr, "Option: -s        simple (yet incomplete) pileup format\n");
+		fprintf(stderr, "        -S        the input is in SAM\n");
+		fprintf(stderr, "        -a        use the SOAPsnp model for SNP calling\n");
+		fprintf(stderr, "        -2        output the 2nd best call and quality\n");
+		fprintf(stderr, "        -i        only show lines/consensus with indels\n");
+		fprintf(stderr, "        -m INT    filtering reads with bits in INT [%d]\n", d->mask);
+		fprintf(stderr, "        -M INT    cap mapping quality at INT [%d]\n", d->c->cap_mapQ);
+		fprintf(stderr, "        -t FILE   list of reference sequences (force -S)\n");
+		fprintf(stderr, "        -l FILE   list of sites at which pileup is output\n");
+		fprintf(stderr, "        -f FILE   reference sequence in the FASTA format\n\n");
+		fprintf(stderr, "        -c        output the maq consensus sequence\n");
+		fprintf(stderr, "        -v        print variants only (for -c)\n");
+		fprintf(stderr, "        -g        output in the GLFv3 format (suppressing -c/-i/-s)\n");
+		fprintf(stderr, "        -T FLOAT  theta in maq consensus calling model (for -c/-g) [%f]\n", d->c->theta);
+		fprintf(stderr, "        -N INT    number of haplotypes in the sample (for -c/-g) [%d]\n", d->c->n_hap);
+		fprintf(stderr, "        -r FLOAT  prior of a difference between two haplotypes (for -c/-g) [%f]\n", d->c->het_rate);
+		fprintf(stderr, "        -G FLOAT  prior of an indel between two haplotypes (for -c/-g) [%f]\n", d->ido->r_indel);
+		fprintf(stderr, "        -I INT    phred prob. of an indel in sequencing/prep. (for -c/-g) [%d]\n", d->ido->q_indel);
+		fprintf(stderr, "\n");
+		free(fn_list); free(fn_fa); free(d);
+		return 1;
+	}
+	if (fn_fa) d->fai = fai_load(fn_fa);
+	if (d->format & (BAM_PLF_CNS|BAM_PLF_GLF)) bam_maqcns_prepare(d->c); // consensus calling
+	if (d->format & BAM_PLF_GLF) { // for glf output
+		glf3_header_t *h;
+		h = glf3_header_init();
+		d->fp_glf = bgzf_fdopen(fileno(stdout), "w");
+		glf3_header_write(d->fp_glf, h);
+		glf3_header_destroy(h);
+	}
+	if (d->fai == 0 && (d->format & (BAM_PLF_CNS|BAM_PLF_INDEL_ONLY)))
+		fprintf(stderr, "[bam_pileup] indels will not be called when -f is absent.\n");
+	if (fn_fa && is_SAM && fn_list == 0) fn_list = samfaipath(fn_fa);
+
+	{
+		samfile_t *fp;
+		fp = is_SAM? samopen(argv[optind], "r", fn_list) : samopen(argv[optind], "rb", 0);
+		if (fp == 0 || fp->header == 0) {
+			fprintf(stderr, "[bam_pileup] fail to read the header: non-exisiting file or wrong format.\n");
+			return 1;
+		}
+		d->h = fp->header;
+		if (fn_pos) d->hash = load_pos(fn_pos, d->h);
+		sampileup(fp, d->mask, pileup_func, d);
+		samclose(fp); // d->h will be destroyed here
+	}
+
+	// free
+	if (d->format & BAM_PLF_GLF) bgzf_close(d->fp_glf);
+	if (fn_pos) { // free the hash table
+		khint_t k;
+		for (k = kh_begin(d->hash); k < kh_end(d->hash); ++k)
+			if (kh_exist(d->hash, k)) free(kh_val(d->hash, k));
+		kh_destroy(64, d->hash);
+	}
+	free(fn_pos); free(fn_list); free(fn_fa);
+	if (d->fai) fai_destroy(d->fai);
+	bam_maqcns_destroy(d->c);
+	free(d->ido); free(d->ref); free(d);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_rmdup.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_rmdup.c
new file mode 100644
index 0000000..f0d2b5d
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_rmdup.c
@@ -0,0 +1,206 @@
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <zlib.h>
+#include <unistd.h>
+#include "sam.h"
+
+typedef bam1_t *bam1_p;
+
+#include "khash.h"
+KHASH_SET_INIT_STR(name)
+KHASH_MAP_INIT_INT64(pos, bam1_p)
+
+#define BUFFER_SIZE 0x40000
+
+typedef struct {
+	uint64_t n_checked, n_removed;
+	khash_t(pos) *best_hash;
+} lib_aux_t;
+KHASH_MAP_INIT_STR(lib, lib_aux_t)
+
+typedef struct {
+	int n, max;
+	bam1_t **a;
+} tmp_stack_t;
+
+static inline void stack_insert(tmp_stack_t *stack, bam1_t *b)
+{
+	if (stack->n == stack->max) {
+		stack->max = stack->max? stack->max<<1 : 0x10000;
+		stack->a = (bam1_t**)realloc(stack->a, sizeof(bam1_t*) * stack->max);
+	}
+	stack->a[stack->n++] = b;
+}
+
+static inline void dump_best(tmp_stack_t *stack, samfile_t *out)
+{
+	int i;
+	for (i = 0; i != stack->n; ++i) {
+		samwrite(out, stack->a[i]);
+		bam_destroy1(stack->a[i]);
+	}
+	stack->n = 0;
+}
+
+static void clear_del_set(khash_t(name) *del_set)
+{
+	khint_t k;
+	for (k = kh_begin(del_set); k < kh_end(del_set); ++k)
+		if (kh_exist(del_set, k))
+			free((char*)kh_key(del_set, k));
+	kh_clear(name, del_set);
+}
+
+static lib_aux_t *get_aux(khash_t(lib) *aux, const char *lib)
+{
+	khint_t k = kh_get(lib, aux, lib);
+	if (k == kh_end(aux)) {
+		int ret;
+		char *p = strdup(lib);
+		lib_aux_t *q;
+		k = kh_put(lib, aux, p, &ret);
+		q = &kh_val(aux, k);
+		q->n_checked = q->n_removed = 0;
+		q->best_hash = kh_init(pos);
+		return q;
+	} else return &kh_val(aux, k);
+}
+
+static void clear_best(khash_t(lib) *aux, int max)
+{
+	khint_t k;
+	for (k = kh_begin(aux); k != kh_end(aux); ++k) {
+		if (kh_exist(aux, k)) {
+			lib_aux_t *q = &kh_val(aux, k);
+			if (kh_size(q->best_hash) >= max)
+				kh_clear(pos, q->best_hash);
+		}
+	}
+}
+
+static inline int sum_qual(const bam1_t *b)
+{
+	int i, q;
+	uint8_t *qual = bam1_qual(b);
+	for (i = q = 0; i < b->core.l_qseq; ++i) q += qual[i];
+	return q;
+}
+
+void bam_rmdup_core(samfile_t *in, samfile_t *out)
+{
+	bam1_t *b;
+	int last_tid = -1, last_pos = -1;
+	tmp_stack_t stack;
+	khint_t k;
+	khash_t(lib) *aux;
+	khash_t(name) *del_set;
+	
+	aux = kh_init(lib);
+	del_set = kh_init(name);
+	b = bam_init1();
+	memset(&stack, 0, sizeof(tmp_stack_t));
+
+	kh_resize(name, del_set, 4 * BUFFER_SIZE);
+	while (samread(in, b) >= 0) {
+		bam1_core_t *c = &b->core;
+		if (c->tid != last_tid || last_pos != c->pos) {
+			dump_best(&stack, out); // write the result
+			clear_best(aux, BUFFER_SIZE);
+			if (c->tid != last_tid) {
+				clear_best(aux, 0);
+				if (kh_size(del_set)) { // check
+					fprintf(stderr, "[bam_rmdup_core] %llu unmatched pairs\n", (long long)kh_size(del_set));
+					clear_del_set(del_set);
+				}
+				if ((int)c->tid == -1) { // append unmapped reads
+					samwrite(out, b);
+					while (samread(in, b) >= 0) samwrite(out, b);
+					break;
+				}
+				last_tid = c->tid;
+				fprintf(stderr, "[bam_rmdup_core] processing reference %s...\n", in->header->target_name[c->tid]);
+			}
+		}
+		if (!(c->flag&BAM_FPAIRED) || (c->flag&(BAM_FUNMAP|BAM_FMUNMAP)) || (c->mtid >= 0 && c->tid != c->mtid)) {
+			samwrite(out, b);
+		} else if (c->isize > 0) { // paired, head
+			uint64_t key = (uint64_t)c->pos<<32 | c->isize;
+			const char *lib;
+			lib_aux_t *q;
+			int ret;
+			lib = bam_get_library(in->header, b);
+			q = lib? get_aux(aux, lib) : get_aux(aux, "\t");
+			++q->n_checked;
+			k = kh_put(pos, q->best_hash, key, &ret);
+			if (ret == 0) { // found in best_hash
+				bam1_t *p = kh_val(q->best_hash, k);
+				++q->n_removed;
+				if (sum_qual(p) < sum_qual(b)) { // the current alignment is better; this can be accelerated in principle
+					kh_put(name, del_set, strdup(bam1_qname(p)), &ret); // p will be removed
+					bam_copy1(p, b); // replaced as b
+				} else kh_put(name, del_set, strdup(bam1_qname(b)), &ret); // b will be removed
+				if (ret == 0)
+					fprintf(stderr, "[bam_rmdup_core] inconsistent BAM file for pair '%s'. Continue anyway.\n", bam1_qname(b));
+			} else { // not found in best_hash
+				kh_val(q->best_hash, k) = bam_dup1(b);
+				stack_insert(&stack, kh_val(q->best_hash, k));
+			}
+		} else { // paired, tail
+			k = kh_get(name, del_set, bam1_qname(b));
+			if (k != kh_end(del_set)) {
+				free((char*)kh_key(del_set, k));
+				kh_del(name, del_set, k);
+			} else samwrite(out, b);
+		}
+		last_pos = c->pos;
+	}
+
+	for (k = kh_begin(aux); k != kh_end(aux); ++k) {
+		if (kh_exist(aux, k)) {
+			lib_aux_t *q = &kh_val(aux, k);			
+			dump_best(&stack, out);
+			fprintf(stderr, "[bam_rmdup_core] %lld / %lld = %.4lf in library '%s'\n", (long long)q->n_removed,
+					(long long)q->n_checked, (double)q->n_removed/q->n_checked, kh_key(aux, k));
+			kh_destroy(pos, q->best_hash);
+			free((char*)kh_key(aux, k));
+		}
+	}
+	kh_destroy(lib, aux);
+
+	clear_del_set(del_set);
+	kh_destroy(name, del_set);
+	free(stack.a);
+	bam_destroy1(b);
+}
+
+void bam_rmdupse_core(samfile_t *in, samfile_t *out, int force_se);
+
+int bam_rmdup(int argc, char *argv[])
+{
+	int c, is_se = 0, force_se = 0;
+	samfile_t *in, *out;
+	while ((c = getopt(argc, argv, "sS")) >= 0) {
+		switch (c) {
+		case 's': is_se = 1; break;
+		case 'S': force_se = is_se = 1; break;
+		}
+	}
+	if (optind + 2 > argc) {
+		fprintf(stderr, "\n");
+		fprintf(stderr, "Usage:  samtools rmdup [-sS] <input.srt.bam> <output.bam>\n\n");
+		fprintf(stderr, "Option: -s    rmdup for SE reads\n");
+		fprintf(stderr, "        -S    treat PE reads as SE in rmdup (force -s)\n\n");
+		return 1;
+	}
+	in = samopen(argv[optind], "rb", 0);
+	out = samopen(argv[optind+1], "wb", in->header);
+	if (in == 0 || out == 0) {
+		fprintf(stderr, "[bam_rmdup] fail to read/write input files\n");
+		return 1;
+	}
+	if (is_se) bam_rmdupse_core(in, out, force_se);
+	else bam_rmdup_core(in, out);
+	samclose(in); samclose(out);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_rmdupse.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_rmdupse.c
new file mode 100644
index 0000000..e7dbdc7
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_rmdupse.c
@@ -0,0 +1,159 @@
+#include <math.h>
+#include "sam.h"
+#include "khash.h"
+#include "klist.h"
+
+#define QUEUE_CLEAR_SIZE 0x100000
+#define MAX_POS 0x7fffffff
+
+typedef struct {
+	int endpos;
+	uint32_t score:31, discarded:1;
+	bam1_t *b;
+} elem_t, *elem_p;
+#define __free_elem(p) bam_destroy1((p)->data.b)
+KLIST_INIT(q, elem_t, __free_elem)
+typedef klist_t(q) queue_t;
+
+KHASH_MAP_INIT_INT(best, elem_p)
+typedef khash_t(best) besthash_t;
+
+typedef struct {
+	uint64_t n_checked, n_removed;
+	besthash_t *left, *rght;
+} lib_aux_t;
+KHASH_MAP_INIT_STR(lib, lib_aux_t)
+
+static lib_aux_t *get_aux(khash_t(lib) *aux, const char *lib)
+{
+	khint_t k = kh_get(lib, aux, lib);
+	if (k == kh_end(aux)) {
+		int ret;
+		char *p = strdup(lib);
+		lib_aux_t *q;
+		k = kh_put(lib, aux, p, &ret);
+		q = &kh_val(aux, k);
+		q->left = kh_init(best);
+		q->rght = kh_init(best);
+		q->n_checked = q->n_removed = 0;
+		return q;
+	} else return &kh_val(aux, k);
+}
+
+static inline int sum_qual(const bam1_t *b)
+{
+	int i, q;
+	uint8_t *qual = bam1_qual(b);
+	for (i = q = 0; i < b->core.l_qseq; ++i) q += qual[i];
+	return q;
+}
+
+static inline elem_t *push_queue(queue_t *queue, const bam1_t *b, int endpos, int score)
+{
+	elem_t *p = kl_pushp(q, queue);
+	p->discarded = 0;
+	p->endpos = endpos; p->score = score;
+	if (p->b == 0) p->b = bam_init1();
+	bam_copy1(p->b, b);
+	return p;
+}
+
+static void clear_besthash(besthash_t *h, int32_t pos)
+{
+	khint_t k;
+	for (k = kh_begin(h); k != kh_end(h); ++k)
+		if (kh_exist(h, k) && kh_val(h, k)->endpos <= pos)
+			kh_del(best, h, k);
+}
+
+static void dump_alignment(samfile_t *out, queue_t *queue, int32_t pos, khash_t(lib) *h)
+{
+	if (queue->size > QUEUE_CLEAR_SIZE || pos == MAX_POS) {
+		khint_t k;
+		while (1) {
+			elem_t *q;
+			if (queue->head == queue->tail) break;
+			q = &kl_val(queue->head);
+			if (q->discarded) {
+				q->b->data_len = 0;
+				kl_shift(q, queue, 0);
+				continue;
+			}
+			if ((q->b->core.flag&BAM_FREVERSE) && q->endpos > pos) break;
+			samwrite(out, q->b);
+			q->b->data_len = 0;
+			kl_shift(q, queue, 0);
+		}
+		for (k = kh_begin(h); k != kh_end(h); ++k) {
+			if (kh_exist(h, k)) {
+				clear_besthash(kh_val(h, k).left, pos);
+				clear_besthash(kh_val(h, k).rght, pos);
+			}
+		}
+	}
+}
+
+void bam_rmdupse_core(samfile_t *in, samfile_t *out, int force_se)
+{
+	bam1_t *b;
+	queue_t *queue;
+	khint_t k;
+	int last_tid = -2;
+	khash_t(lib) *aux;
+
+	aux = kh_init(lib);
+	b = bam_init1();
+	queue = kl_init(q);
+	while (samread(in, b) >= 0) {
+		bam1_core_t *c = &b->core;
+		int endpos = bam_calend(c, bam1_cigar(b));
+		int score = sum_qual(b);
+		
+		if (last_tid != c->tid) {
+			if (last_tid >= 0) dump_alignment(out, queue, MAX_POS, aux);
+			last_tid = c->tid;
+		} else dump_alignment(out, queue, c->pos, aux);
+		if ((c->flag&BAM_FUNMAP) || ((c->flag&BAM_FPAIRED) && !force_se)) {
+			push_queue(queue, b, endpos, score);
+		} else {
+			const char *lib;
+			lib_aux_t *q;
+			besthash_t *h;
+			uint32_t key;
+			int ret;
+			lib = bam_get_library(in->header, b);
+			q = lib? get_aux(aux, lib) : get_aux(aux, "\t");
+			++q->n_checked;
+			h = (c->flag&BAM_FREVERSE)? q->rght : q->left;
+			key = (c->flag&BAM_FREVERSE)? endpos : c->pos;
+			k = kh_put(best, h, key, &ret);
+			if (ret == 0) { // in the hash table
+				elem_t *p = kh_val(h, k);
+				++q->n_removed;
+				if (p->score < score) {
+					if (c->flag&BAM_FREVERSE) { // mark "discarded" and push the queue
+						p->discarded = 1;
+						kh_val(h, k) = push_queue(queue, b, endpos, score);
+					} else { // replace
+						p->score = score; p->endpos = endpos;
+						bam_copy1(p->b, b);
+					}
+				} // otherwise, discard the alignment
+			} else kh_val(h, k) = push_queue(queue, b, endpos, score);
+		}
+	}
+	dump_alignment(out, queue, MAX_POS, aux);
+
+	for (k = kh_begin(aux); k != kh_end(aux); ++k) {
+		if (kh_exist(aux, k)) {
+			lib_aux_t *q = &kh_val(aux, k);
+			fprintf(stderr, "[bam_rmdupse_core] %lld / %lld = %.4lf in library '%s'\n", (long long)q->n_removed,
+					(long long)q->n_checked, (double)q->n_removed/q->n_checked, kh_key(aux, k));
+			kh_destroy(best, q->left); kh_destroy(best, q->rght);
+			free((char*)kh_key(aux, k));
+		}
+	}
+	kh_destroy(lib, aux);
+	bam_destroy1(b);
+	kl_destroy(q, queue);
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_sort.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_sort.c
new file mode 100644
index 0000000..9884f3d
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_sort.c
@@ -0,0 +1,357 @@
+#include <stdlib.h>
+#include <ctype.h>
+#include <assert.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include "bam.h"
+#include "ksort.h"
+
+static int g_is_by_qname = 0;
+
+static inline int strnum_cmp(const char *a, const char *b)
+{
+	char *pa, *pb;
+	pa = (char*)a; pb = (char*)b;
+	while (*pa && *pb) {
+		if (isdigit(*pa) && isdigit(*pb)) {
+			long ai, bi;
+			ai = strtol(pa, &pa, 10);
+			bi = strtol(pb, &pb, 10);
+			if (ai != bi) return ai<bi? -1 : ai>bi? 1 : 0;
+		} else {
+			if (*pa != *pb) break;
+			++pa; ++pb;
+		}
+	}
+	if (*pa == *pb)
+		return (pa-a) < (pb-b)? -1 : (pa-a) > (pb-b)? 1 : 0;
+	return *pa<*pb? -1 : *pa>*pb? 1 : 0;
+}
+
+#define HEAP_EMPTY 0xffffffffffffffffull
+
+typedef struct {
+	int i;
+	uint64_t pos, idx;
+	bam1_t *b;
+} heap1_t;
+
+#define __pos_cmp(a, b) ((a).pos > (b).pos || ((a).pos == (b).pos && ((a).i > (b).i || ((a).i == (b).i && (a).idx > (b).idx))))
+
+static inline int heap_lt(const heap1_t a, const heap1_t b)
+{
+	if (g_is_by_qname) {
+		int t;
+		if (a.b == 0 || b.b == 0) return a.b == 0? 1 : 0;
+		t = strnum_cmp(bam1_qname(a.b), bam1_qname(b.b));
+		return (t > 0 || (t == 0 && __pos_cmp(a, b)));
+	} else return __pos_cmp(a, b);
+}
+
+KSORT_INIT(heap, heap1_t, heap_lt)
+
+static void swap_header_text(bam_header_t *h1, bam_header_t *h2)
+{
+	int tempi;
+	char *temps;
+	tempi = h1->l_text, h1->l_text = h2->l_text, h2->l_text = tempi;
+	temps = h1->text, h1->text = h2->text, h2->text = temps;
+}
+
+/*!
+  @abstract    Merge multiple sorted BAM.
+  @param  is_by_qname whether to sort by query name
+  @param  out  output BAM file name
+  @param  headers  name of SAM file from which to copy '@' header lines,
+                   or NULL to copy them from the first file to be merged
+  @param  n    number of files to be merged
+  @param  fn   names of files to be merged
+
+  @discussion Padding information may NOT correctly maintained. This
+  function is NOT thread safe.
+ */
+void bam_merge_core(int by_qname, const char *out, const char *headers, int n, char * const *fn, int add_RG)
+{
+	bamFile fpout, *fp;
+	heap1_t *heap;
+	bam_header_t *hout = 0;
+	bam_header_t *hheaders = NULL;
+	int i, j, *RG_len = 0;
+	uint64_t idx = 0;
+	char **RG = 0;
+
+	if (headers) {
+		tamFile fpheaders = sam_open(headers);
+		if (fpheaders == 0) {
+			fprintf(stderr, "[bam_merge_core] Cannot open file `%s'. Continue anyway.\n", headers);
+		} else {
+			hheaders = sam_header_read(fpheaders);
+			sam_close(fpheaders);
+		}
+	}
+
+	g_is_by_qname = by_qname;
+	fp = (bamFile*)calloc(n, sizeof(bamFile));
+	heap = (heap1_t*)calloc(n, sizeof(heap1_t));
+	// prepare RG tag
+	if (add_RG) {
+		RG = (char**)calloc(n, sizeof(void*));
+		RG_len = (int*)calloc(n, sizeof(int));
+		for (i = 0; i != n; ++i) {
+			int l = strlen(fn[i]);
+			const char *s = fn[i];
+			if (l > 4 && strcmp(s + l - 4, ".bam") == 0) l -= 4;
+			for (j = l - 1; j >= 0; --j) if (s[j] == '/') break;
+			++j; l -= j;
+			RG[i] = calloc(l + 1, 1);
+			RG_len[i] = l;
+			strncpy(RG[i], s + j, l);
+		}
+	}
+	// read the first
+	for (i = 0; i != n; ++i) {
+		heap1_t *h;
+		bam_header_t *hin;
+		fp[i] = bam_open(fn[i], "r");
+		if (fp[i] == 0) {
+			int j;
+			fprintf(stderr, "[bam_merge_core] fail to open file %s\n", fn[i]);
+			for (j = 0; j < i; ++j) bam_close(fp[j]);
+			free(fp); free(heap);
+			// FIXME: possible memory leak
+			return;
+		}
+		hin = bam_header_read(fp[i]);
+		if (i == 0) { // the first SAM
+			hout = hin;
+			if (hheaders) {
+				// If the text headers to be swapped in include any @SQ headers,
+				// check that they are consistent with the existing binary list
+				// of reference information.
+				if (hheaders->n_targets > 0) {
+					if (hout->n_targets != hheaders->n_targets)
+						fprintf(stderr, "[bam_merge_core] number of @SQ headers in `%s' differs from number of target sequences", headers);
+					for (j = 0; j < hout->n_targets; ++j)
+						if (strcmp(hout->target_name[j], hheaders->target_name[j]) != 0)
+							fprintf(stderr, "[bam_merge_core] @SQ header '%s' in '%s' differs from target sequence", hheaders->target_name[j], headers);
+				}
+				swap_header_text(hout, hheaders);
+				bam_header_destroy(hheaders);
+				hheaders = NULL;
+			}
+		} else { // validate multiple baf
+			if (hout->n_targets != hin->n_targets) {
+				fprintf(stderr, "[bam_merge_core] file '%s' has different number of target sequences. Abort!\n", fn[i]);
+				exit(1);
+			}
+			for (j = 0; j < hout->n_targets; ++j) {
+				if (strcmp(hout->target_name[j], hin->target_name[j])) {
+					fprintf(stderr, "[bam_merge_core] different target sequence name: '%s' != '%s' in file '%s'. Abort!\n",
+							hout->target_name[j], hin->target_name[j], fn[i]);
+					exit(1);
+				}
+			}
+			bam_header_destroy(hin);
+		}
+		h = heap + i;
+		h->i = i;
+		h->b = (bam1_t*)calloc(1, sizeof(bam1_t));
+		if (bam_read1(fp[i], h->b) >= 0) {
+			h->pos = ((uint64_t)h->b->core.tid<<32) | (uint32_t)h->b->core.pos<<1 | bam1_strand(h->b);
+			h->idx = idx++;
+		}
+		else h->pos = HEAP_EMPTY;
+	}
+	fpout = strcmp(out, "-")? bam_open(out, "w") : bam_dopen(fileno(stdout), "w");
+	assert(fpout);
+	bam_header_write(fpout, hout);
+	bam_header_destroy(hout);
+
+	ks_heapmake(heap, n, heap);
+	while (heap->pos != HEAP_EMPTY) {
+		bam1_t *b = heap->b;
+		if (add_RG && bam_aux_get(b, "RG") == 0)
+			bam_aux_append(b, "RG", 'Z', RG_len[heap->i] + 1, (uint8_t*)RG[heap->i]);
+		bam_write1_core(fpout, &b->core, b->data_len, b->data);
+		if ((j = bam_read1(fp[heap->i], b)) >= 0) {
+			heap->pos = ((uint64_t)b->core.tid<<32) | (uint32_t)b->core.pos<<1 | bam1_strand(b);
+			heap->idx = idx++;
+		} else if (j == -1) {
+			heap->pos = HEAP_EMPTY;
+			free(heap->b->data); free(heap->b);
+			heap->b = 0;
+		} else fprintf(stderr, "[bam_merge_core] '%s' is truncated. Continue anyway.\n", fn[heap->i]);
+		ks_heapadjust(heap, 0, n, heap);
+	}
+
+	if (add_RG) {
+		for (i = 0; i != n; ++i) free(RG[i]);
+		free(RG); free(RG_len);
+	}
+	for (i = 0; i != n; ++i) bam_close(fp[i]);
+	bam_close(fpout);
+	free(fp); free(heap);
+}
+int bam_merge(int argc, char *argv[])
+{
+	int c, is_by_qname = 0, add_RG = 0;
+	char *fn_headers = NULL;
+
+	while ((c = getopt(argc, argv, "h:nr")) >= 0) {
+		switch (c) {
+		case 'r': add_RG = 1; break;
+		case 'h': fn_headers = strdup(optarg); break;
+		case 'n': is_by_qname = 1; break;
+		}
+	}
+	if (optind + 2 >= argc) {
+		fprintf(stderr, "\n");
+		fprintf(stderr, "Usage:   samtools merge [-nr] [-h inh.sam] <out.bam> <in1.bam> <in2.bam> [...]\n\n");
+		fprintf(stderr, "Options: -n       sort by read names\n");
+		fprintf(stderr, "         -r       attach RG tag (inferred from file names)\n");
+		fprintf(stderr, "         -h FILE  copy the header in FILE to <out.bam> [in1.bam]\n\n");
+		fprintf(stderr, "Note: Samtools' merge does not reconstruct the @RG dictionary in the header. Users\n");
+		fprintf(stderr, "      must provide the correct header with -h, or uses Picard which properly maintains\n");
+		fprintf(stderr, "      the header dictionary in merging.\n\n");
+		return 1;
+	}
+	bam_merge_core(is_by_qname, argv[optind], fn_headers, argc - optind - 1, argv + optind + 1, add_RG);
+	free(fn_headers);
+	return 0;
+}
+
+typedef bam1_t *bam1_p;
+
+static inline int bam1_lt(const bam1_p a, const bam1_p b)
+{
+	if (g_is_by_qname) {
+		int t = strnum_cmp(bam1_qname(a), bam1_qname(b));
+		return (t < 0 || (t == 0 && (((uint64_t)a->core.tid<<32|a->core.pos) < ((uint64_t)b->core.tid<<32|b->core.pos))));
+	} else return (((uint64_t)a->core.tid<<32|a->core.pos) < ((uint64_t)b->core.tid<<32|b->core.pos));
+}
+KSORT_INIT(sort, bam1_p, bam1_lt)
+
+static void sort_blocks(int n, int k, bam1_p *buf, const char *prefix, const bam_header_t *h, int is_stdout)
+{
+	char *name;
+	int i;
+	bamFile fp;
+	ks_mergesort(sort, k, buf, 0);
+	name = (char*)calloc(strlen(prefix) + 20, 1);
+	if (n >= 0) sprintf(name, "%s.%.4d.bam", prefix, n);
+	else sprintf(name, "%s.bam", prefix);
+	fp = is_stdout? bam_dopen(fileno(stdout), "w") : bam_open(name, "w");
+	if (fp == 0) {
+		fprintf(stderr, "[sort_blocks] fail to create file %s.\n", name);
+		free(name);
+		// FIXME: possible memory leak
+		return;
+	}
+	free(name);
+	bam_header_write(fp, h);
+	for (i = 0; i < k; ++i)
+		bam_write1_core(fp, &buf[i]->core, buf[i]->data_len, buf[i]->data);
+	bam_close(fp);
+}
+
+/*!
+  @abstract Sort an unsorted BAM file based on the chromosome order
+  and the leftmost position of an alignment
+
+  @param  is_by_qname whether to sort by query name
+  @param  fn       name of the file to be sorted
+  @param  prefix   prefix of the output and the temporary files; upon
+	                   sucessess, prefix.bam will be written.
+  @param  max_mem  approxiate maximum memory (very inaccurate)
+
+  @discussion It may create multiple temporary subalignment files
+  and then merge them by calling bam_merge_core(). This function is
+  NOT thread safe.
+ */
+void bam_sort_core_ext(int is_by_qname, const char *fn, const char *prefix, size_t max_mem, int is_stdout)
+{
+	int n, ret, k, i;
+	size_t mem;
+	bam_header_t *header;
+	bamFile fp;
+	bam1_t *b, **buf;
+
+	g_is_by_qname = is_by_qname;
+	n = k = 0; mem = 0;
+	fp = strcmp(fn, "-")? bam_open(fn, "r") : bam_dopen(fileno(stdin), "r");
+	if (fp == 0) {
+		fprintf(stderr, "[bam_sort_core] fail to open file %s\n", fn);
+		return;
+	}
+	header = bam_header_read(fp);
+	buf = (bam1_t**)calloc(max_mem / BAM_CORE_SIZE, sizeof(bam1_t*));
+	// write sub files
+	for (;;) {
+		if (buf[k] == 0) buf[k] = (bam1_t*)calloc(1, sizeof(bam1_t));
+		b = buf[k];
+		if ((ret = bam_read1(fp, b)) < 0) break;
+		mem += ret;
+		++k;
+		if (mem >= max_mem) {
+			sort_blocks(n++, k, buf, prefix, header, is_stdout);
+			mem = 0; k = 0;
+		}
+	}
+	if (ret != -1)
+		fprintf(stderr, "[bam_sort_core] truncated file. Continue anyway.\n");
+	if (n == 0) sort_blocks(-1, k, buf, prefix, header, is_stdout);
+	else { // then merge
+		char **fns, *fnout;
+		fprintf(stderr, "[bam_sort_core] merging from %d files...\n", n+1);
+		sort_blocks(n++, k, buf, prefix, header, is_stdout);
+		fnout = (char*)calloc(strlen(prefix) + 20, 1);
+		if (is_stdout) sprintf(fnout, "-");
+		else sprintf(fnout, "%s.bam", prefix);
+		fns = (char**)calloc(n, sizeof(char*));
+		for (i = 0; i < n; ++i) {
+			fns[i] = (char*)calloc(strlen(prefix) + 20, 1);
+			sprintf(fns[i], "%s.%.4d.bam", prefix, i);
+		}
+		bam_merge_core(is_by_qname, fnout, 0, n, fns, 0);
+		free(fnout);
+		for (i = 0; i < n; ++i) {
+			unlink(fns[i]);
+			free(fns[i]);
+		}
+		free(fns);
+	}
+	for (k = 0; k < max_mem / BAM_CORE_SIZE; ++k) {
+		if (buf[k]) {
+			free(buf[k]->data);
+			free(buf[k]);
+		}
+	}
+	free(buf);
+	bam_header_destroy(header);
+	bam_close(fp);
+}
+
+void bam_sort_core(int is_by_qname, const char *fn, const char *prefix, size_t max_mem)
+{
+	bam_sort_core_ext(is_by_qname, fn, prefix, max_mem, 0);
+}
+
+int bam_sort(int argc, char *argv[])
+{
+	size_t max_mem = 500000000;
+	int c, is_by_qname = 0, is_stdout = 0;
+	while ((c = getopt(argc, argv, "nom:")) >= 0) {
+		switch (c) {
+		case 'o': is_stdout = 1; break;
+		case 'n': is_by_qname = 1; break;
+		case 'm': max_mem = atol(optarg); break;
+		}
+	}
+	if (optind + 2 > argc) {
+		fprintf(stderr, "Usage: samtools sort [-on] [-m <maxMem>] <in.bam> <out.prefix>\n");
+		return 1;
+	}
+	bam_sort_core_ext(is_by_qname, argv[optind], argv[optind+1], max_mem, is_stdout);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_stat.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_stat.c
new file mode 100644
index 0000000..ea9deee
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_stat.c
@@ -0,0 +1,78 @@
+#include <unistd.h>
+#include <assert.h>
+#include "bam.h"
+
+typedef struct {
+	long long n_reads, n_mapped, n_pair_all, n_pair_map, n_pair_good;
+	long long n_sgltn, n_read1, n_read2;
+	long long n_qcfail, n_dup;
+	long long n_diffchr, n_diffhigh;
+} bam_flagstat_t;
+
+#define flagstat_loop(s, c) do {										\
+		++(s)->n_reads;													\
+		if ((c)->flag & BAM_FPAIRED) {									\
+			++(s)->n_pair_all;											\
+			if ((c)->flag & BAM_FPROPER_PAIR) ++(s)->n_pair_good;		\
+			if ((c)->flag & BAM_FREAD1) ++(s)->n_read1;					\
+			if ((c)->flag & BAM_FREAD2) ++(s)->n_read2;					\
+			if (((c)->flag & BAM_FMUNMAP) && !((c)->flag & BAM_FUNMAP)) ++(s)->n_sgltn;	\
+			if (!((c)->flag & BAM_FUNMAP) && !((c)->flag & BAM_FMUNMAP)) { \
+				++(s)->n_pair_map;										\
+				if ((c)->mtid != (c)->tid) {							\
+					++(s)->n_diffchr;									\
+					if ((c)->qual >= 5) ++(s)->n_diffhigh;				\
+				}														\
+			}															\
+		}																\
+		if (!((c)->flag & BAM_FUNMAP)) ++(s)->n_mapped;					\
+		if ((c)->flag & BAM_FQCFAIL) ++(s)->n_qcfail;					\
+		if ((c)->flag & BAM_FDUP) ++(s)->n_dup;							\
+	} while (0)
+
+bam_flagstat_t *bam_flagstat_core(bamFile fp)
+{
+	bam_flagstat_t *s;
+	bam1_t *b;
+	bam1_core_t *c;
+	int ret;
+	s = (bam_flagstat_t*)calloc(1, sizeof(bam_flagstat_t));
+	b = bam_init1();
+	c = &b->core;
+	while ((ret = bam_read1(fp, b)) >= 0)
+		flagstat_loop(s, c);
+	bam_destroy1(b);
+	if (ret != -1)
+		fprintf(stderr, "[bam_flagstat_core] Truncated file? Continue anyway.\n");
+	return s;
+}
+int bam_flagstat(int argc, char *argv[])
+{
+	bamFile fp;
+	bam_header_t *header;
+	bam_flagstat_t *s;
+	if (argc == optind) {
+		fprintf(stderr, "Usage: samtools flagstat <in.bam>\n");
+		return 1;
+	}
+	fp = strcmp(argv[optind], "-")? bam_open(argv[optind], "r") : bam_dopen(fileno(stdin), "r");
+	assert(fp);
+	header = bam_header_read(fp);
+	s = bam_flagstat_core(fp);
+	printf("%lld in total\n", s->n_reads);
+	printf("%lld QC failure\n", s->n_qcfail);
+	printf("%lld duplicates\n", s->n_dup);
+	printf("%lld mapped (%.2f%%)\n", s->n_mapped, (float)s->n_mapped / s->n_reads * 100.0);
+	printf("%lld paired in sequencing\n", s->n_pair_all);
+	printf("%lld read1\n", s->n_read1);
+	printf("%lld read2\n", s->n_read2);
+	printf("%lld properly paired (%.2f%%)\n", s->n_pair_good, (float)s->n_pair_good / s->n_pair_all * 100.0);
+	printf("%lld with itself and mate mapped\n", s->n_pair_map);
+	printf("%lld singletons (%.2f%%)\n", s->n_sgltn, (float)s->n_sgltn / s->n_pair_all * 100.0);
+	printf("%lld with mate mapped to a different chr\n", s->n_diffchr);
+	printf("%lld with mate mapped to a different chr (mapQ>=5)\n", s->n_diffhigh);
+	free(s);
+	bam_header_destroy(header);
+	bam_close(fp);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bam_tview.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_tview.c
new file mode 100644
index 0000000..4c121e7
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bam_tview.c
@@ -0,0 +1,415 @@
+#undef _HAVE_CURSES
+
+#if _CURSES_LIB == 0
+#elif _CURSES_LIB == 1
+#include <curses.h>
+#ifndef NCURSES_VERSION
+#warning "_CURSES_LIB=1 but NCURSES_VERSION not defined; tview is NOT compiled"
+#else
+#define _HAVE_CURSES
+#endif
+#elif _CURSES_LIB == 2
+#include <xcurses.h>
+#define _HAVE_CURSES
+#else
+#warning "_CURSES_LIB is not 0, 1 or 2; tview is NOT compiled"
+#endif
+
+#ifdef _HAVE_CURSES
+#include <ctype.h>
+#include <assert.h>
+#include <string.h>
+#include "bam.h"
+#include "faidx.h"
+#include "bam_maqcns.h"
+
+char bam_aux_getCEi(bam1_t *b, int i);
+char bam_aux_getCSi(bam1_t *b, int i);
+char bam_aux_getCQi(bam1_t *b, int i);
+
+#define TV_MIN_ALNROW 2
+#define TV_MAX_GOTO  40
+#define TV_LOW_MAPQ  10
+
+#define TV_COLOR_MAPQ   0
+#define TV_COLOR_BASEQ  1
+#define TV_COLOR_NUCL   2
+#define TV_COLOR_COL    3
+#define TV_COLOR_COLQ   4
+
+#define TV_BASE_NUCL 0
+#define TV_BASE_COLOR_SPACE 1
+
+typedef struct {
+	int mrow, mcol;
+	WINDOW *wgoto, *whelp;
+
+	bam_index_t *idx;
+	bam_lplbuf_t *lplbuf;
+	bam_header_t *header;
+	bamFile fp;
+	int curr_tid, left_pos;
+	faidx_t *fai;
+	bam_maqcns_t *bmc;
+
+	int ccol, last_pos, row_shift, base_for, color_for, is_dot, l_ref, ins, no_skip, show_name;
+	char *ref;
+} tview_t;
+
+int tv_pl_func(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data)
+{
+	tview_t *tv = (tview_t*)data;
+	int i, j, c, rb, attr, max_ins = 0;
+	uint32_t call = 0;
+	if (pos < tv->left_pos || tv->ccol > tv->mcol) return 0; // out of screen
+	// print referece
+	rb = (tv->ref && pos - tv->left_pos < tv->l_ref)? tv->ref[pos - tv->left_pos] : 'N';
+	for (i = tv->last_pos + 1; i < pos; ++i) {
+		if (i%10 == 0 && tv->mcol - tv->ccol >= 10) mvprintw(0, tv->ccol, "%-d", i+1);
+		c = tv->ref? tv->ref[i - tv->left_pos] : 'N';
+		mvaddch(1, tv->ccol++, c);
+	}
+	if (pos%10 == 0 && tv->mcol - tv->ccol >= 10) mvprintw(0, tv->ccol, "%-d", pos+1);
+	// print consensus
+	call = bam_maqcns_call(n, pl, tv->bmc);
+	attr = A_UNDERLINE;
+	c = ",ACMGRSVTWYHKDBN"[call>>28&0xf];
+	i = (call>>8&0xff)/10+1;
+	if (i > 4) i = 4;
+	attr |= COLOR_PAIR(i);
+	if (c == toupper(rb)) c = '.';
+	attron(attr);
+	mvaddch(2, tv->ccol, c);
+	attroff(attr);
+	if(tv->ins) {
+		// calculate maximum insert
+		for (i = 0; i < n; ++i) {
+			const bam_pileup1_t *p = pl + i;
+			if (p->indel > 0 && max_ins < p->indel) max_ins = p->indel;
+		}
+	}
+	// core loop
+	for (j = 0; j <= max_ins; ++j) {
+		for (i = 0; i < n; ++i) {
+			const bam_pileup1_t *p = pl + i;
+			int row = TV_MIN_ALNROW + p->level - tv->row_shift;
+			if (j == 0) {
+				if (!p->is_del) {
+					if (tv->base_for == TV_BASE_COLOR_SPACE && 
+							(c = bam_aux_getCSi(p->b, p->qpos))) {
+						c = bam_aux_getCSi(p->b, p->qpos);
+						// assume that if we found one color, we will be able to get the color error
+						if (tv->is_dot && '-' == bam_aux_getCEi(p->b, p->qpos)) c = bam1_strand(p->b)? ',' : '.';
+					} else {
+						if (tv->show_name) {
+							char *name = bam1_qname(p->b);
+							c = (p->qpos + 1 >= p->b->core.l_qname)? ' ' : name[p->qpos];
+						} else {
+							c = bam_nt16_rev_table[bam1_seqi(bam1_seq(p->b), p->qpos)];
+							if (tv->is_dot && toupper(c) == toupper(rb)) c = bam1_strand(p->b)? ',' : '.';
+						}
+					}
+				} else c = '*';
+			} else { // padding
+				if (j > p->indel) c = '*';
+				else { // insertion
+					if (tv->base_for ==  TV_BASE_NUCL) {
+						if (tv->show_name) {
+							char *name = bam1_qname(p->b);
+							c = (p->qpos + j + 1 >= p->b->core.l_qname)? ' ' : name[p->qpos + j];
+						} else {
+							c = bam_nt16_rev_table[bam1_seqi(bam1_seq(p->b), p->qpos + j)];
+							if (j == 0 && tv->is_dot && toupper(c) == toupper(rb)) c = bam1_strand(p->b)? ',' : '.';
+						}
+					} else {
+						c = bam_aux_getCSi(p->b, p->qpos + j);
+						if (tv->is_dot && '-' == bam_aux_getCEi(p->b, p->qpos + j)) c = bam1_strand(p->b)? ',' : '.';
+					}
+				}
+			}
+			if (row > TV_MIN_ALNROW && row < tv->mrow) {
+				int x;
+				attr = 0;
+				if (((p->b->core.flag&BAM_FPAIRED) && !(p->b->core.flag&BAM_FPROPER_PAIR))
+						|| (p->b->core.flag & BAM_FSECONDARY)) attr |= A_UNDERLINE;
+				if (tv->color_for == TV_COLOR_BASEQ) {
+					x = bam1_qual(p->b)[p->qpos]/10 + 1;
+					if (x > 4) x = 4;
+					attr |= COLOR_PAIR(x);
+				} else if (tv->color_for == TV_COLOR_MAPQ) {
+					x = p->b->core.qual/10 + 1;
+					if (x > 4) x = 4;
+					attr |= COLOR_PAIR(x);
+				} else if (tv->color_for == TV_COLOR_NUCL) {
+					x = bam_nt16_nt4_table[bam1_seqi(bam1_seq(p->b), p->qpos)] + 5;
+					attr |= COLOR_PAIR(x);
+				} else if(tv->color_for == TV_COLOR_COL) {
+					x = 0;
+					switch(bam_aux_getCSi(p->b, p->qpos)) {
+						case '0': x = 0; break;
+						case '1': x = 1; break;
+						case '2': x = 2; break;
+						case '3': x = 3; break;
+						case '4': x = 4; break;
+						default: x = bam_nt16_nt4_table[bam1_seqi(bam1_seq(p->b), p->qpos)]; break;
+					}
+					x+=5;
+					attr |= COLOR_PAIR(x);
+				} else if(tv->color_for == TV_COLOR_COLQ) {
+					x = bam_aux_getCQi(p->b, p->qpos);
+					if(0 == x) x = bam1_qual(p->b)[p->qpos];
+					x = x/10 + 1;
+					if (x > 4) x = 4;
+					attr |= COLOR_PAIR(x);
+				}
+				attron(attr);
+				mvaddch(row, tv->ccol, bam1_strand(p->b)? tolower(c) : toupper(c));
+				attroff(attr);
+			}
+		}
+		c = j? '*' : rb;
+		if (c == '*') {
+			attr = COLOR_PAIR(8);
+			attron(attr);
+			mvaddch(1, tv->ccol++, c);
+			attroff(attr);
+		} else mvaddch(1, tv->ccol++, c);
+	}
+	tv->last_pos = pos;
+	return 0;
+}
+
+tview_t *tv_init(const char *fn, const char *fn_fa)
+{
+	tview_t *tv = (tview_t*)calloc(1, sizeof(tview_t));
+	tv->is_dot = 1;
+	tv->idx = bam_index_load(fn);
+	if (tv->idx == 0) exit(1);
+	tv->fp = bam_open(fn, "r");
+	bgzf_set_cache_size(tv->fp, 8 * 1024 *1024);
+	assert(tv->fp);
+	tv->header = bam_header_read(tv->fp);
+	tv->lplbuf = bam_lplbuf_init(tv_pl_func, tv);
+	if (fn_fa) tv->fai = fai_load(fn_fa);
+	tv->bmc = bam_maqcns_init();
+	tv->ins = 1;
+	bam_maqcns_prepare(tv->bmc);
+
+	initscr();
+	keypad(stdscr, TRUE);
+	clear();
+	noecho();
+	cbreak();
+	tv->mrow = 24; tv->mcol = 80;
+	getmaxyx(stdscr, tv->mrow, tv->mcol);
+	tv->wgoto = newwin(3, TV_MAX_GOTO + 10, 10, 5);
+	tv->whelp = newwin(29, 40, 5, 5);
+	tv->color_for = TV_COLOR_MAPQ;
+	start_color();
+	init_pair(1, COLOR_BLUE, COLOR_BLACK);
+	init_pair(2, COLOR_GREEN, COLOR_BLACK);
+	init_pair(3, COLOR_YELLOW, COLOR_BLACK);
+	init_pair(4, COLOR_WHITE, COLOR_BLACK);
+	init_pair(5, COLOR_GREEN, COLOR_BLACK);
+	init_pair(6, COLOR_CYAN, COLOR_BLACK);
+	init_pair(7, COLOR_YELLOW, COLOR_BLACK);
+	init_pair(8, COLOR_RED, COLOR_BLACK);
+	init_pair(9, COLOR_BLUE, COLOR_BLACK);
+	return tv;
+}
+
+void tv_destroy(tview_t *tv)
+{
+	delwin(tv->wgoto); delwin(tv->whelp);
+	endwin();
+
+	bam_lplbuf_destroy(tv->lplbuf);
+	bam_maqcns_destroy(tv->bmc);
+	bam_index_destroy(tv->idx);
+	if (tv->fai) fai_destroy(tv->fai);
+	free(tv->ref);
+	bam_header_destroy(tv->header);
+	bam_close(tv->fp);
+	free(tv);
+}
+
+int tv_fetch_func(const bam1_t *b, void *data)
+{
+	tview_t *tv = (tview_t*)data;
+	if (tv->no_skip) {
+		uint32_t *cigar = bam1_cigar(b); // this is cheating...
+		int i;
+		for (i = 0; i <b->core.n_cigar; ++i) {
+			if ((cigar[i]&0xf) == BAM_CREF_SKIP)
+				cigar[i] = cigar[i]>>4<<4 | BAM_CDEL;
+		}
+	}
+	bam_lplbuf_push(b, tv->lplbuf);
+	return 0;
+}
+
+int tv_draw_aln(tview_t *tv, int tid, int pos)
+{
+	// reset
+	clear();
+	tv->curr_tid = tid; tv->left_pos = pos;
+	tv->last_pos = tv->left_pos - 1;
+	tv->ccol = 0;
+	// print ref and consensus
+	if (tv->fai) {
+		char *str;
+		if (tv->ref) free(tv->ref);
+		str = (char*)calloc(strlen(tv->header->target_name[tv->curr_tid]) + 30, 1);
+		sprintf(str, "%s:%d-%d", tv->header->target_name[tv->curr_tid], tv->left_pos + 1, tv->left_pos + tv->mcol);
+		tv->ref = fai_fetch(tv->fai, str, &tv->l_ref);
+		free(str);
+	}
+	// draw aln
+	bam_lplbuf_reset(tv->lplbuf);
+	bam_fetch(tv->fp, tv->idx, tv->curr_tid, tv->left_pos, tv->left_pos + tv->mcol, tv, tv_fetch_func);
+	bam_lplbuf_push(0, tv->lplbuf);
+
+	while (tv->ccol < tv->mcol) {
+		int pos = tv->last_pos + 1;
+		if (pos%10 == 0 && tv->mcol - tv->ccol >= 10) mvprintw(0, tv->ccol, "%-d", pos+1);
+		mvaddch(1, tv->ccol++, (tv->ref && pos < tv->l_ref)? tv->ref[pos - tv->left_pos] : 'N');
+		++tv->last_pos;
+	}
+	return 0;
+}
+
+static void tv_win_goto(tview_t *tv, int *tid, int *pos)
+{
+	char str[256];
+	int i, l = 0;
+	wborder(tv->wgoto, '|', '|', '-', '-', '+', '+', '+', '+');
+	mvwprintw(tv->wgoto, 1, 2, "Goto: ");
+	for (;;) {
+		int c = wgetch(tv->wgoto);
+		wrefresh(tv->wgoto);
+		if (c == KEY_BACKSPACE || c == '\010' || c == '\177') {
+			--l;
+		} else if (c == KEY_ENTER || c == '\012' || c == '\015') {
+			int _tid = -1, _beg, _end;
+			bam_parse_region(tv->header, str, &_tid, &_beg, &_end);
+			if (_tid >= 0) {
+				*tid = _tid; *pos = _beg;
+				return;
+			}
+		} else if (isgraph(c)) {
+			if (l < TV_MAX_GOTO) str[l++] = c;
+		} else if (c == '\027') l = 0;
+		else if (c == '\033') return;
+		str[l] = '\0';
+		for (i = 0; i < TV_MAX_GOTO; ++i) mvwaddch(tv->wgoto, 1, 8 + i, ' ');
+		mvwprintw(tv->wgoto, 1, 8, "%s", str);
+	}
+}
+
+static void tv_win_help(tview_t *tv) {
+	int r = 1;
+	WINDOW *win = tv->whelp;
+	wborder(win, '|', '|', '-', '-', '+', '+', '+', '+');
+	mvwprintw(win, r++, 2, "        -=-    Help    -=- ");
+	r++;
+	mvwprintw(win, r++, 2, "?          This window");
+	mvwprintw(win, r++, 2, "Arrows     Small scroll movement");
+	mvwprintw(win, r++, 2, "h,j,k,l    Small scroll movement");
+	mvwprintw(win, r++, 2, "H,J,K,L    Large scroll movement");
+	mvwprintw(win, r++, 2, "ctrl-H     Scroll 1k left");
+	mvwprintw(win, r++, 2, "ctrl-L     Scroll 1k right");
+	mvwprintw(win, r++, 2, "space      Scroll one screen");
+	mvwprintw(win, r++, 2, "backspace  Scroll back one screen");
+	mvwprintw(win, r++, 2, "g          Go to specific location");
+	mvwprintw(win, r++, 2, "m          Color for mapping qual");
+	mvwprintw(win, r++, 2, "n          Color for nucleotide");
+	mvwprintw(win, r++, 2, "b          Color for base quality");
+	mvwprintw(win, r++, 2, "c          Color for cs color");
+	mvwprintw(win, r++, 2, "z          Color for cs qual");
+	mvwprintw(win, r++, 2, ".          Toggle on/off dot view");
+	mvwprintw(win, r++, 2, "s          Toggle on/off ref skip");
+	mvwprintw(win, r++, 2, "r          Toggle on/off rd name");
+	mvwprintw(win, r++, 2, "N          Turn on nt view");
+	mvwprintw(win, r++, 2, "C          Turn on cs view");
+	mvwprintw(win, r++, 2, "i          Toggle on/off ins");
+	mvwprintw(win, r++, 2, "q          Exit");
+	r++;
+	mvwprintw(win, r++, 2, "Underline:      Secondary or orphan");
+	mvwprintw(win, r++, 2, "Blue:    0-9    Green: 10-19");
+	mvwprintw(win, r++, 2, "Yellow: 20-29   White: >=30");
+	wrefresh(win);
+	wgetch(win);
+}
+
+void tv_loop(tview_t *tv)
+{
+	int tid, pos;
+	tid = tv->curr_tid; pos = tv->left_pos;
+	while (1) {
+		int c = getch();
+		switch (c) {
+			case '?': tv_win_help(tv); break;
+			case '\033':
+			case 'q': goto end_loop;
+			case 'g': tv_win_goto(tv, &tid, &pos); break;
+			case 'm': tv->color_for = TV_COLOR_MAPQ; break;
+			case 'b': tv->color_for = TV_COLOR_BASEQ; break;
+			case 'n': tv->color_for = TV_COLOR_NUCL; break;
+			case 'c': tv->color_for = TV_COLOR_COL; break;
+			case 'z': tv->color_for = TV_COLOR_COLQ; break;
+			case 's': tv->no_skip = !tv->no_skip; break;
+			case 'r': tv->show_name = !tv->show_name; break;
+			case KEY_LEFT:
+			case 'h': --pos; break;
+			case KEY_RIGHT:
+			case 'l': ++pos; break;
+			case KEY_SLEFT:
+			case 'H': pos -= 20; break;
+			case KEY_SRIGHT:
+			case 'L': pos += 20; break;
+			case '.': tv->is_dot = !tv->is_dot; break;
+			case 'N': tv->base_for = TV_BASE_NUCL; break;
+			case 'C': tv->base_for = TV_BASE_COLOR_SPACE; break;
+			case 'i': tv->ins = !tv->ins; break;
+			case '\010': pos -= 1000; break;
+			case '\014': pos += 1000; break;
+			case ' ': pos += tv->mcol; break;
+			case KEY_UP:
+			case 'j': --tv->row_shift; break;
+			case KEY_DOWN:
+			case 'k': ++tv->row_shift; break;
+			case KEY_BACKSPACE:
+			case '\177': pos -= tv->mcol; break;
+			case KEY_RESIZE: getmaxyx(stdscr, tv->mrow, tv->mcol); break;
+			default: continue;
+		}
+		if (pos < 0) pos = 0;
+		if (tv->row_shift < 0) tv->row_shift = 0;
+		tv_draw_aln(tv, tid, pos);
+	}
+end_loop:
+	return;
+}
+
+int bam_tview_main(int argc, char *argv[])
+{
+	tview_t *tv;
+	if (argc == 1) {
+		fprintf(stderr, "Usage: bamtk tview <aln.bam> [ref.fasta]\n");
+		return 1;
+	}
+	tv = tv_init(argv[1], (argc == 2)? 0 : argv[2]);
+	tv_draw_aln(tv, 0, 0);
+	tv_loop(tv);
+	tv_destroy(tv);
+	return 0;
+}
+#else // #ifdef _HAVE_CURSES
+#include <stdio.h>
+#warning "No curses library is available; tview is disabled."
+int bam_tview_main(int argc, char *argv[])
+{
+	fprintf(stderr, "[bam_tview_main] The ncurses library is unavailable; tview is not compiled.\n");
+	return 1;
+}
+#endif // #ifdef _HAVE_CURSES
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bamtk.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bamtk.c
new file mode 100644
index 0000000..48ac76b
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bamtk.c
@@ -0,0 +1,128 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <assert.h>
+#include <fcntl.h>
+#include "bam.h"
+
+#ifdef _USE_KNETFILE
+#include "knetfile.h"
+#endif
+
+#ifndef PACKAGE_VERSION
+#define PACKAGE_VERSION "0.1.7 (r510)"
+#endif
+
+int bam_taf2baf(int argc, char *argv[]);
+int bam_pileup(int argc, char *argv[]);
+int bam_merge(int argc, char *argv[]);
+int bam_index(int argc, char *argv[]);
+int bam_sort(int argc, char *argv[]);
+int bam_tview_main(int argc, char *argv[]);
+int bam_mating(int argc, char *argv[]);
+int bam_rmdup(int argc, char *argv[]);
+int bam_flagstat(int argc, char *argv[]);
+int bam_fillmd(int argc, char *argv[]);
+
+int main_samview(int argc, char *argv[]);
+int main_import(int argc, char *argv[]);
+
+int faidx_main(int argc, char *argv[]);
+int glf3_view_main(int argc, char *argv[]);
+
+int bam_tagview(int argc, char *argv[])
+{
+	bamFile fp;
+	bam_header_t *header;
+	bam1_t *b;
+	char tag[2];
+	int ret;
+	if (argc < 3) {
+		fprintf(stderr, "Usage: samtools tagview <in.bam> <tag>\n");
+		return 1;
+	}
+	fp = strcmp(argv[1], "-")? bam_open(argv[1], "r") : bam_dopen(fileno(stdin), "r");
+	assert(fp);
+	header = bam_header_read(fp);
+	if (header == 0) {
+		fprintf(stderr, "[bam_view] fail to read the BAM header. Abort!\n");
+		return 1;
+	}
+	tag[0] = argv[2][0]; tag[1] = argv[2][1];
+	b = (bam1_t*)calloc(1, sizeof(bam1_t));
+	while ((ret = bam_read1(fp, b)) >= 0) {
+		uint8_t *d = bam_aux_get(b, tag);
+		if (d) {
+			printf("%s\t%d\t", bam1_qname(b), b->core.flag);
+			if (d[0] == 'Z' || d[0] == 'H') printf("%s\n", bam_aux2Z(d));
+			else if (d[0] == 'f') printf("%f\n", bam_aux2f(d));
+			else if (d[0] == 'd') printf("%lf\n", bam_aux2d(d));
+			else if (d[0] == 'A') printf("%c\n", bam_aux2A(d));
+			else if (d[0] == 'c' || d[0] == 's' || d[0] == 'i') printf("%d\n", bam_aux2i(d));
+			else if (d[0] == 'C' || d[0] == 'S' || d[0] == 'I') printf("%u\n", bam_aux2i(d));
+			else printf("\n");
+		}
+	}
+	if (ret < -1) fprintf(stderr, "[bam_view] truncated file? Continue anyway. (%d)\n", ret);
+	free(b->data); free(b);
+	bam_header_destroy(header);
+	bam_close(fp);
+	return 0;
+}
+
+static int usage()
+{
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Program: samtools (Tools for alignments in the SAM format)\n");
+	fprintf(stderr, "Version: %s\n\n", PACKAGE_VERSION);
+	fprintf(stderr, "Usage:   samtools <command> [options]\n\n");
+	fprintf(stderr, "Command: view        SAM<->BAM conversion\n");
+	fprintf(stderr, "         sort        sort alignment file\n");
+	fprintf(stderr, "         pileup      generate pileup output\n");
+	fprintf(stderr, "         faidx       index/extract FASTA\n");
+#if _CURSES_LIB != 0
+	fprintf(stderr, "         tview       text alignment viewer\n");
+#endif
+	fprintf(stderr, "         index       index alignment\n");
+	fprintf(stderr, "         fixmate     fix mate information\n");
+	fprintf(stderr, "         glfview     print GLFv3 file\n");
+	fprintf(stderr, "         flagstat    simple stats\n");
+	fprintf(stderr, "         calmd       recalculate MD/NM tags and '=' bases\n");
+	fprintf(stderr, "         merge       merge sorted alignments\n");
+	fprintf(stderr, "         rmdup       remove PCR duplicates\n");
+	fprintf(stderr, "\n");
+	return 1;
+}
+
+int main(int argc, char *argv[])
+{
+#ifdef _WIN32
+	setmode(fileno(stdout), O_BINARY);
+	setmode(fileno(stdin),  O_BINARY);
+#ifdef _USE_KNETFILE
+	knet_win32_init();
+#endif
+#endif
+	if (argc < 2) return usage();
+	if (strcmp(argv[1], "view") == 0) return main_samview(argc-1, argv+1);
+	else if (strcmp(argv[1], "import") == 0) return main_import(argc-1, argv+1);
+	else if (strcmp(argv[1], "pileup") == 0) return bam_pileup(argc-1, argv+1);
+	else if (strcmp(argv[1], "merge") == 0) return bam_merge(argc-1, argv+1);
+	else if (strcmp(argv[1], "sort") == 0) return bam_sort(argc-1, argv+1);
+	else if (strcmp(argv[1], "index") == 0) return bam_index(argc-1, argv+1);
+	else if (strcmp(argv[1], "faidx") == 0) return faidx_main(argc-1, argv+1);
+	else if (strcmp(argv[1], "fixmate") == 0) return bam_mating(argc-1, argv+1);
+	else if (strcmp(argv[1], "rmdup") == 0) return bam_rmdup(argc-1, argv+1);
+	else if (strcmp(argv[1], "glfview") == 0) return glf3_view_main(argc-1, argv+1);
+	else if (strcmp(argv[1], "flagstat") == 0) return bam_flagstat(argc-1, argv+1);
+	else if (strcmp(argv[1], "tagview") == 0) return bam_tagview(argc-1, argv+1);
+	else if (strcmp(argv[1], "calmd") == 0) return bam_fillmd(argc-1, argv+1);
+	else if (strcmp(argv[1], "fillmd") == 0) return bam_fillmd(argc-1, argv+1);
+#if _CURSES_LIB != 0
+	else if (strcmp(argv[1], "tview") == 0) return bam_tview_main(argc-1, argv+1);
+#endif
+	else {
+		fprintf(stderr, "[main] unrecognized command '%s'\n", argv[1]);
+		return 1;
+	}
+	return 0;	
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bgzf.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bgzf.c
new file mode 100644
index 0000000..59f902f
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bgzf.c
@@ -0,0 +1,683 @@
+/* The MIT License
+
+   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+*/
+
+/*
+  2009-06-29 by lh3: cache recent uncompressed blocks.
+  2009-06-25 by lh3: optionally use my knetfile library to access file on a FTP.
+  2009-06-12 by lh3: support a mode string like "wu" where 'u' for uncompressed output */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "bgzf.h"
+
+#include "khash.h"
+typedef struct {
+	int size;
+	uint8_t *block;
+	int64_t end_offset;
+} cache_t;
+KHASH_MAP_INIT_INT64(cache, cache_t)
+
+#if defined(_WIN32) || defined(_MSC_VER)
+#define ftello(fp) ftell(fp)
+#define fseeko(fp, offset, whence) fseek(fp, offset, whence)
+#else
+extern off_t ftello(FILE *stream);
+extern int fseeko(FILE *stream, off_t offset, int whence);
+#endif
+
+typedef int8_t bgzf_byte_t;
+
+static const int DEFAULT_BLOCK_SIZE = 64 * 1024;
+static const int MAX_BLOCK_SIZE = 64 * 1024;
+
+static const int BLOCK_HEADER_LENGTH = 18;
+static const int BLOCK_FOOTER_LENGTH = 8;
+
+static const int GZIP_ID1 = 31;
+static const int GZIP_ID2 = 139;
+static const int CM_DEFLATE = 8;
+static const int FLG_FEXTRA = 4;
+static const int OS_UNKNOWN = 255;
+static const int BGZF_ID1 = 66; // 'B'
+static const int BGZF_ID2 = 67; // 'C'
+static const int BGZF_LEN = 2;
+static const int BGZF_XLEN = 6; // BGZF_LEN+4
+
+static const int GZIP_WINDOW_BITS = -15; // no zlib header
+static const int Z_DEFAULT_MEM_LEVEL = 8;
+
+
+inline
+void
+packInt16(uint8_t* buffer, uint16_t value)
+{
+    buffer[0] = value;
+    buffer[1] = value >> 8;
+}
+
+inline
+int
+unpackInt16(const uint8_t* buffer)
+{
+    return (buffer[0] | (buffer[1] << 8));
+}
+
+inline
+void
+packInt32(uint8_t* buffer, uint32_t value)
+{
+    buffer[0] = value;
+    buffer[1] = value >> 8;
+    buffer[2] = value >> 16;
+    buffer[3] = value >> 24;
+}
+
+static inline
+int
+bgzf_min(int x, int y)
+{
+    return (x < y) ? x : y;
+}
+
+static
+void
+report_error(BGZF* fp, const char* message) {
+    fp->error = message;
+}
+
+static BGZF *bgzf_read_init()
+{
+	BGZF *fp;
+	fp = calloc(1, sizeof(BGZF));
+    fp->uncompressed_block_size = MAX_BLOCK_SIZE;
+    fp->uncompressed_block = malloc(MAX_BLOCK_SIZE);
+    fp->compressed_block_size = MAX_BLOCK_SIZE;
+    fp->compressed_block = malloc(MAX_BLOCK_SIZE);
+	fp->cache_size = 0;
+	fp->cache = kh_init(cache);
+	return fp;
+}
+
+static
+BGZF*
+open_read(int fd)
+{
+#ifdef _USE_KNETFILE
+    knetFile *file = knet_dopen(fd, "r");
+#else
+    FILE* file = fdopen(fd, "r");
+#endif
+    BGZF* fp;
+	if (file == 0) return 0;
+	fp = bgzf_read_init();
+    fp->file_descriptor = fd;
+    fp->open_mode = 'r';
+#ifdef _USE_KNETFILE
+    fp->x.fpr = file;
+#else
+    fp->file = file;
+#endif
+    return fp;
+}
+
+static
+BGZF*
+open_write(int fd, bool is_uncompressed)
+{
+    FILE* file = fdopen(fd, "w");
+    BGZF* fp;
+	if (file == 0) return 0;
+	fp = malloc(sizeof(BGZF));
+    fp->file_descriptor = fd;
+    fp->open_mode = 'w';
+    fp->owned_file = 0; fp->is_uncompressed = is_uncompressed;
+#ifdef _USE_KNETFILE
+    fp->x.fpw = file;
+#else
+    fp->file = file;
+#endif
+    fp->uncompressed_block_size = DEFAULT_BLOCK_SIZE;
+    fp->uncompressed_block = NULL;
+    fp->compressed_block_size = MAX_BLOCK_SIZE;
+    fp->compressed_block = malloc(MAX_BLOCK_SIZE);
+    fp->block_address = 0;
+    fp->block_offset = 0;
+    fp->block_length = 0;
+    fp->error = NULL;
+    return fp;
+}
+
+BGZF*
+bgzf_open(const char* __restrict path, const char* __restrict mode)
+{
+    BGZF* fp = NULL;
+    if (mode[0] == 'r' || mode[0] == 'R') { /* The reading mode is preferred. */
+#ifdef _USE_KNETFILE
+		knetFile *file = knet_open(path, mode);
+		if (file == 0) return 0;
+		fp = bgzf_read_init();
+		fp->file_descriptor = -1;
+		fp->open_mode = 'r';
+		fp->x.fpr = file;
+#else
+		int fd, oflag = O_RDONLY;
+#ifdef _WIN32
+		oflag |= O_BINARY;
+#endif
+		fd = open(path, oflag);
+		if (fd == -1) return 0;
+        fp = open_read(fd);
+#endif
+    } else if (mode[0] == 'w' || mode[0] == 'W') {
+		int fd, oflag = O_WRONLY | O_CREAT | O_TRUNC;
+#ifdef _WIN32
+		oflag |= O_BINARY;
+#endif
+		fd = open(path, oflag, 0666);
+		if (fd == -1) return 0;
+        fp = open_write(fd, strstr(mode, "u")? 1 : 0);
+    }
+    if (fp != NULL) {
+        fp->owned_file = 1;
+    }
+    return fp;
+}
+
+BGZF*
+bgzf_fdopen(int fd, const char * __restrict mode)
+{
+	if (fd == -1) return 0;
+    if (mode[0] == 'r' || mode[0] == 'R') {
+        return open_read(fd);
+    } else if (mode[0] == 'w' || mode[0] == 'W') {
+        return open_write(fd, strstr(mode, "u")? 1 : 0);
+    } else {
+        return NULL;
+    }
+}
+
+static
+int
+deflate_block(BGZF* fp, int block_length)
+{
+    // Deflate the block in fp->uncompressed_block into fp->compressed_block.
+    // Also adds an extra field that stores the compressed block length.
+
+    bgzf_byte_t* buffer = fp->compressed_block;
+    int buffer_size = fp->compressed_block_size;
+
+    // Init gzip header
+    buffer[0] = GZIP_ID1;
+    buffer[1] = GZIP_ID2;
+    buffer[2] = CM_DEFLATE;
+    buffer[3] = FLG_FEXTRA;
+    buffer[4] = 0; // mtime
+    buffer[5] = 0;
+    buffer[6] = 0;
+    buffer[7] = 0;
+    buffer[8] = 0;
+    buffer[9] = OS_UNKNOWN;
+    buffer[10] = BGZF_XLEN;
+    buffer[11] = 0;
+    buffer[12] = BGZF_ID1;
+    buffer[13] = BGZF_ID2;
+    buffer[14] = BGZF_LEN;
+    buffer[15] = 0;
+    buffer[16] = 0; // placeholder for block length
+    buffer[17] = 0;
+
+    // loop to retry for blocks that do not compress enough
+    int input_length = block_length;
+    int compressed_length = 0;
+    while (1) {
+		int compress_level = fp->is_uncompressed? 0 : Z_DEFAULT_COMPRESSION;
+        z_stream zs;
+        zs.zalloc = NULL;
+        zs.zfree = NULL;
+        zs.next_in = fp->uncompressed_block;
+        zs.avail_in = input_length;
+        zs.next_out = (void*)&buffer[BLOCK_HEADER_LENGTH];
+        zs.avail_out = buffer_size - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;
+
+        int status = deflateInit2(&zs, compress_level, Z_DEFLATED,
+                                  GZIP_WINDOW_BITS, Z_DEFAULT_MEM_LEVEL, Z_DEFAULT_STRATEGY);
+        if (status != Z_OK) {
+            report_error(fp, "deflate init failed");
+            return -1;
+        }
+        status = deflate(&zs, Z_FINISH);
+        if (status != Z_STREAM_END) {
+            deflateEnd(&zs);
+            if (status == Z_OK) {
+                // Not enough space in buffer.
+                // Can happen in the rare case the input doesn't compress enough.
+                // Reduce the amount of input until it fits.
+                input_length -= 1024;
+                if (input_length <= 0) {
+                    // should never happen
+                    report_error(fp, "input reduction failed");
+                    return -1;
+                }
+                continue;
+            }
+            report_error(fp, "deflate failed");
+            return -1;
+        }
+        status = deflateEnd(&zs);
+        if (status != Z_OK) {
+            report_error(fp, "deflate end failed");
+            return -1;
+        }
+        compressed_length = zs.total_out;
+        compressed_length += BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
+        if (compressed_length > MAX_BLOCK_SIZE) {
+            // should never happen
+            report_error(fp, "deflate overflow");
+            return -1;
+        }
+        break;
+    }
+
+    packInt16((uint8_t*)&buffer[16], compressed_length-1);
+    uint32_t crc = crc32(0L, NULL, 0L);
+    crc = crc32(crc, fp->uncompressed_block, input_length);
+    packInt32((uint8_t*)&buffer[compressed_length-8], crc);
+    packInt32((uint8_t*)&buffer[compressed_length-4], input_length);
+
+    int remaining = block_length - input_length;
+    if (remaining > 0) {
+        if (remaining > input_length) {
+            // should never happen (check so we can use memcpy)
+            report_error(fp, "remainder too large");
+            return -1;
+        }
+        memcpy(fp->uncompressed_block,
+               fp->uncompressed_block + input_length,
+               remaining);
+    }
+    fp->block_offset = remaining;
+    return compressed_length;
+}
+
+static
+int
+inflate_block(BGZF* fp, int block_length)
+{
+    // Inflate the block in fp->compressed_block into fp->uncompressed_block
+
+    z_stream zs;
+    zs.zalloc = NULL;
+    zs.zfree = NULL;
+    zs.next_in = fp->compressed_block + 18;
+    zs.avail_in = block_length - 16;
+    zs.next_out = fp->uncompressed_block;
+    zs.avail_out = fp->uncompressed_block_size;
+
+    int status = inflateInit2(&zs, GZIP_WINDOW_BITS);
+    if (status != Z_OK) {
+        report_error(fp, "inflate init failed");
+        return -1;
+    }
+    status = inflate(&zs, Z_FINISH);
+    if (status != Z_STREAM_END) {
+        inflateEnd(&zs);
+        report_error(fp, "inflate failed");
+        return -1;
+    }
+    status = inflateEnd(&zs);
+    if (status != Z_OK) {
+        report_error(fp, "inflate failed");
+        return -1;
+    }
+    return zs.total_out;
+}
+
+static
+int
+check_header(const bgzf_byte_t* header)
+{
+    return (header[0] == GZIP_ID1 &&
+            header[1] == (bgzf_byte_t) GZIP_ID2 &&
+            header[2] == Z_DEFLATED &&
+            (header[3] & FLG_FEXTRA) != 0 &&
+            unpackInt16((uint8_t*)&header[10]) == BGZF_XLEN &&
+            header[12] == BGZF_ID1 &&
+            header[13] == BGZF_ID2 &&
+            unpackInt16((uint8_t*)&header[14]) == BGZF_LEN);
+}
+
+static void free_cache(BGZF *fp)
+{
+	khint_t k;
+	khash_t(cache) *h = (khash_t(cache)*)fp->cache;
+	if (fp->open_mode != 'r') return;
+	for (k = kh_begin(h); k < kh_end(h); ++k)
+		if (kh_exist(h, k)) free(kh_val(h, k).block);
+	kh_destroy(cache, h);
+}
+
+static int load_block_from_cache(BGZF *fp, int64_t block_address)
+{
+	khint_t k;
+	cache_t *p;
+	khash_t(cache) *h = (khash_t(cache)*)fp->cache;
+	k = kh_get(cache, h, block_address);
+	if (k == kh_end(h)) return 0;
+	p = &kh_val(h, k);
+	if (fp->block_length != 0) fp->block_offset = 0;
+	fp->block_address = block_address;
+	fp->block_length = p->size;
+	memcpy(fp->uncompressed_block, p->block, MAX_BLOCK_SIZE);
+#ifdef _USE_KNETFILE
+	knet_seek(fp->x.fpr, p->end_offset, SEEK_SET);
+#else
+	fseeko(fp->file, p->end_offset, SEEK_SET);
+#endif
+	return p->size;
+}
+
+static void cache_block(BGZF *fp, int size)
+{
+	int ret;
+	khint_t k;
+	cache_t *p;
+	khash_t(cache) *h = (khash_t(cache)*)fp->cache;
+	if (MAX_BLOCK_SIZE >= fp->cache_size) return;
+	if ((kh_size(h) + 1) * MAX_BLOCK_SIZE > fp->cache_size) {
+		/* A better way would be to remove the oldest block in the
+		 * cache, but here we remove a random one for simplicity. This
+		 * should not have a big impact on performance. */
+		for (k = kh_begin(h); k < kh_end(h); ++k)
+			if (kh_exist(h, k)) break;
+		if (k < kh_end(h)) {
+			free(kh_val(h, k).block);
+			kh_del(cache, h, k);
+		}
+	}
+	k = kh_put(cache, h, fp->block_address, &ret);
+	if (ret == 0) return; // if this happens, a bug!
+	p = &kh_val(h, k);
+	p->size = fp->block_length;
+	p->end_offset = fp->block_address + size;
+	p->block = malloc(MAX_BLOCK_SIZE);
+	memcpy(kh_val(h, k).block, fp->uncompressed_block, MAX_BLOCK_SIZE);
+}
+
+static
+int
+read_block(BGZF* fp)
+{
+    bgzf_byte_t header[BLOCK_HEADER_LENGTH];
+	int size = 0;
+#ifdef _USE_KNETFILE
+    int64_t block_address = knet_tell(fp->x.fpr);
+	if (load_block_from_cache(fp, block_address)) return 0;
+    int count = knet_read(fp->x.fpr, header, sizeof(header));
+#else
+    int64_t block_address = ftello(fp->file);
+	if (load_block_from_cache(fp, block_address)) return 0;
+    int count = fread(header, 1, sizeof(header), fp->file);
+#endif
+    if (count == 0) {
+        fp->block_length = 0;
+        return 0;
+    }
+	size = count;
+    if (count != sizeof(header)) {
+        report_error(fp, "read failed");
+        return -1;
+    }
+    if (!check_header(header)) {
+        report_error(fp, "invalid block header");
+        return -1;
+    }
+    int block_length = unpackInt16((uint8_t*)&header[16]) + 1;
+    bgzf_byte_t* compressed_block = (bgzf_byte_t*) fp->compressed_block;
+    memcpy(compressed_block, header, BLOCK_HEADER_LENGTH);
+    int remaining = block_length - BLOCK_HEADER_LENGTH;
+#ifdef _USE_KNETFILE
+    count = knet_read(fp->x.fpr, &compressed_block[BLOCK_HEADER_LENGTH], remaining);
+#else
+    count = fread(&compressed_block[BLOCK_HEADER_LENGTH], 1, remaining, fp->file);
+#endif
+    if (count != remaining) {
+        report_error(fp, "read failed");
+        return -1;
+    }
+	size += count;
+    count = inflate_block(fp, block_length);
+    if (count < 0) {
+        return -1;
+    }
+    if (fp->block_length != 0) {
+        // Do not reset offset if this read follows a seek.
+        fp->block_offset = 0;
+    }
+    fp->block_address = block_address;
+    fp->block_length = count;
+	cache_block(fp, size);
+    return 0;
+}
+
+int
+bgzf_read(BGZF* fp, void* data, int length)
+{
+    if (length <= 0) {
+        return 0;
+    }
+    if (fp->open_mode != 'r') {
+        report_error(fp, "file not open for reading");
+        return -1;
+    }
+
+    int bytes_read = 0;
+    bgzf_byte_t* output = data;
+    while (bytes_read < length) {
+        int available = fp->block_length - fp->block_offset;
+        if (available <= 0) {
+            if (read_block(fp) != 0) {
+                return -1;
+            }
+            available = fp->block_length - fp->block_offset;
+            if (available <= 0) {
+                break;
+            }
+        }
+        int copy_length = bgzf_min(length-bytes_read, available);
+        bgzf_byte_t* buffer = fp->uncompressed_block;
+        memcpy(output, buffer + fp->block_offset, copy_length);
+        fp->block_offset += copy_length;
+        output += copy_length;
+        bytes_read += copy_length;
+    }
+    if (fp->block_offset == fp->block_length) {
+#ifdef _USE_KNETFILE
+        fp->block_address = knet_tell(fp->x.fpr);
+#else
+        fp->block_address = ftello(fp->file);
+#endif
+        fp->block_offset = 0;
+        fp->block_length = 0;
+    }
+    return bytes_read;
+}
+
+static
+int
+flush_block(BGZF* fp)
+{
+    while (fp->block_offset > 0) {
+        int block_length = deflate_block(fp, fp->block_offset);
+        if (block_length < 0) {
+            return -1;
+        }
+#ifdef _USE_KNETFILE
+        int count = fwrite(fp->compressed_block, 1, block_length, fp->x.fpw);
+#else
+        int count = fwrite(fp->compressed_block, 1, block_length, fp->file);
+#endif
+        if (count != block_length) {
+            report_error(fp, "write failed");
+            return -1;
+        }
+        fp->block_address += block_length;
+    }
+    return 0;
+}
+
+int
+bgzf_write(BGZF* fp, const void* data, int length)
+{
+    if (fp->open_mode != 'w') {
+        report_error(fp, "file not open for writing");
+        return -1;
+    }
+
+    if (fp->uncompressed_block == NULL) {
+        fp->uncompressed_block = malloc(fp->uncompressed_block_size);
+    }
+
+    const bgzf_byte_t* input = data;
+    int block_length = fp->uncompressed_block_size;
+    int bytes_written = 0;
+    while (bytes_written < length) {
+        int copy_length = bgzf_min(block_length - fp->block_offset, length - bytes_written);
+        bgzf_byte_t* buffer = fp->uncompressed_block;
+        memcpy(buffer + fp->block_offset, input, copy_length);
+        fp->block_offset += copy_length;
+        input += copy_length;
+        bytes_written += copy_length;
+        if (fp->block_offset == block_length) {
+            if (flush_block(fp) != 0) {
+                break;
+            }
+        }
+    }
+    return bytes_written;
+}
+
+int
+bgzf_close(BGZF* fp)
+{
+    if (fp->open_mode == 'w') {
+        if (flush_block(fp) != 0) {
+            return -1;
+        }
+		{ // add an empty block
+			int count, block_length = deflate_block(fp, 0);
+#ifdef _USE_KNETFILE
+			count = fwrite(fp->compressed_block, 1, block_length, fp->x.fpw);
+#else
+			count = fwrite(fp->compressed_block, 1, block_length, fp->file);
+#endif
+		}
+#ifdef _USE_KNETFILE
+        if (fflush(fp->x.fpw) != 0) {
+#else
+        if (fflush(fp->file) != 0) {
+#endif
+            report_error(fp, "flush failed");
+            return -1;
+        }
+    }
+    if (fp->owned_file) {
+#ifdef _USE_KNETFILE
+		int ret;
+		if (fp->open_mode == 'w') ret = fclose(fp->x.fpw);
+		else ret = knet_close(fp->x.fpr);
+        if (ret != 0) return -1;
+#else
+        if (fclose(fp->file) != 0) {
+            return -1;
+        }
+#endif
+    }
+    free(fp->uncompressed_block);
+    free(fp->compressed_block);
+	free_cache(fp);
+    free(fp);
+    return 0;
+}
+
+int64_t
+bgzf_tell(BGZF* fp)
+{
+    return ((fp->block_address << 16) | (fp->block_offset & 0xFFFF));
+}
+
+void bgzf_set_cache_size(BGZF *fp, int cache_size)
+{
+	if (fp) fp->cache_size = cache_size;
+}
+
+int bgzf_check_EOF(BGZF *fp)
+{
+	static uint8_t magic[28] = "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\033\0\3\0\0\0\0\0\0\0\0\0";
+	uint8_t buf[28];
+	off_t offset;
+#ifdef _USE_KNETFILE
+	offset = knet_tell(fp->x.fpr);
+	if (knet_seek(fp->x.fpr, -28, SEEK_END) != 0) return -1;
+	knet_read(fp->x.fpr, buf, 28);
+	knet_seek(fp->x.fpr, offset, SEEK_SET);
+#else
+	offset = ftello(fp->file);
+	if (fseeko(fp->file, -28, SEEK_END) != 0) return -1;
+	fread(buf, 1, 28, fp->file);
+	fseeko(fp->file, offset, SEEK_SET);
+#endif
+	return (memcmp(magic, buf, 28) == 0)? 1 : 0;
+}
+
+int64_t
+bgzf_seek(BGZF* fp, int64_t pos, int where)
+{
+    if (fp->open_mode != 'r') {
+        report_error(fp, "file not open for read");
+        return -1;
+    }
+    if (where != SEEK_SET) {
+        report_error(fp, "unimplemented seek option");
+        return -1;
+    }
+    int block_offset = pos & 0xFFFF;
+    int64_t block_address = (pos >> 16) & 0xFFFFFFFFFFFFLL;
+#ifdef _USE_KNETFILE
+    if (knet_seek(fp->x.fpr, block_address, SEEK_SET) != 0) {
+#else
+    if (fseeko(fp->file, block_address, SEEK_SET) != 0) {
+#endif
+        report_error(fp, "seek failed");
+        return -1;
+    }
+    fp->block_length = 0;  // indicates current block is not loaded
+    fp->block_address = block_address;
+    fp->block_offset = block_offset;
+    return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bgzf.h b/ext/samtools-0.1.7a_getUnique-0.1.3/bgzf.h
new file mode 100644
index 0000000..91b3317
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bgzf.h
@@ -0,0 +1,134 @@
+/* The MIT License
+
+   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+*/
+
+#ifndef __BGZF_H
+#define __BGZF_H
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <zlib.h>
+#ifdef _USE_KNETFILE
+#include "knetfile.h"
+#endif
+
+//typedef int8_t bool;
+
+typedef struct {
+    int file_descriptor;
+    char open_mode;  // 'r' or 'w'
+    bool owned_file, is_uncompressed;
+#ifdef _USE_KNETFILE
+	union {
+		knetFile *fpr;
+		FILE *fpw;
+	} x;
+#else
+    FILE* file;
+#endif
+    int uncompressed_block_size;
+    int compressed_block_size;
+    void* uncompressed_block;
+    void* compressed_block;
+    int64_t block_address;
+    int block_length;
+    int block_offset;
+	int cache_size;
+    const char* error;
+	void *cache; // a pointer to a hash table
+} BGZF;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Open an existing file descriptor for reading or writing.
+ * Mode must be either "r" or "w".
+ * A subsequent bgzf_close will not close the file descriptor.
+ * Returns null on error.
+ */
+BGZF* bgzf_fdopen(int fd, const char* __restrict mode);
+
+/*
+ * Open the specified file for reading or writing.
+ * Mode must be either "r" or "w".
+ * Returns null on error.
+ */
+BGZF* bgzf_open(const char* path, const char* __restrict mode);
+
+/*
+ * Close the BGZ file and free all associated resources.
+ * Does not close the underlying file descriptor if created with bgzf_fdopen.
+ * Returns zero on success, -1 on error.
+ */
+int bgzf_close(BGZF* fp);
+
+/*
+ * Read up to length bytes from the file storing into data.
+ * Returns the number of bytes actually read.
+ * Returns zero on end of file.
+ * Returns -1 on error.
+ */
+int bgzf_read(BGZF* fp, void* data, int length);
+
+/*
+ * Write length bytes from data to the file.
+ * Returns the number of bytes written.
+ * Returns -1 on error.
+ */
+int bgzf_write(BGZF* fp, const void* data, int length);
+
+/*
+ * Return a virtual file pointer to the current location in the file.
+ * No interpetation of the value should be made, other than a subsequent
+ * call to bgzf_seek can be used to position the file at the same point.
+ * Return value is non-negative on success.
+ * Returns -1 on error.
+ */
+int64_t bgzf_tell(BGZF* fp);
+
+/*
+ * Set the file to read from the location specified by pos, which must
+ * be a value previously returned by bgzf_tell for this file (but not
+ * necessarily one returned by this file handle).
+ * The where argument must be SEEK_SET.
+ * Seeking on a file opened for write is not supported.
+ * Returns zero on success, -1 on error.
+ */
+int64_t bgzf_seek(BGZF* fp, int64_t pos, int where);
+
+/*
+ * Set the cache size. Zero to disable. By default, caching is
+ * disabled. The recommended cache size for frequent random access is
+ * about 8M bytes.
+ */
+void bgzf_set_cache_size(BGZF *fp, int cache_size);
+
+int bgzf_check_EOF(BGZF *fp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/bgzip.c b/ext/samtools-0.1.7a_getUnique-0.1.3/bgzip.c
new file mode 100644
index 0000000..ac2a98e
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/bgzip.c
@@ -0,0 +1,179 @@
+/* The MIT License
+
+   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include "bgzf.h"
+
+static const int WINDOW_SIZE = 64 * 1024;
+
+static int bgzip_main_usage()
+{
+	printf("\n");
+	printf("Usage:   bgzip [options] [file] ...\n\n");
+	printf("Options: -c      write on standard output, keep original files unchanged\n");
+	printf("         -d      decompress\n");
+	// printf("         -l      list compressed file contents\n");
+	printf("         -b INT  decompress at virtual file pointer INT\n");
+	printf("         -s INT  decompress INT bytes in the uncompressed file\n");
+	printf("         -h      give this help\n");
+	printf("\n");
+	return 0;
+}
+
+static int write_open(const char *fn, int is_forced)
+{
+	int fd = -1;
+	char c;
+	if (!is_forced) {
+		if ((fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0666)) < 0 && errno == EEXIST) {
+			printf("bgzip: %s already exists; do you wish to overwrite (y or n)? ", fn);
+			scanf("%c", &c);
+			if (c != 'Y' && c != 'y') {
+				printf("bgzip: not overwritten\n");
+				exit(1);
+			}
+		}
+	}
+	if (fd < 0) {
+		if ((fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, 0666)) < 0) {
+			fprintf(stderr, "bgzip: %s: Fail to write\n", fn);
+			exit(1);
+		}
+	}
+	return fd;
+}
+
+static
+void
+fail(BGZF* fp)
+{
+    printf("Error: %s\n", fp->error);
+    exit(1);
+}
+
+int main(int argc, char **argv)
+{
+	int c, compress, pstdout, is_forced;
+	BGZF *rz;
+	void *buffer;
+	long start, end, size;
+
+	compress = 1; pstdout = 0; start = 0; size = -1; end = -1; is_forced = 0;
+	while((c  = getopt(argc, argv, "cdlhfb:s:")) >= 0){
+		switch(c){
+		case 'h': return bgzip_main_usage();
+		case 'd': compress = 0; break;
+		case 'c': pstdout = 1; break;
+                // case 'l': compress = 2; break;
+		case 'b': start = atol(optarg); break;
+		case 's': size = atol(optarg); break;
+		case 'f': is_forced = 1; break;
+		}
+	}
+	if (size >= 0) end = start + size;
+	if(end >= 0 && end < start){
+		fprintf(stderr, " -- Illegal region: [%ld, %ld] --\n", start, end);
+		return 1;
+	}
+	if(compress == 1){
+		int f_src, f_dst = -1;
+		if(argc > optind){
+			if((f_src = open(argv[optind], O_RDONLY)) < 0){
+				fprintf(stderr, " -- Cannot open file: %s --\n", argv[optind]);
+				return 1;
+			}
+			if(pstdout){
+				f_dst = fileno(stdout);
+			} else {
+				char *name = malloc(sizeof(strlen(argv[optind]) + 5));
+				strcpy(name, argv[optind]);
+				strcat(name, ".gz");
+				f_dst = write_open(name, is_forced);
+				if (f_dst < 0) return 1;
+				free(name);
+			}
+		} else if(pstdout){ 
+			f_src = fileno(stdin);
+			f_dst = fileno(stdout);
+		} else return bgzip_main_usage();
+		rz = bgzf_fdopen(f_dst, "w");
+		buffer = malloc(WINDOW_SIZE);
+		while((c = read(f_src, buffer, WINDOW_SIZE)) > 0) {
+                  if (bgzf_write(rz, buffer, c) < 0) {
+                    fail(rz);
+                  }
+                }
+                // f_dst will be closed here
+		if (bgzf_close(rz) < 0) {
+                  fail(rz);
+                }
+		if (argc > optind) unlink(argv[optind]);
+		free(buffer);
+		close(f_src);
+		return 0;
+	} else {
+		if(argc <= optind) return bgzip_main_usage();
+                int f_dst;
+                if (argc > optind && !pstdout) {
+                  char *name;
+                  if (strstr(argv[optind], ".gz") - argv[optind] != strlen(argv[optind]) - 3) {
+                    printf("bgzip: %s: unknown suffix -- ignored\n", argv[optind]);
+                    return 1;
+                  }
+                  name = strdup(argv[optind]);
+                  name[strlen(name) - 3] = '\0';
+                  f_dst = write_open(name, is_forced);
+                  free(name);
+                } else f_dst = fileno(stdout);
+                rz = bgzf_open(argv[optind], "r");
+                if (rz == NULL) {
+                  printf("Could not open file: %s\n", argv[optind]);
+                  return 1;
+                }
+                buffer = malloc(WINDOW_SIZE);
+                if (bgzf_seek(rz, start, SEEK_SET) < 0) {
+                  fail(rz);
+                }
+                while(1){
+                  if(end < 0) c = bgzf_read(rz, buffer, WINDOW_SIZE);
+                  else c = bgzf_read(rz, buffer, (end - start > WINDOW_SIZE)? WINDOW_SIZE:(end - start));
+                  if(c == 0) break;
+                  if (c < 0) fail(rz);
+                  start += c;
+                  write(f_dst, buffer, c);
+                  if(end >= 0 && start >= end) break;
+                }
+                free(buffer);
+		if (bgzf_close(rz) < 0) {
+                  fail(rz);
+                }
+                if (!pstdout) unlink(argv[optind]);
+		return 0;
+	}
+}
+
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/examples/00README.txt b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/00README.txt
new file mode 100644
index 0000000..dbb276f
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/00README.txt
@@ -0,0 +1,23 @@
+File ex1.fa contains two sequences cut from the human genome
+build36. They were exatracted with command:
+
+  samtools faidx human_b36.fa 2:2043966-2045540 20:67967-69550
+
+Sequence names were changed manually for simplicity. File ex1.sam.gz
+contains MAQ alignments exatracted with:
+
+  (samtools view NA18507_maq.bam 2:2044001-2045500;
+   samtools view NA18507_maq.bam 20:68001-69500)
+
+and processed with `samtools fixmate' to make it self-consistent as a
+standalone alignment.
+
+To try samtools, you may run the following commands:
+
+  samtools faidx ex1.fa                 # index the reference FASTA
+  samtools import ex1.fa.fai ex1.sam.gz ex1.bam   # SAM->BAM
+  samtools index ex1.bam                # index BAM
+  samtools tview ex1.bam ex1.fa         # view alignment
+  samtools pileup -cf ex1.fa ex1.bam    # pileup and consensus
+  samtools pileup -cf ex1.fa -t ex1.fa.fai ex1.sam.gz
+
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/examples/Makefile b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/Makefile
new file mode 100644
index 0000000..8f0386f
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/Makefile
@@ -0,0 +1,39 @@
+all:../libbam.a ../samtools ex1.glf ex1.pileup.gz ex1.bam.bai ex1f-rmduppe.bam ex1f-rmdupse.bam ex1.glfview.gz calDepth
+		@echo; echo \# You can now launch the viewer with: \'samtools tview ex1.bam ex1.fa\'; echo;
+
+ex1.fa.fai:ex1.fa
+		../samtools faidx ex1.fa
+ex1.bam:ex1.sam.gz ex1.fa.fai
+		../samtools import ex1.fa.fai ex1.sam.gz ex1.bam
+ex1.bam.bai:ex1.bam
+		../samtools index ex1.bam
+ex1.pileup.gz:ex1.bam ex1.fa
+		../samtools pileup -cf ex1.fa ex1.bam | gzip > ex1.pileup.gz
+ex1.glf:ex1.bam ex1.fa
+		../samtools pileup -gf ex1.fa ex1.bam > ex1.glf
+ex1.glfview.gz:ex1.glf
+		../samtools glfview ex1.glf | gzip > ex1.glfview.gz
+ex1a.bam:ex1.bam
+		../samtools view -h ex1.bam | awk 'BEGIN{FS=OFS="\t"}{if(/^@/)print;else{$$1=$$1"a";print}}' | ../samtools view -bS - > $@
+ex1b.bam:ex1.bam
+		../samtools view -h ex1.bam | awk 'BEGIN{FS=OFS="\t"}{if(/^@/)print;else{$$1=$$1"b";print}}' | ../samtools view -bS - > $@
+ex1f.rg:
+		(echo "@RG	ID:ex1	LB:ex1"; echo "@RG	ID:ex1a	LB:ex1"; echo "@RG	ID:ex1b	LB:ex1b") > $@
+ex1f.bam:ex1.bam ex1a.bam ex1b.bam ex1f.rg
+		../samtools merge -rh ex1f.rg $@ ex1.bam ex1a.bam ex1b.bam
+ex1f-rmduppe.bam:ex1f.bam
+		../samtools rmdup ex1f.bam $@
+ex1f-rmdupse.bam:ex1f.bam
+		../samtools rmdup -S ex1f.bam $@
+
+../samtools:
+		(cd ..; make samtools)
+
+../libbam.a:
+		(cd ..; make libbam.a)
+
+calDepth:../libbam.a calDepth.c
+		gcc -g -Wall -O2 -I.. calDepth.c -o $@ -lm -lz -L.. -lbam
+
+clean:
+		rm -fr *.bam *.bai *.glf* *.fai *.pileup* *~ calDepth *.dSYM ex1*.rg
\ No newline at end of file
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/examples/calDepth.c b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/calDepth.c
new file mode 100644
index 0000000..7a3239c
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/calDepth.c
@@ -0,0 +1,62 @@
+#include <stdio.h>
+#include "sam.h"
+
+typedef struct {
+	int beg, end;
+	samfile_t *in;
+} tmpstruct_t;
+
+// callback for bam_fetch()
+static int fetch_func(const bam1_t *b, void *data)
+{
+	bam_plbuf_t *buf = (bam_plbuf_t*)data;
+	bam_plbuf_push(b, buf);
+	return 0;
+}
+// callback for bam_plbuf_init()
+static int pileup_func(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data)
+{
+	tmpstruct_t *tmp = (tmpstruct_t*)data;
+	if ((int)pos >= tmp->beg && (int)pos < tmp->end)
+		printf("%s\t%d\t%d\n", tmp->in->header->target_name[tid], pos + 1, n);
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	tmpstruct_t tmp;
+	if (argc == 1) {
+		fprintf(stderr, "Usage: calDepth <in.bam> [region]\n");
+		return 1;
+	}
+	tmp.beg = 0; tmp.end = 0x7fffffff;
+	tmp.in = samopen(argv[1], "rb", 0);
+	if (tmp.in == 0) {
+		fprintf(stderr, "Fail to open BAM file %s\n", argv[1]);
+		return 1;
+	}
+	if (argc == 2) { // if a region is not specified
+		sampileup(tmp.in, -1, pileup_func, &tmp);
+	} else {
+		int ref;
+		bam_index_t *idx;
+		bam_plbuf_t *buf;
+		idx = bam_index_load(argv[1]); // load BAM index
+		if (idx == 0) {
+			fprintf(stderr, "BAM indexing file is not available.\n");
+			return 1;
+		}
+		bam_parse_region(tmp.in->header, argv[2], &ref, &tmp.beg, &tmp.end); // parse the region
+		if (ref < 0) {
+			fprintf(stderr, "Invalid region %s\n", argv[2]);
+			return 1;
+		}
+		buf = bam_plbuf_init(pileup_func, &tmp); // initialize pileup
+		bam_fetch(tmp.in->x.bam, idx, ref, tmp.beg, tmp.end, buf, fetch_func);
+		bam_plbuf_push(0, buf); // finalize pileup
+		bam_index_destroy(idx);
+		bam_plbuf_destroy(buf);
+	}
+	samclose(tmp.in);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/examples/ex1.fa b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/ex1.fa
new file mode 100644
index 0000000..ef611b4
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/ex1.fa
@@ -0,0 +1,56 @@
+>seq1
+CACTAGTGGCTCATTGTAAATGTGTGGTTTAACTCGTCCATGGCCCAGCATTAGGGAGCT
+GTGGACCCTGCAGCCTGGCTGTGGGGGCCGCAGTGGCTGAGGGGTGCAGAGCCGAGTCAC
+GGGGTTGCCAGCACAGGGGCTTAACCTCTGGTGACTGCCAGAGCTGCTGGCAAGCTAGAG
+TCCCATTTGGAGCCCCTCTAAGCCGTTCTATTTGTAATGAAAACTATATTTATGCTATTC
+AGTTCTAAATATAGAAATTGAAACAGCTGTGTTTAGTGCCTTTGTTCAACCCCCTTGCAA
+CAACCTTGAGAACCCCAGGGAATTTGTCAATGTCAGGGAAGGAGCATTTTGTCAGTTACC
+AAATGTGTTTATTACCAGAGGGATGGAGGGAAGAGGGACGCTGAAGAACTTTGATGCCCT
+CTTCTTCCAAAGATGAAACGCGTAACTGCGCTCTCATTCACTCCAGCTCCCTGTCACCCA
+ATGGACCTGTGATATCTGGATTCTGGGAAATTCTTCATCCTGGACCCTGAGAGATTCTGC
+AGCCCAGCTCCAGATTGCTTGTGGTCTGACAGGCTGCAACTGTGAGCCATCACAATGAAC
+AACAGGAAGAAAAGGTCTTTCAAAAGGTGATGTGTGTTCTCATCAACCTCATACACACAC
+ATGGTTTAGGGGTATAATACCTCTACATGGCTGATTATGAAAACAATGTTCCCCAGATAC
+CATCCCTGTCTTACTTCCAGCTCCCCAGAGGGAAAGCTTTCAACGCTTCTAGCCATTTCT
+TTTGGCATTTGCCTTCAGACCCTACACGAATGCGTCTCTACCACAGGGGGCTGCGCGGTT
+TCCCATCATGAAGCACTGAACTTCCACGTCTCATCTAGGGGAACAGGGAGGTGCACTAAT
+GCGCTCCACGCCCAAGCCCTTCTCACAGTTTCTGCCCCCAGCATGGTTGTACTGGGCAAT
+ACATGAGATTATTAGGAAATGCTTTACTGTCATAACTATGAAGAGACTATTGCCAGATGA
+ACCACACATTAATACTATGTTTCTTATCTGCACATTACTACCCTGCAATTAATATAATTG
+TGTCCATGTACACACGCTGTCCTATGTACTTATCATGACTCTATCCCAAATTCCCAATTA
+CGTCCTATCTTCTTCTTAGGGAAGAACAGCTTAGGTATCAATTTGGTGTTCTGTGTAAAG
+TCTCAGGGAGCCGTCCGTGTCCTCCCATCTGGCCTCGTCCACACTGGTTCTCTTGAAAGC
+TTGGGCTGTAATGATGCCCCTTGGCCATCACCCAGTCCCTGCCCCATCTCTTGTAATCTC
+TCTCCTTTTTGCTGCATCCCTGTCTTCCTCTGTCTTGATTTACTTGTTGTTGGTTTTCTG
+TTTCTTTGTTTGATTTGGTGGAAGACATAATCCCACGCTTCCTATGGAAAGGTTGTTGGG
+AGATTTTTAATGATTCCTCAATGTTAAAATGTCTATTTTTGTCTTGACACCCAACTAATA
+TTTGTCTGAGCAAAACAGTCTAGATGAGAGAGAACTTCCCTGGAGGTCTGATGGCGTTTC
+TCCCTCGTCTTCTTA
+>seq2
+TTCAAATGAACTTCTGTAATTGAAAAATTCATTTAAGAAATTACAAAATATAGTTGAAAG
+CTCTAACAATAGACTAAACCAAGCAGAAGAAAGAGGTTCAGAACTTGAAGACAAGTCTCT
+TATGAATTAACCCAGTCAGACAAAAATAAAGAAAAAAATTTTAAAAATGAACAGAGCTTT
+CAAGAAGTATGAGATTATGTAAAGTAACTGAACCTATGAGTCACAGGTATTCCTGAGGAA
+AAAGAAAAAGTGAGAAGTTTGGAAAAACTATTTGAGGAAGTAATTGGGGAAAACCTCTTT
+AGTCTTGCTAGAGATTTAGACATCTAAATGAAAGAGGCTCAAAGAATGCCAGGAAGATAC
+ATTGCAAGACAGACTTCATCAAGATATGTAGTCATCAGACTATCTAAAGTCAACATGAAG
+GAAAAAAATTCTAAAATCAGCAAGAGAAAAGCATACAGTCATCTATAAAGGAAATCCCAT
+CAGAATAACAATGGGCTTCTCAGCAGAAACCTTACAAGCCAGAAGAGATTGGATCTAATT
+TTTGGACTTCTTAAAGAAAAAAAAACCTGTCAAACACGAATGTTATGCCCTGCTAAACTA
+AGCATCATAAATGAAGGGGAAATAAAGTCAAGTCTTTCCTGACAAGCAAATGCTAAGATA
+ATTCATCATCACTAAACCAGTCCTATAAGAAATGCTCAAAAGAATTGTAAAAGTCAAAAT
+TAAAGTTCAATACTCACCATCATAAATACACACAAAAGTACAAAACTCACAGGTTTTATA
+AAACAATTGAGACTACAGAGCAACTAGGTAAAAAATTAACATTACAACAGGAACAAAACC
+TCATATATCAATATTAACTTTGAATAAAAAGGGATTAAATTCCCCCACTTAAGAGATATA
+GATTGGCAGAACAGATTTAAAAACATGAACTAACTATATGCTGTTTACAAGAAACTCATT
+AATAAAGACATGAGTTCAGGTAAAGGGGTGGAAAAAGATGTTCTACGCAAACAGAAACCA
+AATGAGAGAAGGAGTAGCTATACTTATATCAGATAAAGCACACTTTAAATCAACAACAGT
+AAAATAAAACAAAGGAGGTCATCATACAATGATAAAAAGATCAATTCAGCAAGAAGATAT
+AACCATCCTACTAAATACATATGCACCTAACACAAGACTACCCAGATTCATAAAACAAAT
+ACTACTAGACCTAAGAGGGATGAGAAATTACCTAATTGGTACAATGTACAATATTCTGAT
+GATGGTTACACTAAAAGCCCATACTTTACTGCTACTCAATATATCCATGTAACAAATCTG
+CGCTTGTACTTCTAAATCTATAAAAAAATTAAAATTTAACAAAAGTAAATAAAACACATA
+GCTAAAACTAAAAAAGCAAAAACAAAAACTATGCTAAGTATTGGTAAAGATGTGGGGAAA
+AAAGTAAACTCTCAAATATTGCTAGTGGGAGTATAAATTGTTTTCCACTTTGGAAAACAA
+TTTGGTAATTTCGTTTTTTTTTTTTTCTTTTCTCTTTTTTTTTTTTTTTTTTTTGCATGC
+CAGAAAAAAATATTTACAGTAACT
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/examples/ex1.sam.gz b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/ex1.sam.gz
new file mode 100644
index 0000000..44c07ee
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/examples/ex1.sam.gz differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/faidx.c b/ext/samtools-0.1.7a_getUnique-0.1.3/faidx.c
new file mode 100644
index 0000000..811bdf8
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/faidx.c
@@ -0,0 +1,422 @@
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "faidx.h"
+#include "khash.h"
+
+typedef struct {
+	uint64_t len:32, line_len:16, line_blen:16;
+	uint64_t offset;
+} faidx1_t;
+KHASH_MAP_INIT_STR(s, faidx1_t)
+
+#ifndef _NO_RAZF
+#include "razf.h"
+#else
+#ifdef _WIN32
+#define ftello(fp) ftell(fp)
+#define fseeko(fp, offset, whence) fseek(fp, offset, whence)
+#else
+extern off_t ftello(FILE *stream);
+extern int fseeko(FILE *stream, off_t offset, int whence);
+#endif
+#define RAZF FILE
+#define razf_read(fp, buf, size) fread(buf, 1, size, fp)
+#define razf_open(fn, mode) fopen(fn, mode)
+#define razf_close(fp) fclose(fp)
+#define razf_seek(fp, offset, whence) fseeko(fp, offset, whence)
+#define razf_tell(fp) ftello(fp)
+#endif
+#ifdef _USE_KNETFILE
+#include "knetfile.h"
+#endif
+
+struct __faidx_t {
+	RAZF *rz;
+	int n, m;
+	char **name;
+	khash_t(s) *hash;
+};
+
+#ifndef kroundup32
+#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
+#endif
+
+static inline void fai_insert_index(faidx_t *idx, const char *name, int len, int line_len, int line_blen, uint64_t offset)
+{
+	khint_t k;
+	int ret;
+	faidx1_t t;
+	if (idx->n == idx->m) {
+		idx->m = idx->m? idx->m<<1 : 16;
+		idx->name = (char**)realloc(idx->name, sizeof(void*) * idx->m);
+	}
+	idx->name[idx->n] = strdup(name);
+	k = kh_put(s, idx->hash, idx->name[idx->n], &ret);
+	t.len = len; t.line_len = line_len; t.line_blen = line_blen; t.offset = offset;
+	kh_value(idx->hash, k) = t;
+	++idx->n;
+}
+
+faidx_t *fai_build_core(RAZF *rz)
+{
+	char c, *name;
+	int l_name, m_name, ret;
+	int len, line_len, line_blen, state;
+	int l1, l2;
+	faidx_t *idx;
+	uint64_t offset;
+
+	idx = (faidx_t*)calloc(1, sizeof(faidx_t));
+	idx->hash = kh_init(s);
+	name = 0; l_name = m_name = 0;
+	len = line_len = line_blen = -1; state = 0; l1 = l2 = -1; offset = 0;
+	while (razf_read(rz, &c, 1)) {
+		if (c == '\n') { // an empty line
+			if (state == 1) {
+				offset = razf_tell(rz);
+				continue;
+			} else if ((state == 0 && len < 0) || state == 2) continue;
+		}
+		if (c == '>') { // fasta header
+			if (len >= 0)
+				fai_insert_index(idx, name, len, line_len, line_blen, offset);
+			l_name = 0;
+			while ((ret = razf_read(rz, &c, 1)) != 0 && !isspace(c)) {
+				if (m_name < l_name + 2) {
+					m_name = l_name + 2;
+					kroundup32(m_name);
+					name = (char*)realloc(name, m_name);
+				}
+				name[l_name++] = c;
+			}
+			name[l_name] = '\0';
+			if (ret == 0) {
+				fprintf(stderr, "[fai_build_core] the last entry has no sequence\n");
+				free(name); fai_destroy(idx);
+				return 0;
+			}
+			if (c != '\n') while (razf_read(rz, &c, 1) && c != '\n');
+			state = 1; len = 0;
+			offset = razf_tell(rz);
+		} else {
+			if (state == 3) {
+				fprintf(stderr, "[fai_build_core] inlined empty line is not allowed in sequence '%s'.\n", name);
+				free(name); fai_destroy(idx);
+				return 0;
+			}
+			if (state == 2) state = 3;
+			l1 = l2 = 0;
+			do {
+				++l1;
+				if (isgraph(c)) ++l2;
+			} while ((ret = razf_read(rz, &c, 1)) && c != '\n');
+			if (state == 3 && l2) {
+				fprintf(stderr, "[fai_build_core] different line length in sequence '%s'.\n", name);
+				free(name); fai_destroy(idx);
+				return 0;
+			}
+			++l1; len += l2;
+			if (l2 >= 0x10000) {
+				fprintf(stderr, "[fai_build_core] line length exceeds 65535 in sequence '%s'.\n", name);
+				free(name); fai_destroy(idx);
+				return 0;
+			}
+			if (state == 1) line_len = l1, line_blen = l2, state = 0;
+			else if (state == 0) {
+				if (l1 != line_len || l2 != line_blen) state = 2;
+			}
+		}
+	}
+	fai_insert_index(idx, name, len, line_len, line_blen, offset);
+	free(name);
+	return idx;
+}
+
+void fai_save(const faidx_t *fai, FILE *fp)
+{
+	khint_t k;
+	int i;
+	for (i = 0; i < fai->n; ++i) {
+		faidx1_t x;
+		k = kh_get(s, fai->hash, fai->name[i]);
+		x = kh_value(fai->hash, k);
+#ifdef _WIN32
+		fprintf(fp, "%s\t%d\t%ld\t%d\t%d\n", fai->name[i], (int)x.len, (long)x.offset, (int)x.line_blen, (int)x.line_len);
+#else
+		fprintf(fp, "%s\t%d\t%lld\t%d\t%d\n", fai->name[i], (int)x.len, (long long)x.offset, (int)x.line_blen, (int)x.line_len);
+#endif
+	}
+}
+
+faidx_t *fai_read(FILE *fp)
+{
+	faidx_t *fai;
+	char *buf, *p;
+	int len, line_len, line_blen;
+#ifdef _WIN32
+	long offset;
+#else
+	long long offset;
+#endif
+	fai = (faidx_t*)calloc(1, sizeof(faidx_t));
+	fai->hash = kh_init(s);
+	buf = (char*)calloc(0x10000, 1);
+	while (!feof(fp) && fgets(buf, 0x10000, fp)) {
+		for (p = buf; *p && isgraph(*p); ++p);
+		*p = 0; ++p;
+#ifdef _WIN32
+		sscanf(p, "%d%ld%d%d", &len, &offset, &line_blen, &line_len);
+#else
+		sscanf(p, "%d%lld%d%d", &len, &offset, &line_blen, &line_len);
+#endif
+		fai_insert_index(fai, buf, len, line_len, line_blen, offset);
+	}
+	free(buf);
+	return fai;
+}
+
+void fai_destroy(faidx_t *fai)
+{
+	int i;
+	for (i = 0; i < fai->n; ++i) free(fai->name[i]);
+	free(fai->name);
+	kh_destroy(s, fai->hash);
+	if (fai->rz) razf_close(fai->rz);
+	free(fai);
+}
+
+int fai_build(const char *fn)
+{
+	char *str;
+	RAZF *rz;
+	FILE *fp;
+	faidx_t *fai;
+	str = (char*)calloc(strlen(fn) + 5, 1);
+	sprintf(str, "%s.fai", fn);
+	rz = razf_open(fn, "r");
+	if (rz == 0) {
+		fprintf(stderr, "[fai_build] fail to open the FASTA file %s\n",str);
+		free(str);
+		return -1;
+	}
+	fai = fai_build_core(rz);
+	razf_close(rz);
+	fp = fopen(str, "wb");
+	if (fp == 0) {
+		fprintf(stderr, "[fai_build] fail to write FASTA index %s\n",str);
+		fai_destroy(fai); free(str);
+		return -1;
+	}
+	fai_save(fai, fp);
+	fclose(fp);
+	free(str);
+	fai_destroy(fai);
+	return 0;
+}
+
+#ifdef _USE_KNETFILE
+FILE *download_and_open(const char *fn)
+{
+    const int buf_size = 1 * 1024 * 1024;
+    uint8_t *buf;
+    FILE *fp;
+    knetFile *fp_remote;
+    const char *url = fn;
+    const char *p;
+    int l = strlen(fn);
+    for (p = fn + l - 1; p >= fn; --p)
+        if (*p == '/') break;
+    fn = p + 1;
+
+    // First try to open a local copy
+    fp = fopen(fn, "r");
+    if (fp)
+        return fp;
+
+    // If failed, download from remote and open
+    fp_remote = knet_open(url, "rb");
+    if (fp_remote == 0) {
+        fprintf(stderr, "[download_from_remote] fail to open remote file %s\n",url);
+        return NULL;
+    }
+    if ((fp = fopen(fn, "wb")) == 0) {
+        fprintf(stderr, "[download_from_remote] fail to create file in the working directory %s\n",fn);
+        knet_close(fp_remote);
+        return NULL;
+    }
+    buf = (uint8_t*)calloc(buf_size, 1);
+    while ((l = knet_read(fp_remote, buf, buf_size)) != 0)
+        fwrite(buf, 1, l, fp);
+    free(buf);
+    fclose(fp);
+    knet_close(fp_remote);
+
+    return fopen(fn, "r");
+}
+#endif
+
+faidx_t *fai_load(const char *fn)
+{
+	char *str;
+	FILE *fp;
+	faidx_t *fai;
+	str = (char*)calloc(strlen(fn) + 5, 1);
+	sprintf(str, "%s.fai", fn);
+
+#ifdef _USE_KNETFILE
+    if (strstr(fn, "ftp://") == fn || strstr(fn, "http://") == fn)
+    {
+        fp = download_and_open(str);
+        if ( !fp )
+        {
+            fprintf(stderr, "[fai_load] failed to open remote FASTA index %s\n", str);
+            free(str);
+            return 0;
+        }
+    }
+    else
+#endif
+        fp = fopen(str, "rb");
+	if (fp == 0) {
+		fprintf(stderr, "[fai_load] build FASTA index.\n");
+		fai_build(fn);
+		fp = fopen(str, "rb");
+		if (fp == 0) {
+			fprintf(stderr, "[fai_load] fail to open FASTA index.\n");
+			free(str);
+			return 0;
+		}
+	}
+
+	fai = fai_read(fp);
+	fclose(fp);
+
+	fai->rz = razf_open(fn, "rb");
+	free(str);
+	if (fai->rz == 0) {
+		fprintf(stderr, "[fai_load] fail to open FASTA file.\n");
+		return 0;
+	}
+	return fai;
+}
+
+char *fai_fetch(const faidx_t *fai, const char *str, int *len)
+{
+	char *s, *p, c;
+	int i, l, k;
+	khiter_t iter;
+	faidx1_t val;
+	khash_t(s) *h;
+	int beg, end;
+
+	beg = end = -1;
+	h = fai->hash;
+	l = strlen(str);
+	p = s = (char*)malloc(l+1);
+	/* squeeze out "," */
+	for (i = k = 0; i != l; ++i)
+		if (str[i] != ',' && !isspace(str[i])) s[k++] = str[i];
+	s[k] = 0;
+	for (i = 0; i != k; ++i) if (s[i] == ':') break;
+	s[i] = 0;
+	iter = kh_get(s, h, s); /* get the ref_id */
+	if (iter == kh_end(h)) {
+		*len = 0;
+		free(s); return 0;
+	}
+	val = kh_value(h, iter);
+	if (i == k) { /* dump the whole sequence */
+		beg = 0; end = val.len;
+	} else {
+		for (p = s + i + 1; i != k; ++i) if (s[i] == '-') break;
+		beg = atoi(p);
+		if (i < k) {
+			p = s + i + 1;
+			end = atoi(p);
+		} else end = val.len;
+	}
+	if (beg > 0) --beg;
+	if (beg >= val.len) beg = val.len;
+	if (end >= val.len) end = val.len;
+	if (beg > end) beg = end;
+	free(s);
+
+	// now retrieve the sequence
+	l = 0;
+	s = (char*)malloc(end - beg + 2);
+	razf_seek(fai->rz, val.offset + beg / val.line_blen * val.line_len + beg % val.line_blen, SEEK_SET);
+	while (razf_read(fai->rz, &c, 1) == 1 && l < end - beg && !fai->rz->z_err)
+		if (isgraph(c)) s[l++] = c;
+	s[l] = '\0';
+	*len = l;
+	return s;
+}
+
+int faidx_main(int argc, char *argv[])
+{
+	if (argc == 1) {
+		fprintf(stderr, "Usage: faidx <in.fasta> [<reg> [...]]\n");
+		return 1;
+	} else {
+		if (argc == 2) fai_build(argv[1]);
+		else {
+			int i, j, k, l;
+			char *s;
+			faidx_t *fai;
+			fai = fai_load(argv[1]);
+			if (fai == 0) return 1;
+			for (i = 2; i != argc; ++i) {
+				printf(">%s\n", argv[i]);
+				s = fai_fetch(fai, argv[i], &l);
+				for (j = 0; j < l; j += 60) {
+					for (k = 0; k < 60 && k < l - j; ++k)
+						putchar(s[j + k]);
+					putchar('\n');
+				}
+				free(s);
+			}
+			fai_destroy(fai);
+		}
+	}
+	return 0;
+}
+
+int faidx_fetch_nseq(const faidx_t *fai) 
+{
+	return fai->n;
+}
+
+char *faidx_fetch_seq(const faidx_t *fai, char *c_name, int p_beg_i, int p_end_i, int *len)
+{
+	int l;
+	char c;
+    khiter_t iter;
+    faidx1_t val;
+	char *seq=NULL;
+
+    // Adjust position
+    iter = kh_get(s, fai->hash, c_name);
+    if(iter == kh_end(fai->hash)) return 0;
+    val = kh_value(fai->hash, iter);
+	if(p_end_i < p_beg_i) p_beg_i = p_end_i;
+    if(p_beg_i < 0) p_beg_i = 0;
+    else if(val.len <= p_beg_i) p_beg_i = val.len - 1;
+    if(p_end_i < 0) p_end_i = 0;
+    else if(val.len <= p_end_i) p_end_i = val.len - 1;
+
+    // Now retrieve the sequence 
+	l = 0;
+	seq = (char*)malloc(p_end_i - p_beg_i + 2);
+	razf_seek(fai->rz, val.offset + p_beg_i / val.line_blen * val.line_len + p_beg_i % val.line_blen, SEEK_SET);
+	while (razf_read(fai->rz, &c, 1) == 1 && l < p_end_i - p_beg_i + 1)
+		if (isgraph(c)) seq[l++] = c;
+	seq[l] = '\0';
+	*len = l;
+	return seq;
+}
+
+#ifdef FAIDX_MAIN
+int main(int argc, char *argv[]) { return faidx_main(argc, argv); }
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/faidx.h b/ext/samtools-0.1.7a_getUnique-0.1.3/faidx.h
new file mode 100644
index 0000000..1fb1b1f
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/faidx.h
@@ -0,0 +1,103 @@
+/* The MIT License
+
+   Copyright (c) 2008 Genome Research Ltd (GRL).
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Contact: Heng Li <lh3@sanger.ac.uk> */
+
+#ifndef FAIDX_H
+#define FAIDX_H
+
+/*!
+  @header
+
+  Index FASTA files and extract subsequence.
+
+  @copyright The Wellcome Trust Sanger Institute.
+ */
+
+struct __faidx_t;
+typedef struct __faidx_t faidx_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	/*!
+	  @abstract   Build index for a FASTA or razip compressed FASTA file.
+	  @param  fn  FASTA file name
+	  @return     0 on success; or -1 on failure
+	  @discussion File "fn.fai" will be generated.
+	 */
+	int fai_build(const char *fn);
+
+	/*!
+	  @abstract    Distroy a faidx_t struct.
+	  @param  fai  Pointer to the struct to be destroyed
+	 */
+	void fai_destroy(faidx_t *fai);
+
+	/*!
+	  @abstract   Load index from "fn.fai".
+	  @param  fn  File name of the FASTA file
+	 */
+	faidx_t *fai_load(const char *fn);
+
+	/*!
+	  @abstract    Fetch the sequence in a region.
+	  @param  fai  Pointer to the faidx_t struct
+	  @param  reg  Region in the format "chr2:20,000-30,000"
+	  @param  len  Length of the region
+	  @return      Pointer to the sequence; null on failure
+
+	  @discussion The returned sequence is allocated by malloc family
+	  and should be destroyed by end users by calling free() on it.
+	 */
+	char *fai_fetch(const faidx_t *fai, const char *reg, int *len);
+
+	/*!
+	  @abstract	   Fetch the number of sequences. 
+	  @param  fai  Pointer to the faidx_t struct
+	  @return	   The number of sequences
+	 */
+	int faidx_fetch_nseq(const faidx_t *fai);
+
+	/*!
+	  @abstract    Fetch the sequence in a region.
+	  @param  fai  Pointer to the faidx_t struct
+	  @param  c_name Region name
+	  @param  p_beg_i  Beginning position number (zero-based)
+	  @param  p_end_i  End position number (zero-based)
+	  @param  len  Length of the region
+	  @return      Pointer to the sequence; null on failure
+
+	  @discussion The returned sequence is allocated by malloc family
+	  and should be destroyed by end users by calling free() on it.
+	 */
+	char *faidx_fetch_seq(const faidx_t *fai, char *c_name, int p_beg_i, int p_end_i, int *len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/getUniqueRead.c b/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/getUniqueRead.c
new file mode 100644
index 0000000..bd1d778
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/getUniqueRead.c
@@ -0,0 +1,313 @@
+
+#include "getUniqueRead.h"
+#include "../bam.h"
+
+#define Bowtie 1
+#define BWA 2
+
+typedef struct ReadPosOutput_t{
+	char *chrom;
+	char *outputname;
+	FILE *output;
+	int num_reads; /*number of reads reported so far for this chromosome*/
+	} ReadPosOutput;
+
+typedef struct ReadPosOutput_allchrom_t{
+	ReadPosOutput * cout;
+	int size;
+	} RdOutAC;
+
+static char *outputPrefix = NULL;
+static int ALIGNER = BWA;
+static int ChromNameReport = 0;
+static int StrandReport = 0;
+static int StrandSep = 0; /*Separate negative reads and positive reads to separate files? (0 no, 1 yes)*/
+static int minReadLen = 0;
+static int maxReadLen = 100000000;
+
+static int *readLength=NULL;
+static int maxReadLen_S = 0;
+
+
+void summarizeReadLength(bam1_t *b)
+{	int k = 0, i=0, mRL;
+	k = b->core.l_qseq;
+	//printf("k=%d\n",k);
+	if(readLength==NULL || k +10> maxReadLen_S){
+		mRL = maxReadLen_S;
+		maxReadLen_S = k+10;
+		readLength = (int *) realloc(readLength,sizeof(int)*(maxReadLen_S+10));
+		for(i=mRL;i<maxReadLen_S;i++){
+			readLength[i]=0;
+			}
+		}
+	readLength[k-1]++;
+
+  return;
+}
+
+void reportReadLength(FILE *out)
+{	int i;
+	for(i=0;i<maxReadLen_S;i++){
+		if(i==0) fprintf(out,"readLength\tcount\n");
+		if(readLength[i]>0){
+			fprintf(out,"%d\t%d\n",i+1,readLength[i]);
+			}
+		}
+
+}
+
+//static int cmp_ReadPosOutput(void *a1, void *a2);
+static int is_unique_mapped(bam1_t *b, int aligner); /*In this version, this function will just test if a read is mapped*/
+static RdOutAC *create_Readoutput(bam_header_t *in, char *prefix);
+static int destroy_Readoutput(RdOutAC * out); /*return the total number of reads reported so far*/
+static int report_one_read(RdOutAC *out, bam1_t *b);
+
+static RdOutAC *create_Readoutput(bam_header_t *in, char *prefix)
+{	RdOutAC *ot=malloc(sizeof(RdOutAC));
+	int i;
+	ot->size = (in->n_targets)*(StrandSep+1);
+	ot->cout = malloc(sizeof(ReadPosOutput)*(ot->size+10));
+	if(ot->cout==NULL) {fprintf(stderr,"Error in create_Readoutput: memory allocation failed\n");exit(1);}
+	
+	if(StrandSep==0){
+		for(i=0;i<ot->size;i++){
+			ot->cout[i].chrom = strdup(in->target_name[i]);
+			ot->cout[i].outputname = malloc(sizeof(char)*(strlen(prefix)+strlen(ot->cout[i].chrom)+10));
+			if(ot->cout[i].outputname==NULL) {fprintf(stderr,"Error in create_Readoutput: memory allocation failed\n");exit(1);}
+			ot->cout[i].outputname[0] = '\0';
+			strcat(ot->cout[i].outputname,prefix);
+			strcat(ot->cout[i].outputname,ot->cout[i].chrom);
+			strcat(ot->cout[i].outputname,".seq");
+
+			ot->cout[i].output=NULL; 
+			ot->cout[i].output = fopen(ot->cout[i].outputname,"w");
+			if(ot->cout[i].output==NULL){
+				fprintf(stderr,"Error, failed to create/open the file %s\n",ot->cout[i].outputname);
+				exit(1);
+				}
+
+			ot->cout[i].num_reads=0;
+			}
+		}else{
+                for(i=0;i<ot->size/2;i++){
+                        ot->cout[2*i].chrom = strdup(in->target_name[i]);
+                        ot->cout[2*i].outputname = malloc(sizeof(char)*(strlen(prefix)+strlen(ot->cout[2*i].chrom)+20));
+                        if(ot->cout[2*i].outputname==NULL) {fprintf(stderr,"Error in create_Readoutput: memory allocation failed\n");exit(1);}
+                        ot->cout[2*i].outputname[0] = '\0';
+                        strcat(ot->cout[2*i].outputname,prefix);
+                        strcat(ot->cout[2*i].outputname,ot->cout[2*i].chrom);
+			strcat(ot->cout[2*i].outputname,"_pos");
+                        strcat(ot->cout[2*i].outputname,".seq");
+
+                        ot->cout[2*i].output = fopen(ot->cout[2*i].outputname,"w");
+                        if(ot->cout[2*i].output==NULL){
+                                fprintf(stderr,"Error, failed to create/open the file %s\n",ot->cout[2*i].outputname);
+                                exit(1);
+                                }
+
+                        ot->cout[2*i].num_reads=0;
+
+                        ot->cout[2*i+1].chrom = strdup(in->target_name[i]);
+                        ot->cout[2*i+1].outputname = malloc(sizeof(char)*(strlen(prefix)+strlen(ot->cout[2*i].chrom)+20));
+                        if(ot->cout[2*i+1].outputname==NULL) {fprintf(stderr,"Error in create_Readoutput: memory allocation failed\n");exit(1);}
+                        ot->cout[2*i+1].outputname[0] = '\0';
+                        strcat(ot->cout[2*i+1].outputname,prefix);
+                        strcat(ot->cout[2*i+1].outputname,ot->cout[2*i].chrom);
+                        strcat(ot->cout[2*i+1].outputname,"_neg");
+                        strcat(ot->cout[2*i+1].outputname,".seq");
+
+                        ot->cout[2*i+1].output = fopen(ot->cout[2*i+1].outputname,"w");
+                        if(ot->cout[2*i+1].output==NULL){
+                                fprintf(stderr,"Error, failed to create/open the file %s\n",ot->cout[2*i+1].outputname);
+                                exit(1);
+                                }
+
+                        ot->cout[2*i+1].num_reads=0;
+
+                        }
+
+
+		}
+
+	return ot;
+}
+
+static int destroy_Readoutput(RdOutAC *out)
+{	int i, n=0;
+	if(out==NULL) return 0;
+
+	for(i=0;i<out->size;i++){
+		n += out->cout[i].num_reads;
+		//fprintf(stderr,"chromsome %s: %d reads\n",out->cout[i].chrom,out->cout[i].num_reads);
+		free(out->cout[i].chrom);
+		free(out->cout[i].outputname);
+		fclose(out->cout[i].output);
+		}
+	free(out->cout);
+	out->cout=NULL;
+	out->size = 0;
+	
+	free(out);
+	return n;
+}
+
+
+int get_Unique_args(char *args_in)
+{	char *args = strdup(args_in), *substr=NULL;
+ 	if(args==NULL){
+		fprintf(stderr,"argument is required for option U\n");
+		exit(1);
+		}
+
+	substr = strtok(args,",");
+	if(strcmp(substr,"BWA")==0){
+		ALIGNER = BWA;
+		//fprintf(stderr,"Aliger is BWA\n");
+		}else if(strcmp(substr,"Bowtie")==0){
+		ALIGNER = Bowtie;
+		//fprintf(stderr,"Aliger is Bowtie\n");
+		}else{
+		fprintf(stderr,"Aligner can only be BWA or Bowtie\n");
+		exit(1);
+		}
+	substr = strtok(NULL,",");
+	if(substr==NULL){
+		fprintf(stderr, "Option U should have argument of the format\n<Aligner,OutputPrefix,ChomNameReport?,StrandReport?> or <Aligner,OutputPrefix,ChomNameReport?,StrandReport?,minLen,MaxLen>\n");
+		exit(1);
+		}
+	outputPrefix = strdup(substr);
+
+	substr = strtok(NULL,",");
+        if(substr==NULL){
+                fprintf(stderr, "Option U should have argument of the format\n<Aligner,OutputPrefix,ChomNameReport?,StrandReport?> or <Aligner,OutputPrefix,ChomNameReport?,StrandReport?,minLen,MaxLen>\n");
+                exit(1);
+                }
+	if(strcmp(substr,"N")!=0&&strcmp(substr,"Y")!=0){
+		fprintf(stderr,"The 3rd argumennt for the option U must be 'Y' or 'N'");
+		exit(1);
+		}else if(strcmp(substr,"N")==0){ChromNameReport=0;}
+		else if(strcmp(substr,"Y")==0){ChromNameReport=1;}
+	
+	substr = strtok(NULL,",");
+        if(substr==NULL){
+                fprintf(stderr, "Option U should have argument of the format\n<Aligner,OutputPrefix,ChomNameReport?,StrandReport?> or <Aligner,OutputPrefix,ChomNameReport?,StrandReport?,minLen,MaxLen>\n");
+                exit(1);
+                }
+        if(strcmp(substr,"N")!=0&&strcmp(substr,"Y")!=0&&strcmp(substr,"S")!=0){
+                fprintf(stderr,"The 4th argumennt for the option U must be 'Y' or 'N', or 'S'");
+		exit(1);
+                }else if(strcmp(substr,"N")==0){StrandReport=0;}
+                else if(strcmp(substr,"Y")==0){StrandReport=1;}
+		else if(strcmp(substr,"S")==0){StrandSep=1;}
+
+	substr = strtok(NULL,",");
+	if(substr!=NULL){
+		minReadLen = atoi(substr);
+		if(minReadLen<0) fprintf(stderr,"minLen=%d is negative\n",minReadLen);
+
+		substr = strtok(NULL,",");
+	        if(substr==NULL){
+        	        fprintf(stderr, "Option U should have argument of the format\n<Aligner,OutputPrefix,ChomNameReport?,StrandReport?> or <Aligner,OutputPrefix,ChomNameReport?,StrandReport?,minLen,MaxLen>\n");
+               		exit(1);
+                	}
+		maxReadLen = atoi(substr);
+		if(maxReadLen<minReadLen) fprintf(stderr,"maxLen=%d is less than minLen=%d\n",maxReadLen, minReadLen);
+		}
+
+
+
+	return 0;
+}
+/*
+static int cmp_ReadPosOutput(void *a1, void *a2)
+{	ReadPosOutput tmp1, tmp2;
+	tmp1 = *(ReadPosOutput *) a1;
+	tmp2 = *(ReadPosOutput *) a2;
+
+	if(strcmp(tmp1.chrom,tmp2.chrom)<0) return -1;
+	else if (strcmp(tmp1.chrom,tmp2.chrom)>0) return 1;
+	else return 0;
+}*/
+
+
+static int is_unique_mapped(bam1_t *b, int aligner)
+{	int is_unmapped;
+	//int num_hit;
+	//char XTtag;
+	//uint8_t *tag_p;
+
+
+	if(b->core.l_qseq < minReadLen || b->core.l_qseq > maxReadLen) return 0; /*Does not satisfy the read length constraint, return false (0)*/
+
+	is_unmapped = ((b->core.flag) & 0x0004)>>2;
+
+	if(is_unmapped==0){
+		//if(aligner==Bowtie)
+		//	{ tag_p = bam_aux_get(b,"XM");
+		//	  num_hit = bam_aux2i(tag_p);
+		//	  if(num_hit<=1) return 1; else return 0;
+		//	}
+		//else if(aligner==BWA){
+		//	tag_p = bam_aux_get(b,"XT");
+		//	XTtag = bam_aux2A(tag_p);
+		//	tag_p = bam_aux_get(b,"X1");
+		//	num_hit = bam_aux2i(tag_p);
+
+			//if(XTtag!='U'||num_hit>1) {fprintf(stderr,"name=%s\tXTtag=%c\tnum_hit=%d\n",bam1_qname(b),XTtag,num_hit);getchar();}
+
+		//	if(XTtag=='U'&&num_hit<=0) return 1; 
+		//	else return 0;
+
+		//	}
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static int report_one_read(RdOutAC *out, bam1_t *b)
+{	int unique;
+	int strand;
+	FILE *fout=NULL;
+	int index;
+	unique = is_unique_mapped(b,ALIGNER);
+	if(unique==0) return 0; /*b is not unqiuely mapped, do not report*/
+
+	strand = ((b->core.flag) & 0x0010)>>4;
+	if(StrandSep==1){
+		fout = out->cout[b->core.tid*2+strand].output;
+		index = b->core.tid*2+strand;
+		}else{
+		fout = out->cout[b->core.tid].output;
+		index = b->core.tid;
+		}
+	if(fout==NULL) {fprintf(stderr,"ERROR: fout is NULL\n");}
+
+	if(ChromNameReport==1) fprintf(fout,"%s\t",out->cout[index].chrom);
+	fprintf(fout,"%d",b->core.pos);
+	if(StrandReport==1) {
+		fprintf(fout,"\t%d",strand);
+		}
+	fprintf(fout,"\n");
+
+	out->cout[index].num_reads++;
+	return 1;
+}
+
+void report_unique_read(bam_header_t *in,bam1_t *b)
+{	static RdOutAC *out= NULL;
+	int num_unique=0;
+	
+	if(out==NULL) out = create_Readoutput(in, outputPrefix);
+
+	if(b!=NULL) report_one_read(out,b);
+
+
+	if(in==NULL&&b==NULL&&out!=NULL) {
+		num_unique=destroy_Readoutput(out);
+		fprintf(stderr,"Reported %d unqiue mapped reads\n",num_unique);
+		}
+	return ;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/getUniqueRead.h b/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/getUniqueRead.h
new file mode 100644
index 0000000..bd30a81
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/getUniqueRead.h
@@ -0,0 +1,23 @@
+#ifndef GetUniqueBamRead
+#define GetUniqueBamRead
+
+#define _GNU_SOURCE     /* Expose declaration of tdestroy() */
+#include <search.h>
+
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+#include "../bam.h"
+#include "../sam.h"
+
+
+
+int get_Unique_args(char *args);
+
+void report_unique_read(bam_header_t *in,bam1_t *b);
+void summarizeReadLength(bam1_t *b);
+void reportReadLength(FILE *out);
+
+#endif
+
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/tmp.txt b/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/tmp.txt
new file mode 100644
index 0000000..be530e4
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/getUniqueRead/tmp.txt
@@ -0,0 +1,85 @@
+chromsome 1: 570172 reads
+chromsome 2: 598966 reads
+chromsome 3: 473076 reads
+chromsome 4: 483467 reads
+chromsome 5: 432846 reads
+chromsome 6: 408330 reads
+chromsome 7: 384468 reads
+chromsome 8: 359828 reads
+chromsome 9: 288396 reads
+chromsome 10: 378667 reads
+chromsome 11: 323820 reads
+chromsome 12: 317501 reads
+chromsome 13: 224033 reads
+chromsome 14: 214702 reads
+chromsome 15: 203450 reads
+chromsome 16: 228424 reads
+chromsome 17: 189502 reads
+chromsome 18: 182816 reads
+chromsome 19: 138899 reads
+chromsome 20: 148321 reads
+chromsome 21: 92174 reads
+chromsome 22: 82089 reads
+chromsome X: 377070 reads
+chromsome Y: 0 reads
+chromsome MT: 0 reads
+chromsome GL000207.1: 0 reads
+chromsome GL000226.1: 0 reads
+chromsome GL000229.1: 0 reads
+chromsome GL000231.1: 0 reads
+chromsome GL000210.1: 0 reads
+chromsome GL000239.1: 0 reads
+chromsome GL000235.1: 0 reads
+chromsome GL000201.1: 0 reads
+chromsome GL000247.1: 0 reads
+chromsome GL000245.1: 0 reads
+chromsome GL000197.1: 0 reads
+chromsome GL000203.1: 0 reads
+chromsome GL000246.1: 0 reads
+chromsome GL000249.1: 0 reads
+chromsome GL000196.1: 0 reads
+chromsome GL000248.1: 0 reads
+chromsome GL000244.1: 0 reads
+chromsome GL000238.1: 0 reads
+chromsome GL000202.1: 0 reads
+chromsome GL000234.1: 0 reads
+chromsome GL000232.1: 0 reads
+chromsome GL000206.1: 0 reads
+chromsome GL000240.1: 0 reads
+chromsome GL000236.1: 0 reads
+chromsome GL000241.1: 0 reads
+chromsome GL000243.1: 0 reads
+chromsome GL000242.1: 0 reads
+chromsome GL000230.1: 0 reads
+chromsome GL000237.1: 0 reads
+chromsome GL000233.1: 0 reads
+chromsome GL000204.1: 0 reads
+chromsome GL000198.1: 0 reads
+chromsome GL000208.1: 0 reads
+chromsome GL000191.1: 0 reads
+chromsome GL000227.1: 0 reads
+chromsome GL000228.1: 0 reads
+chromsome GL000214.1: 0 reads
+chromsome GL000221.1: 0 reads
+chromsome GL000209.1: 0 reads
+chromsome GL000218.1: 0 reads
+chromsome GL000220.1: 0 reads
+chromsome GL000213.1: 0 reads
+chromsome GL000211.1: 0 reads
+chromsome GL000199.1: 0 reads
+chromsome GL000217.1: 0 reads
+chromsome GL000216.1: 0 reads
+chromsome GL000215.1: 0 reads
+chromsome GL000205.1: 0 reads
+chromsome GL000219.1: 0 reads
+chromsome GL000224.1: 0 reads
+chromsome GL000223.1: 0 reads
+chromsome GL000195.1: 0 reads
+chromsome GL000212.1: 0 reads
+chromsome GL000222.1: 0 reads
+chromsome GL000200.1: 0 reads
+chromsome GL000193.1: 0 reads
+chromsome GL000194.1: 0 reads
+chromsome GL000225.1: 0 reads
+chromsome GL000192.1: 0 reads
+Reported 7101017 unqiue mapped reads
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/glf.c b/ext/samtools-0.1.7a_getUnique-0.1.3/glf.c
new file mode 100644
index 0000000..8d5346a
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/glf.c
@@ -0,0 +1,236 @@
+#include <string.h>
+#include <stdlib.h>
+#include "glf.h"
+
+#ifdef _NO_BGZF
+// then alias bgzf_*() functions
+#endif
+
+static int glf3_is_BE = 0;
+
+static inline uint32_t bam_swap_endian_4(uint32_t v)
+{
+	v = ((v & 0x0000FFFFU) << 16) | (v >> 16);
+	return ((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8);
+}
+
+static inline uint16_t bam_swap_endian_2(uint16_t v)
+{
+	return (uint16_t)(((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8));
+}
+
+static inline int bam_is_big_endian()
+{
+	long one= 1;
+	return !(*((char *)(&one)));
+}
+
+glf3_header_t *glf3_header_init()
+{
+	glf3_is_BE = bam_is_big_endian();
+	return (glf3_header_t*)calloc(1, sizeof(glf3_header_t));
+}
+
+glf3_header_t *glf3_header_read(glfFile fp)
+{
+	glf3_header_t *h;
+	char magic[4];
+	h = glf3_header_init();
+	bgzf_read(fp, magic, 4);
+	if (strncmp(magic, "GLF\3", 4)) {
+		fprintf(stderr, "[glf3_header_read] invalid magic.\n");
+		glf3_header_destroy(h);
+		return 0;
+	}
+	bgzf_read(fp, &h->l_text, 4);
+	if (glf3_is_BE) h->l_text = bam_swap_endian_4(h->l_text);
+	if (h->l_text) {
+		h->text = (uint8_t*)calloc(h->l_text + 1, 1);
+		bgzf_read(fp, h->text, h->l_text);
+	}
+	return h;
+}
+
+void glf3_header_write(glfFile fp, const glf3_header_t *h)
+{
+	int32_t x;
+	bgzf_write(fp, "GLF\3", 4);
+	x = glf3_is_BE? bam_swap_endian_4(h->l_text) : h->l_text;
+	bgzf_write(fp, &x, 4);
+	if (h->l_text) bgzf_write(fp, h->text, h->l_text);
+}
+
+void glf3_header_destroy(glf3_header_t *h)
+{
+	free(h->text);
+	free(h);
+}
+
+char *glf3_ref_read(glfFile fp, int *len)
+{
+	int32_t n, x;
+	char *str;
+	*len = 0;
+	if (bgzf_read(fp, &n, 4) != 4) return 0;
+	if (glf3_is_BE) n = bam_swap_endian_4(n);
+	if (n < 0) {
+		fprintf(stderr, "[glf3_ref_read] invalid reference name length: %d.\n", n);
+		return 0;
+	}
+	str = (char*)calloc(n + 1, 1); // not necesarily n+1 in fact
+	x = bgzf_read(fp, str, n);
+	x += bgzf_read(fp, len, 4);
+	if (x != n + 4) {
+		free(str); *len = -1; return 0; // truncated
+	}
+	if (glf3_is_BE) *len = bam_swap_endian_4(*len);
+	return str;
+}
+
+void glf3_ref_write(glfFile fp, const char *str, int len)
+{
+	int32_t m, n = strlen(str) + 1;
+	m = glf3_is_BE? bam_swap_endian_4(n) : n;
+	bgzf_write(fp, &m, 4);
+	bgzf_write(fp, str, n);
+	if (glf3_is_BE) len = bam_swap_endian_4(len);
+	bgzf_write(fp, &len, 4);
+}
+
+void glf3_view1(const char *ref_name, const glf3_t *g3, int pos)
+{
+	int j;
+	if (g3->rtype == GLF3_RTYPE_END) return;
+	printf("%s\t%d\t%c\t%d\t%d\t%d", ref_name, pos + 1,
+		   g3->rtype == GLF3_RTYPE_INDEL? '*' : "XACMGRSVTWYHKDBN"[g3->ref_base],
+		   g3->depth, g3->rms_mapQ, g3->min_lk);
+	if (g3->rtype == GLF3_RTYPE_SUB)
+		for (j = 0; j != 10; ++j) printf("\t%d", g3->lk[j]);
+	else {
+		printf("\t%d\t%d\t%d\t%d\t%d\t%s\t%s\t", g3->lk[0], g3->lk[1], g3->lk[2], g3->indel_len[0], g3->indel_len[1],
+			   g3->indel_len[0]? g3->indel_seq[0] : "*", g3->indel_len[1]? g3->indel_seq[1] : "*");
+	}
+	printf("\n");
+}
+
+int glf3_write1(glfFile fp, const glf3_t *g3)
+{
+	int r;
+	uint8_t c;
+	uint32_t y[2];
+	c = g3->rtype<<4 | g3->ref_base;
+	r = bgzf_write(fp, &c, 1);
+	if (g3->rtype == GLF3_RTYPE_END) return r;
+	y[0] = g3->offset;
+	y[1] = g3->min_lk<<24 | g3->depth;
+	if (glf3_is_BE) {
+		y[0] = bam_swap_endian_4(y[0]);
+		y[1] = bam_swap_endian_4(y[1]);
+	}
+	r += bgzf_write(fp, y, 8);
+	r += bgzf_write(fp, &g3->rms_mapQ, 1);
+	if (g3->rtype == GLF3_RTYPE_SUB) r += bgzf_write(fp, g3->lk, 10);
+	else {
+		int16_t x[2];
+		r += bgzf_write(fp, g3->lk, 3);
+		x[0] = glf3_is_BE? bam_swap_endian_2(g3->indel_len[0]) : g3->indel_len[0];
+		x[1] = glf3_is_BE? bam_swap_endian_2(g3->indel_len[1]) : g3->indel_len[1];
+		r += bgzf_write(fp, x, 4);
+		if (g3->indel_len[0]) r += bgzf_write(fp, g3->indel_seq[0], abs(g3->indel_len[0]));
+		if (g3->indel_len[1]) r += bgzf_write(fp, g3->indel_seq[1], abs(g3->indel_len[1]));
+	}
+	return r;
+}
+
+#ifndef kv_roundup32
+#define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
+#endif
+
+int glf3_read1(glfFile fp, glf3_t *g3)
+{
+	int r;
+	uint8_t c;
+	uint32_t y[2];
+	r = bgzf_read(fp, &c, 1);
+	if (r == 0) return 0;
+	g3->ref_base = c & 0xf;
+	g3->rtype = c>>4;
+	if (g3->rtype == GLF3_RTYPE_END) return r;
+	r += bgzf_read(fp, y, 8);
+	if (glf3_is_BE) {
+		y[0] = bam_swap_endian_4(y[0]);
+		y[1] = bam_swap_endian_4(y[1]);
+	}
+	g3->offset = y[0];
+	g3->min_lk = y[1]>>24;
+	g3->depth = y[1]<<8>>8;
+	r += bgzf_read(fp, &g3->rms_mapQ, 1);
+	if (g3->rtype == GLF3_RTYPE_SUB) r += bgzf_read(fp, g3->lk, 10);
+	else {
+		int16_t x[2], max;
+		r += bgzf_read(fp, g3->lk, 3);
+		r += bgzf_read(fp, x, 4);
+		if (glf3_is_BE) {
+			x[0] = bam_swap_endian_2(x[0]);
+			x[1] = bam_swap_endian_2(x[1]);
+		}
+		g3->indel_len[0] = x[0];
+		g3->indel_len[1] = x[1];
+		x[0] = abs(x[0]); x[1] = abs(x[1]);
+		max = (x[0] > x[1]? x[0] : x[1]) + 1;
+		if (g3->max_len < max) {
+			g3->max_len = max;
+			kv_roundup32(g3->max_len);
+			g3->indel_seq[0] = (char*)realloc(g3->indel_seq[0], g3->max_len);
+			g3->indel_seq[1] = (char*)realloc(g3->indel_seq[1], g3->max_len);
+		}
+		r += bgzf_read(fp, g3->indel_seq[0], x[0]);
+		r += bgzf_read(fp, g3->indel_seq[1], x[1]);
+		g3->indel_seq[0][x[0]] = g3->indel_seq[1][x[1]] = 0;
+	}
+	return r;
+}
+
+void glf3_view(glfFile fp)
+{
+	glf3_header_t *h;
+	char *name;
+	glf3_t *g3;
+	int len;
+	h = glf3_header_read(fp);
+	g3 = glf3_init1();
+	while ((name = glf3_ref_read(fp, &len)) != 0) {
+		int pos = 0;
+		while (glf3_read1(fp, g3) && g3->rtype != GLF3_RTYPE_END) {
+			pos += g3->offset;
+			glf3_view1(name, g3, pos);
+		}
+		free(name);
+	}
+	glf3_header_destroy(h);
+	glf3_destroy1(g3);
+}
+
+int glf3_view_main(int argc, char *argv[])
+{
+	glfFile fp;
+	if (argc == 1) {
+		fprintf(stderr, "Usage: glfview <in.glf>\n");
+		return 1;
+	}
+	fp = (strcmp(argv[1], "-") == 0)? bgzf_fdopen(fileno(stdin), "r") : bgzf_open(argv[1], "r");
+	if (fp == 0) {
+		fprintf(stderr, "Fail to open file '%s'\n", argv[1]);
+		return 1;
+	}
+	glf3_view(fp);
+	bgzf_close(fp);
+	return 0;
+}
+
+#ifdef GLFVIEW_MAIN
+int main(int argc, char *argv[])
+{
+	return glf3_view_main(argc, argv);
+}
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/glf.h b/ext/samtools-0.1.7a_getUnique-0.1.3/glf.h
new file mode 100644
index 0000000..12e5400
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/glf.h
@@ -0,0 +1,56 @@
+#ifndef GLF_H_
+#define GLF_H_
+
+typedef struct {
+	unsigned char ref_base:4, dummy:4; /** "XACMGRSVTWYHKDBN"[ref_base] gives the reference base */
+	unsigned char max_mapQ; /** maximum mapping quality */
+	unsigned char lk[10];   /** log likelihood ratio, capped at 255 */
+	unsigned min_lk:8, depth:24; /** minimum lk capped at 255, and the number of mapped reads */
+} glf1_t;
+
+#include <stdint.h>
+#include "bgzf.h"
+typedef BGZF *glfFile;
+
+#define GLF3_RTYPE_END   0
+#define GLF3_RTYPE_SUB   1
+#define GLF3_RTYPE_INDEL 2
+
+typedef struct {
+	uint8_t ref_base:4, rtype:4; /** "XACMGRSVTWYHKDBN"[ref_base] gives the reference base */
+	uint8_t rms_mapQ; /** RMS mapping quality */
+	uint8_t lk[10];   /** log likelihood ratio, capped at 255 */
+	uint32_t min_lk:8, depth:24; /** minimum lk capped at 255, and the number of mapped reads */
+	int32_t offset; /** the first base in a chromosome has offset zero. */
+	// for indel (lkHom1, lkHom2 and lkHet are the first three elements in lk[10])
+	int16_t indel_len[2];
+	int32_t max_len; // maximum indel len; will be modified by glf3_read1()
+	char *indel_seq[2];
+} glf3_t;
+
+typedef struct {
+	int32_t l_text;
+	uint8_t *text;
+} glf3_header_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define glf3_init1() ((glf3_t*)calloc(1, sizeof(glf3_t)))
+#define glf3_destroy1(g3) do { free((g3)->indel_seq[0]); free((g3)->indel_seq[1]); free(g3); } while (0)
+
+	glf3_header_t *glf3_header_init();
+	glf3_header_t *glf3_header_read(glfFile fp);
+	void glf3_header_write(glfFile fp, const glf3_header_t *h);
+	void glf3_header_destroy(glf3_header_t *h);
+	char *glf3_ref_read(glfFile fp, int *len);
+	void glf3_ref_write(glfFile fp, const char *name, int len);
+	int glf3_write1(glfFile fp, const glf3_t *g3);
+	int glf3_read1(glfFile fp, glf3_t *g3);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/kaln.c b/ext/samtools-0.1.7a_getUnique-0.1.3/kaln.c
new file mode 100644
index 0000000..9fa40d0
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/kaln.c
@@ -0,0 +1,370 @@
+/* The MIT License
+
+   Copyright (c) 2003-2006, 2008, 2009, by Heng Li <lh3lh3@gmail.com>
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include "kaln.h"
+
+#define FROM_M 0
+#define FROM_I 1
+#define FROM_D 2
+
+typedef struct {
+	int i, j;
+	unsigned char ctype;
+} path_t;
+
+int aln_sm_blosum62[] = {
+/*	 A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  *  X */
+	 4,-1,-2,-2, 0,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0,-4, 0,
+	-1, 5, 0,-2,-3, 1, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3,-4,-1,
+	-2, 0, 6, 1,-3, 0, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3,-4,-1,
+	-2,-2, 1, 6,-3, 0, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3,-4,-1,
+	 0,-3,-3,-3, 9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-4,-2,
+	-1, 1, 0, 0,-3, 5, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2,-4,-1,
+	-1, 0, 0, 2,-4, 2, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2,-4,-1,
+	 0,-2, 0,-1,-3,-2,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3,-4,-1,
+	-2, 0, 1,-1,-3, 0, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3,-4,-1,
+	-1,-3,-3,-3,-1,-3,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3,-4,-1,
+	-1,-2,-3,-4,-1,-2,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1,-4,-1,
+	-1, 2, 0,-1,-3, 1, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2,-4,-1,
+	-1,-1,-2,-3,-1, 0,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1,-4,-1,
+	-2,-3,-3,-3,-2,-3,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1,-4,-1,
+	-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2,-4,-2,
+	 1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2,-4, 0,
+	 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0,-4, 0,
+	-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3,-4,-2,
+	-2,-2,-2,-3,-2,-1,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1,-4,-1,
+	 0,-3,-3,-3,-1,-2,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4,-4,-1,
+	-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4, 1,-4,
+	 0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2, 0, 0,-2,-1,-1,-4,-1
+};
+
+int aln_sm_blast[] = {
+	1, -3, -3, -3, -2,
+	-3, 1, -3, -3, -2,
+	-3, -3, 1, -3, -2,
+	-3, -3, -3, 1, -2,
+	-2, -2, -2, -2, -2
+};
+
+ka_param_t ka_param_blast = {  5,  2,  2, aln_sm_blast, 5, 50 };
+ka_param_t ka_param_aa2aa = { 10,  2,  2, aln_sm_blosum62, 22, 50 };
+
+static uint32_t *ka_path2cigar32(const path_t *path, int path_len, int *n_cigar)
+{
+	int i, n;
+	uint32_t *cigar;
+	unsigned char last_type;
+
+	if (path_len == 0 || path == 0) {
+		*n_cigar = 0;
+		return 0;
+	}
+
+	last_type = path->ctype;
+	for (i = n = 1; i < path_len; ++i) {
+		if (last_type != path[i].ctype) ++n;
+		last_type = path[i].ctype;
+	}
+	*n_cigar = n;
+	cigar = (uint32_t*)calloc(*n_cigar, 4);
+
+	cigar[0] = 1u << 4 | path[path_len-1].ctype;
+	last_type = path[path_len-1].ctype;
+	for (i = path_len - 2, n = 0; i >= 0; --i) {
+		if (path[i].ctype == last_type) cigar[n] += 1u << 4;
+		else {
+			cigar[++n] = 1u << 4 | path[i].ctype;
+			last_type = path[i].ctype;
+		}
+	}
+
+	return cigar;
+}
+
+/***************************/
+/* START OF common_align.c */
+/***************************/
+
+#define SET_INF(s) (s).M = (s).I = (s).D = MINOR_INF;
+
+#define set_M(MM, cur, p, sc)							\
+{														\
+	if ((p)->M >= (p)->I) {								\
+		if ((p)->M >= (p)->D) {							\
+			(MM) = (p)->M + (sc); (cur)->Mt = FROM_M;	\
+		} else {										\
+			(MM) = (p)->D + (sc); (cur)->Mt = FROM_D;	\
+		}												\
+	} else {											\
+		if ((p)->I > (p)->D) {							\
+			(MM) = (p)->I + (sc); (cur)->Mt = FROM_I;	\
+		} else {										\
+			(MM) = (p)->D + (sc); (cur)->Mt = FROM_D;	\
+		}												\
+	}													\
+}
+#define set_I(II, cur, p)								\
+{														\
+	if ((p)->M - gap_open > (p)->I) {					\
+		(cur)->It = FROM_M;								\
+		(II) = (p)->M - gap_open - gap_ext;				\
+	} else {											\
+		(cur)->It = FROM_I;								\
+		(II) = (p)->I - gap_ext;						\
+	}													\
+}
+#define set_end_I(II, cur, p)							\
+{														\
+	if (gap_end >= 0) {									\
+		if ((p)->M - gap_open > (p)->I) {				\
+			(cur)->It = FROM_M;							\
+			(II) = (p)->M - gap_open - gap_end;			\
+		} else {										\
+			(cur)->It = FROM_I;							\
+			(II) = (p)->I - gap_end;					\
+		}												\
+	} else set_I(II, cur, p);							\
+}
+#define set_D(DD, cur, p)								\
+{														\
+	if ((p)->M - gap_open > (p)->D) {					\
+		(cur)->Dt = FROM_M;								\
+		(DD) = (p)->M - gap_open - gap_ext;				\
+	} else {											\
+		(cur)->Dt = FROM_D;								\
+		(DD) = (p)->D - gap_ext;						\
+	}													\
+}
+#define set_end_D(DD, cur, p)							\
+{														\
+	if (gap_end >= 0) {									\
+		if ((p)->M - gap_open > (p)->D) {				\
+			(cur)->Dt = FROM_M;							\
+			(DD) = (p)->M - gap_open - gap_end;			\
+		} else {										\
+			(cur)->Dt = FROM_D;							\
+			(DD) = (p)->D - gap_end;					\
+		}												\
+	} else set_D(DD, cur, p);							\
+}
+
+typedef struct {
+	uint8_t Mt:3, It:2, Dt:2;
+} dpcell_t;
+
+typedef struct {
+	int M, I, D;
+} dpscore_t;
+
+/***************************
+ * banded global alignment *
+ ***************************/
+uint32_t *ka_global_core(uint8_t *seq1, int len1, uint8_t *seq2, int len2, const ka_param_t *ap, int *_score, int *n_cigar)
+{
+	int i, j;
+	dpcell_t **dpcell, *q;
+	dpscore_t *curr, *last, *s;
+	int b1, b2, tmp_end;
+	int *mat, end, max = 0;
+	uint8_t type, ctype;
+	uint32_t *cigar = 0;
+
+	int gap_open, gap_ext, gap_end, b;
+	int *score_matrix, N_MATRIX_ROW;
+
+	/* initialize some align-related parameters. just for compatibility */
+	gap_open = ap->gap_open;
+	gap_ext = ap->gap_ext;
+	gap_end = ap->gap_end;
+	b = ap->band_width;
+	score_matrix = ap->matrix;
+	N_MATRIX_ROW = ap->row;
+
+	*n_cigar = 0;
+	if (len1 == 0 || len2 == 0) return 0;
+
+	/* calculate b1 and b2 */
+	if (len1 > len2) {
+		b1 = len1 - len2 + b;
+		b2 = b;
+	} else {
+		b1 = b;
+		b2 = len2 - len1 + b;
+	}
+	if (b1 > len1) b1 = len1;
+	if (b2 > len2) b2 = len2;
+	--seq1; --seq2;
+
+	/* allocate memory */
+	end = (b1 + b2 <= len1)? (b1 + b2 + 1) : (len1 + 1);
+	dpcell = (dpcell_t**)malloc(sizeof(dpcell_t*) * (len2 + 1));
+	for (j = 0; j <= len2; ++j)
+		dpcell[j] = (dpcell_t*)malloc(sizeof(dpcell_t) * end);
+	for (j = b2 + 1; j <= len2; ++j)
+		dpcell[j] -= j - b2;
+	curr = (dpscore_t*)malloc(sizeof(dpscore_t) * (len1 + 1));
+	last = (dpscore_t*)malloc(sizeof(dpscore_t) * (len1 + 1));
+	
+	/* set first row */
+	SET_INF(*curr); curr->M = 0;
+	for (i = 1, s = curr + 1; i < b1; ++i, ++s) {
+		SET_INF(*s);
+		set_end_D(s->D, dpcell[0] + i, s - 1);
+	}
+	s = curr; curr = last; last = s;
+
+	/* core dynamic programming, part 1 */
+	tmp_end = (b2 < len2)? b2 : len2 - 1;
+	for (j = 1; j <= tmp_end; ++j) {
+		q = dpcell[j]; s = curr; SET_INF(*s);
+		set_end_I(s->I, q, last);
+		end = (j + b1 <= len1 + 1)? (j + b1 - 1) : len1;
+		mat = score_matrix + seq2[j] * N_MATRIX_ROW;
+		++s; ++q;
+		for (i = 1; i != end; ++i, ++s, ++q) {
+			set_M(s->M, q, last + i - 1, mat[seq1[i]]); /* this will change s->M ! */
+			set_I(s->I, q, last + i);
+			set_D(s->D, q, s - 1);
+		}
+		set_M(s->M, q, last + i - 1, mat[seq1[i]]);
+		set_D(s->D, q, s - 1);
+		if (j + b1 - 1 > len1) { /* bug fixed, 040227 */
+			set_end_I(s->I, q, last + i);
+		} else s->I = MINOR_INF;
+		s = curr; curr = last; last = s;
+	}
+	/* last row for part 1, use set_end_D() instead of set_D() */
+	if (j == len2 && b2 != len2 - 1) {
+		q = dpcell[j]; s = curr; SET_INF(*s);
+		set_end_I(s->I, q, last);
+		end = (j + b1 <= len1 + 1)? (j + b1 - 1) : len1;
+		mat = score_matrix + seq2[j] * N_MATRIX_ROW;
+		++s; ++q;
+		for (i = 1; i != end; ++i, ++s, ++q) {
+			set_M(s->M, q, last + i - 1, mat[seq1[i]]); /* this will change s->M ! */
+			set_I(s->I, q, last + i);
+			set_end_D(s->D, q, s - 1);
+		}
+		set_M(s->M, q, last + i - 1, mat[seq1[i]]);
+		set_end_D(s->D, q, s - 1);
+		if (j + b1 - 1 > len1) { /* bug fixed, 040227 */
+			set_end_I(s->I, q, last + i);
+		} else s->I = MINOR_INF;
+		s = curr; curr = last; last = s;
+		++j;
+	}
+
+	/* core dynamic programming, part 2 */
+	for (; j <= len2 - b2 + 1; ++j) {
+		SET_INF(curr[j - b2]);
+		mat = score_matrix + seq2[j] * N_MATRIX_ROW;
+		end = j + b1 - 1;
+		for (i = j - b2 + 1, q = dpcell[j] + i, s = curr + i; i != end; ++i, ++s, ++q) {
+			set_M(s->M, q, last + i - 1, mat[seq1[i]]);
+			set_I(s->I, q, last + i);
+			set_D(s->D, q, s - 1);
+		}
+		set_M(s->M, q, last + i - 1, mat[seq1[i]]);
+		set_D(s->D, q, s - 1);
+		s->I = MINOR_INF;
+		s = curr; curr = last; last = s;
+	}
+
+	/* core dynamic programming, part 3 */
+	for (; j < len2; ++j) {
+		SET_INF(curr[j - b2]);
+		mat = score_matrix + seq2[j] * N_MATRIX_ROW;
+		for (i = j - b2 + 1, q = dpcell[j] + i, s = curr + i; i < len1; ++i, ++s, ++q) {
+			set_M(s->M, q, last + i - 1, mat[seq1[i]]);
+			set_I(s->I, q, last + i);
+			set_D(s->D, q, s - 1);
+		}
+		set_M(s->M, q, last + len1 - 1, mat[seq1[i]]);
+		set_end_I(s->I, q, last + i);
+		set_D(s->D, q, s - 1);
+		s = curr; curr = last; last = s;
+	}
+	/* last row */
+	if (j == len2) {
+		SET_INF(curr[j - b2]);
+		mat = score_matrix + seq2[j] * N_MATRIX_ROW;
+		for (i = j - b2 + 1, q = dpcell[j] + i, s = curr + i; i < len1; ++i, ++s, ++q) {
+			set_M(s->M, q, last + i - 1, mat[seq1[i]]);
+			set_I(s->I, q, last + i);
+			set_end_D(s->D, q, s - 1);
+		}
+		set_M(s->M, q, last + len1 - 1, mat[seq1[i]]);
+		set_end_I(s->I, q, last + i);
+		set_end_D(s->D, q, s - 1);
+		s = curr; curr = last; last = s;
+	}
+
+	*_score = last[len1].M;
+	if (n_cigar) { /* backtrace */
+		path_t *p, *path = (path_t*)malloc(sizeof(path_t) * (len1 + len2 + 2));
+		i = len1; j = len2;
+		q = dpcell[j] + i;
+		s = last + len1;
+		max = s->M; type = q->Mt; ctype = FROM_M;
+		if (s->I > max) { max = s->I; type = q->It; ctype = FROM_I; }
+		if (s->D > max) { max = s->D; type = q->Dt; ctype = FROM_D; }
+
+		p = path;
+		p->ctype = ctype; p->i = i; p->j = j; /* bug fixed 040408 */
+		++p;
+		do {
+			switch (ctype) {
+			case FROM_M: --i; --j; break;
+			case FROM_I: --j; break;
+			case FROM_D: --i; break;
+			}
+			q = dpcell[j] + i;
+			ctype = type;
+			switch (type) {
+			case FROM_M: type = q->Mt; break;
+			case FROM_I: type = q->It; break;
+			case FROM_D: type = q->Dt; break;
+			}
+			p->ctype = ctype; p->i = i; p->j = j;
+			++p;
+		} while (i || j);
+		cigar = ka_path2cigar32(path, p - path - 1, n_cigar);
+		free(path);
+	}
+
+	/* free memory */
+	for (j = b2 + 1; j <= len2; ++j)
+		dpcell[j] += j - b2;
+	for (j = 0; j <= len2; ++j)
+		free(dpcell[j]);
+	free(dpcell);
+	free(curr); free(last);
+
+	return cigar;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/kaln.h b/ext/samtools-0.1.7a_getUnique-0.1.3/kaln.h
new file mode 100644
index 0000000..b04d8cc
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/kaln.h
@@ -0,0 +1,55 @@
+/* The MIT License
+
+   Copyright (c) 2003-2006, 2008, 2009 by Heng Li <lh3@live.co.uk>
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+#ifndef LH3_KALN_H_
+#define LH3_KALN_H_
+
+#include <stdint.h>
+
+#define MINOR_INF -1073741823
+
+typedef struct {
+	int gap_open;
+	int gap_ext;
+	int gap_end;
+
+	int *matrix;
+	int row;
+	int band_width;
+} ka_param_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	uint32_t *ka_global_core(uint8_t *seq1, int len1, uint8_t *seq2, int len2, const ka_param_t *ap, int *_score, int *n_cigar);
+
+#ifdef __cplusplus
+}
+#endif
+
+extern ka_param_t ka_param_blast; /* = {  5,  2,  2, aln_sm_blast, 5, 50 }; */
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/khash.h b/ext/samtools-0.1.7a_getUnique-0.1.3/khash.h
new file mode 100644
index 0000000..1d583ef
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/khash.h
@@ -0,0 +1,486 @@
+/* The MIT License
+
+   Copyright (c) 2008 Genome Research Ltd (GRL).
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Contact: Heng Li <lh3@sanger.ac.uk> */
+
+/*
+  An example:
+
+#include "khash.h"
+KHASH_MAP_INIT_INT(32, char)
+int main() {
+	int ret, is_missing;
+	khiter_t k;
+	khash_t(32) *h = kh_init(32);
+	k = kh_put(32, h, 5, &ret);
+	if (!ret) kh_del(32, h, k);
+	kh_value(h, k) = 10;
+	k = kh_get(32, h, 10);
+	is_missing = (k == kh_end(h));
+	k = kh_get(32, h, 5);
+	kh_del(32, h, k);
+	for (k = kh_begin(h); k != kh_end(h); ++k)
+		if (kh_exist(h, k)) kh_value(h, k) = 1;
+	kh_destroy(32, h);
+	return 0;
+}
+*/
+
+/*
+  2008-09-19 (0.2.3):
+
+	* Corrected the example
+	* Improved interfaces
+
+  2008-09-11 (0.2.2):
+
+	* Improved speed a little in kh_put()
+
+  2008-09-10 (0.2.1):
+
+	* Added kh_clear()
+	* Fixed a compiling error
+
+  2008-09-02 (0.2.0):
+
+	* Changed to token concatenation which increases flexibility.
+
+  2008-08-31 (0.1.2):
+
+	* Fixed a bug in kh_get(), which has not been tested previously.
+
+  2008-08-31 (0.1.1):
+
+	* Added destructor
+*/
+
+
+#ifndef __AC_KHASH_H
+#define __AC_KHASH_H
+
+/*!
+  @header
+
+  Generic hash table library.
+
+  @copyright Heng Li
+ */
+
+#define AC_VERSION_KHASH_H "0.2.2"
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+typedef uint32_t khint_t;
+typedef khint_t khiter_t;
+
+#define __ac_HASH_PRIME_SIZE 32
+static const uint32_t __ac_prime_list[__ac_HASH_PRIME_SIZE] =
+{
+  0ul,          3ul,          11ul,         23ul,         53ul,
+  97ul,         193ul,        389ul,        769ul,        1543ul,
+  3079ul,       6151ul,       12289ul,      24593ul,      49157ul,
+  98317ul,      196613ul,     393241ul,     786433ul,     1572869ul,
+  3145739ul,    6291469ul,    12582917ul,   25165843ul,   50331653ul,
+  100663319ul,  201326611ul,  402653189ul,  805306457ul,  1610612741ul,
+  3221225473ul, 4294967291ul
+};
+
+#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)
+#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)
+#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)
+#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))
+#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))
+#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))
+#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))
+
+static const double __ac_HASH_UPPER = 0.77;
+
+#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \
+	typedef struct {													\
+		khint_t n_buckets, size, n_occupied, upper_bound;				\
+		uint32_t *flags;												\
+		khkey_t *keys;													\
+		khval_t *vals;													\
+	} kh_##name##_t;													\
+	static inline kh_##name##_t *kh_init_##name() {						\
+		return (kh_##name##_t*)calloc(1, sizeof(kh_##name##_t));		\
+	}																	\
+	static inline void kh_destroy_##name(kh_##name##_t *h)				\
+	{																	\
+		if (h) {														\
+			free(h->keys); free(h->flags);								\
+			free(h->vals);												\
+			free(h);													\
+		}																\
+	}																	\
+	static inline void kh_clear_##name(kh_##name##_t *h)				\
+	{																	\
+		if (h && h->flags) {											\
+			memset(h->flags, 0xaa, ((h->n_buckets>>4) + 1) * sizeof(uint32_t)); \
+			h->size = h->n_occupied = 0;								\
+		}																\
+	}																	\
+	static inline khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) \
+	{																	\
+		if (h->n_buckets) {												\
+			khint_t inc, k, i, last;									\
+			k = __hash_func(key); i = k % h->n_buckets;					\
+			inc = 1 + k % (h->n_buckets - 1); last = i;					\
+			while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
+				if (i + inc >= h->n_buckets) i = i + inc - h->n_buckets; \
+				else i += inc;											\
+				if (i == last) return h->n_buckets;						\
+			}															\
+			return __ac_iseither(h->flags, i)? h->n_buckets : i;		\
+		} else return 0;												\
+	}																	\
+	static inline void kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) \
+	{																	\
+		uint32_t *new_flags = 0;										\
+		khint_t j = 1;													\
+		{																\
+			khint_t t = __ac_HASH_PRIME_SIZE - 1;						\
+			while (__ac_prime_list[t] > new_n_buckets) --t;				\
+			new_n_buckets = __ac_prime_list[t+1];						\
+			if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	\
+			else {														\
+				new_flags = (uint32_t*)malloc(((new_n_buckets>>4) + 1) * sizeof(uint32_t));	\
+				memset(new_flags, 0xaa, ((new_n_buckets>>4) + 1) * sizeof(uint32_t)); \
+				if (h->n_buckets < new_n_buckets) {						\
+					h->keys = (khkey_t*)realloc(h->keys, new_n_buckets * sizeof(khkey_t)); \
+					if (kh_is_map)										\
+						h->vals = (khval_t*)realloc(h->vals, new_n_buckets * sizeof(khval_t)); \
+				}														\
+			}															\
+		}																\
+		if (j) {														\
+			for (j = 0; j != h->n_buckets; ++j) {						\
+				if (__ac_iseither(h->flags, j) == 0) {					\
+					khkey_t key = h->keys[j];							\
+					khval_t val;										\
+					if (kh_is_map) val = h->vals[j];					\
+					__ac_set_isdel_true(h->flags, j);					\
+					while (1) {											\
+						khint_t inc, k, i;								\
+						k = __hash_func(key);							\
+						i = k % new_n_buckets;							\
+						inc = 1 + k % (new_n_buckets - 1);				\
+						while (!__ac_isempty(new_flags, i)) {			\
+							if (i + inc >= new_n_buckets) i = i + inc - new_n_buckets; \
+							else i += inc;								\
+						}												\
+						__ac_set_isempty_false(new_flags, i);			\
+						if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { \
+							{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \
+							if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \
+							__ac_set_isdel_true(h->flags, i);			\
+						} else {										\
+							h->keys[i] = key;							\
+							if (kh_is_map) h->vals[i] = val;			\
+							break;										\
+						}												\
+					}													\
+				}														\
+			}															\
+			if (h->n_buckets > new_n_buckets) {							\
+				h->keys = (khkey_t*)realloc(h->keys, new_n_buckets * sizeof(khkey_t)); \
+				if (kh_is_map)											\
+					h->vals = (khval_t*)realloc(h->vals, new_n_buckets * sizeof(khval_t)); \
+			}															\
+			free(h->flags);												\
+			h->flags = new_flags;										\
+			h->n_buckets = new_n_buckets;								\
+			h->n_occupied = h->size;									\
+			h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \
+		}																\
+	}																	\
+	static inline khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) \
+	{																	\
+		khint_t x;														\
+		if (h->n_occupied >= h->upper_bound) {							\
+			if (h->n_buckets > (h->size<<1)) kh_resize_##name(h, h->n_buckets - 1); \
+			else kh_resize_##name(h, h->n_buckets + 1);					\
+		}																\
+		{																\
+			khint_t inc, k, i, site, last;								\
+			x = site = h->n_buckets; k = __hash_func(key); i = k % h->n_buckets; \
+			if (__ac_isempty(h->flags, i)) x = i;						\
+			else {														\
+				inc = 1 + k % (h->n_buckets - 1); last = i;				\
+				while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
+					if (__ac_isdel(h->flags, i)) site = i;				\
+					if (i + inc >= h->n_buckets) i = i + inc - h->n_buckets; \
+					else i += inc;										\
+					if (i == last) { x = site; break; }					\
+				}														\
+				if (x == h->n_buckets) {								\
+					if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \
+					else x = i;											\
+				}														\
+			}															\
+		}																\
+		if (__ac_isempty(h->flags, x)) {								\
+			h->keys[x] = key;											\
+			__ac_set_isboth_false(h->flags, x);							\
+			++h->size; ++h->n_occupied;									\
+			*ret = 1;													\
+		} else if (__ac_isdel(h->flags, x)) {							\
+			h->keys[x] = key;											\
+			__ac_set_isboth_false(h->flags, x);							\
+			++h->size;													\
+			*ret = 2;													\
+		} else *ret = 0;												\
+		return x;														\
+	}																	\
+	static inline void kh_del_##name(kh_##name##_t *h, khint_t x)		\
+	{																	\
+		if (x != h->n_buckets && !__ac_iseither(h->flags, x)) {			\
+			__ac_set_isdel_true(h->flags, x);							\
+			--h->size;													\
+		}																\
+	}
+
+/* --- BEGIN OF HASH FUNCTIONS --- */
+
+/*! @function
+  @abstract     Integer hash function
+  @param  key   The integer [uint32_t]
+  @return       The hash value [khint_t]
+ */
+#define kh_int_hash_func(key) (uint32_t)(key)
+/*! @function
+  @abstract     Integer comparison function
+ */
+#define kh_int_hash_equal(a, b) ((a) == (b))
+/*! @function
+  @abstract     64-bit integer hash function
+  @param  key   The integer [uint64_t]
+  @return       The hash value [khint_t]
+ */
+#define kh_int64_hash_func(key) (uint32_t)((key)>>33^(key)^(key)<<11)
+/*! @function
+  @abstract     64-bit integer comparison function
+ */
+#define kh_int64_hash_equal(a, b) ((a) == (b))
+/*! @function
+  @abstract     const char* hash function
+  @param  s     Pointer to a null terminated string
+  @return       The hash value
+ */
+static inline khint_t __ac_X31_hash_string(const char *s)
+{
+	khint_t h = *s;
+	if (h) for (++s ; *s; ++s) h = (h << 5) - h + *s;
+	return h;
+}
+/*! @function
+  @abstract     Another interface to const char* hash function
+  @param  key   Pointer to a null terminated string [const char*]
+  @return       The hash value [khint_t]
+ */
+#define kh_str_hash_func(key) __ac_X31_hash_string(key)
+/*! @function
+  @abstract     Const char* comparison function
+ */
+#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)
+
+/* --- END OF HASH FUNCTIONS --- */
+
+/* Other necessary macros... */
+
+/*!
+  @abstract Type of the hash table.
+  @param  name  Name of the hash table [symbol]
+ */
+#define khash_t(name) kh_##name##_t
+
+/*! @function
+  @abstract     Initiate a hash table.
+  @param  name  Name of the hash table [symbol]
+  @return       Pointer to the hash table [khash_t(name)*]
+ */
+#define kh_init(name) kh_init_##name()
+
+/*! @function
+  @abstract     Destroy a hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+ */
+#define kh_destroy(name, h) kh_destroy_##name(h)
+
+/*! @function
+  @abstract     Reset a hash table without deallocating memory.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+ */
+#define kh_clear(name, h) kh_clear_##name(h)
+
+/*! @function
+  @abstract     Resize a hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  s     New size [khint_t]
+ */
+#define kh_resize(name, h, s) kh_resize_##name(h, s)
+
+/*! @function
+  @abstract     Insert a key to the hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  k     Key [type of keys]
+  @param  r     Extra return code: 0 if the key is present in the hash table;
+                1 if the bucket is empty (never used); 2 if the element in
+				the bucket has been deleted [int*]
+  @return       Iterator to the inserted element [khint_t]
+ */
+#define kh_put(name, h, k, r) kh_put_##name(h, k, r)
+
+/*! @function
+  @abstract     Retrieve a key from the hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  k     Key [type of keys]
+  @return       Iterator to the found element, or kh_end(h) is the element is absent [khint_t]
+ */
+#define kh_get(name, h, k) kh_get_##name(h, k)
+
+/*! @function
+  @abstract     Remove a key from the hash table.
+  @param  name  Name of the hash table [symbol]
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  k     Iterator to the element to be deleted [khint_t]
+ */
+#define kh_del(name, h, k) kh_del_##name(h, k)
+
+
+/*! @function
+  @abstract     Test whether a bucket contains data.
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  x     Iterator to the bucket [khint_t]
+  @return       1 if containing data; 0 otherwise [int]
+ */
+#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))
+
+/*! @function
+  @abstract     Get key given an iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  x     Iterator to the bucket [khint_t]
+  @return       Key [type of keys]
+ */
+#define kh_key(h, x) ((h)->keys[x])
+
+/*! @function
+  @abstract     Get value given an iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @param  x     Iterator to the bucket [khint_t]
+  @return       Value [type of values]
+  @discussion   For hash sets, calling this results in segfault.
+ */
+#define kh_val(h, x) ((h)->vals[x])
+
+/*! @function
+  @abstract     Alias of kh_val()
+ */
+#define kh_value(h, x) ((h)->vals[x])
+
+/*! @function
+  @abstract     Get the start iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       The start iterator [khint_t]
+ */
+#define kh_begin(h) (khint_t)(0)
+
+/*! @function
+  @abstract     Get the end iterator
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       The end iterator [khint_t]
+ */
+#define kh_end(h) ((h)->n_buckets)
+
+/*! @function
+  @abstract     Get the number of elements in the hash table
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       Number of elements in the hash table [khint_t]
+ */
+#define kh_size(h) ((h)->size)
+
+/*! @function
+  @abstract     Get the number of buckets in the hash table
+  @param  h     Pointer to the hash table [khash_t(name)*]
+  @return       Number of buckets in the hash table [khint_t]
+ */
+#define kh_n_buckets(h) ((h)->n_buckets)
+
+/* More conenient interfaces */
+
+/*! @function
+  @abstract     Instantiate a hash set containing integer keys
+  @param  name  Name of the hash table [symbol]
+ */
+#define KHASH_SET_INIT_INT(name)										\
+	KHASH_INIT(name, uint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing integer keys
+  @param  name  Name of the hash table [symbol]
+  @param  khval_t  Type of values [type]
+ */
+#define KHASH_MAP_INIT_INT(name, khval_t)								\
+	KHASH_INIT(name, uint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing 64-bit integer keys
+  @param  name  Name of the hash table [symbol]
+ */
+#define KHASH_SET_INIT_INT64(name)										\
+	KHASH_INIT(name, uint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing 64-bit integer keys
+  @param  name  Name of the hash table [symbol]
+  @param  khval_t  Type of values [type]
+ */
+#define KHASH_MAP_INIT_INT64(name, khval_t)								\
+	KHASH_INIT(name, uint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)
+
+typedef const char *kh_cstr_t;
+/*! @function
+  @abstract     Instantiate a hash map containing const char* keys
+  @param  name  Name of the hash table [symbol]
+ */
+#define KHASH_SET_INIT_STR(name)										\
+	KHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)
+
+/*! @function
+  @abstract     Instantiate a hash map containing const char* keys
+  @param  name  Name of the hash table [symbol]
+  @param  khval_t  Type of values [type]
+ */
+#define KHASH_MAP_INIT_STR(name, khval_t)								\
+	KHASH_INIT(name, kh_cstr_t, khval_t, 1, kh_str_hash_func, kh_str_hash_equal)
+
+#endif /* __AC_KHASH_H */
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/klist.h b/ext/samtools-0.1.7a_getUnique-0.1.3/klist.h
new file mode 100644
index 0000000..2f17016
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/klist.h
@@ -0,0 +1,96 @@
+#ifndef _LH3_KLIST_H
+#define _LH3_KLIST_H
+
+#include <stdlib.h>
+
+#define KMEMPOOL_INIT(name, kmptype_t, kmpfree_f)						\
+	typedef struct {													\
+		size_t cnt, n, max;												\
+		kmptype_t **buf;												\
+	} kmp_##name##_t;													\
+	static inline kmp_##name##_t *kmp_init_##name() {					\
+		return calloc(1, sizeof(kmp_##name##_t));						\
+	}																	\
+	static inline void kmp_destroy_##name(kmp_##name##_t *mp) {			\
+		size_t k;														\
+		for (k = 0; k < mp->n; ++k) {									\
+			kmpfree_f(mp->buf[k]); free(mp->buf[k]);					\
+		}																\
+		free(mp->buf); free(mp);										\
+	}																	\
+	static inline kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) {		\
+		++mp->cnt;														\
+		if (mp->n == 0) return calloc(1, sizeof(kmptype_t));			\
+		return mp->buf[--mp->n];										\
+	}																	\
+	static inline void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) { \
+		--mp->cnt;														\
+		if (mp->n == mp->max) {											\
+			mp->max = mp->max? mp->max<<1 : 16;							\
+			mp->buf = realloc(mp->buf, sizeof(void*) * mp->max);		\
+		}																\
+		mp->buf[mp->n++] = p;											\
+	}
+
+#define kmempool_t(name) kmp_##name##_t
+#define kmp_init(name) kmp_init_##name()
+#define kmp_destroy(name, mp) kmp_destroy_##name(mp)
+#define kmp_alloc(name, mp) kmp_alloc_##name(mp)
+#define kmp_free(name, mp, p) kmp_free_##name(mp, p)
+
+#define KLIST_INIT(name, kltype_t, kmpfree_t)							\
+	struct __kl1_##name {												\
+		kltype_t data;													\
+		struct __kl1_##name *next;										\
+	};																	\
+	typedef struct __kl1_##name kl1_##name;								\
+	KMEMPOOL_INIT(name, kl1_##name, kmpfree_t)							\
+	typedef struct {													\
+		kl1_##name *head, *tail;										\
+		kmp_##name##_t *mp;												\
+		size_t size;													\
+	} kl_##name##_t;													\
+	static inline kl_##name##_t *kl_init_##name() {						\
+		kl_##name##_t *kl = calloc(1, sizeof(kl_##name##_t));			\
+		kl->mp = kmp_init(name);										\
+		kl->head = kl->tail = kmp_alloc(name, kl->mp);					\
+		kl->head->next = 0;												\
+		return kl;														\
+	}																	\
+	static inline void kl_destroy_##name(kl_##name##_t *kl) {			\
+		kl1_##name *p;													\
+		for (p = kl->head; p != kl->tail; p = p->next)					\
+			kmp_free(name, kl->mp, p);									\
+		kmp_free(name, kl->mp, p);										\
+		kmp_destroy(name, kl->mp);										\
+		free(kl);														\
+	}																	\
+	static inline kltype_t *kl_pushp_##name(kl_##name##_t *kl) {		\
+		kl1_##name *q, *p = kmp_alloc(name, kl->mp);					\
+		q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p;	\
+		++kl->size;														\
+		return &q->data;												\
+	}																	\
+	static inline int kl_shift_##name(kl_##name##_t *kl, kltype_t *d) { \
+		kl1_##name *p;													\
+		if (kl->head->next == 0) return -1;								\
+		--kl->size;														\
+		p = kl->head; kl->head = kl->head->next;						\
+		if (d) *d = p->data;											\
+		kmp_free(name, kl->mp, p);										\
+		return 0;														\
+	}
+
+#define kliter_t(name) kl1_##name
+#define klist_t(name) kl_##name##_t
+#define kl_val(iter) ((iter)->data)
+#define kl_next(iter) ((iter)->next)
+#define kl_begin(kl) ((kl)->head)
+#define kl_end(kl) ((kl)->tail)
+
+#define kl_init(name) kl_init_##name()
+#define kl_destroy(name, kl) kl_destroy_##name(kl)
+#define kl_pushp(name, kl) kl_pushp_##name(kl)
+#define kl_shift(name, kl, d) kl_shift_##name(kl, d)
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/knetfile.c b/ext/samtools-0.1.7a_getUnique-0.1.3/knetfile.c
new file mode 100644
index 0000000..994babb
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/knetfile.c
@@ -0,0 +1,632 @@
+/* The MIT License
+
+   Copyright (c) 2008 Genome Research Ltd (GRL).
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Contact: Heng Li <lh3@sanger.ac.uk> */
+
+/* Probably I will not do socket programming in the next few years and
+   therefore I decide to heavily annotate this file, for Linux and
+   Windows as well.  -lh3 */
+
+#include <time.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#ifdef _WIN32
+#include <winsock.h>
+#else
+#include <netdb.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#endif
+
+#include "knetfile.h"
+
+/* In winsock.h, the type of a socket is SOCKET, which is: "typedef
+ * u_int SOCKET". An invalid SOCKET is: "(SOCKET)(~0)", or signed
+ * integer -1. In knetfile.c, I use "int" for socket type
+ * throughout. This should be improved to avoid confusion.
+ *
+ * In Linux/Mac, recv() and read() do almost the same thing. You can see
+ * in the header file that netread() is simply an alias of read(). In
+ * Windows, however, they are different and using recv() is mandatory.
+ */
+
+/* This function tests if the file handler is ready for reading (or
+ * writing if is_read==0). */
+static int socket_wait(int fd, int is_read)
+{
+	fd_set fds, *fdr = 0, *fdw = 0;
+	struct timeval tv;
+	int ret;
+	tv.tv_sec = 5; tv.tv_usec = 0; // 5 seconds time out
+	FD_ZERO(&fds);
+	FD_SET(fd, &fds);
+	if (is_read) fdr = &fds;
+	else fdw = &fds;
+	ret = select(fd+1, fdr, fdw, 0, &tv);
+#ifndef _WIN32
+	if (ret == -1) perror("select");
+#else
+	if (ret == 0)
+		fprintf(stderr, "select time-out\n");
+	else if (ret == SOCKET_ERROR)
+		fprintf(stderr, "select: %d\n", WSAGetLastError());
+#endif
+	return ret;
+}
+
+#ifndef _WIN32
+/* This function does not work with Windows due to the lack of
+ * getaddrinfo() in winsock. It is addapted from an example in "Beej's
+ * Guide to Network Programming" (http://beej.us/guide/bgnet/). */
+static int socket_connect(const char *host, const char *port)
+{
+#define __err_connect(func) do { perror(func); freeaddrinfo(res); return -1; } while (0)
+
+	int on = 1, fd;
+	struct linger lng = { 0, 0 };
+	struct addrinfo hints, *res;
+	memset(&hints, 0, sizeof(struct addrinfo));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	/* In Unix/Mac, getaddrinfo() is the most convenient way to get
+	 * server information. */
+	if (getaddrinfo(host, port, &hints, &res) != 0) __err_connect("getaddrinfo");
+	if ((fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) __err_connect("socket");
+	/* The following two setsockopt() are used by ftplib
+	 * (http://nbpfaus.net/~pfau/ftplib/). I am not sure if they
+	 * necessary. */
+	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) __err_connect("setsockopt");
+	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1) __err_connect("setsockopt");
+	if (connect(fd, res->ai_addr, res->ai_addrlen) != 0) __err_connect("connect");
+	freeaddrinfo(res);
+	return fd;
+}
+#else
+/* MinGW's printf has problem with "%lld" */
+char *int64tostr(char *buf, int64_t x)
+{
+	int cnt;
+	int i = 0;
+	do {
+		buf[i++] = '0' + x % 10;
+		x /= 10;
+	} while (x);
+	buf[i] = 0;
+	for (cnt = i, i = 0; i < cnt/2; ++i) {
+		int c = buf[i]; buf[i] = buf[cnt-i-1]; buf[cnt-i-1] = c;
+	}
+	return buf;
+}
+
+int64_t strtoint64(const char *buf)
+{
+	int64_t x;
+	for (x = 0; *buf != '\0'; ++buf)
+		x = x * 10 + ((int64_t) *buf - 48);
+	return x;
+}
+/* In windows, the first thing is to establish the TCP connection. */
+int knet_win32_init()
+{
+	WSADATA wsaData;
+	return WSAStartup(MAKEWORD(2, 2), &wsaData);
+}
+void knet_win32_destroy()
+{
+	WSACleanup();
+}
+/* A slightly modfied version of the following function also works on
+ * Mac (and presummably Linux). However, this function is not stable on
+ * my Mac. It sometimes works fine but sometimes does not. Therefore for
+ * non-Windows OS, I do not use this one. */
+static SOCKET socket_connect(const char *host, const char *port)
+{
+#define __err_connect(func)										\
+	do {														\
+		fprintf(stderr, "%s: %d\n", func, WSAGetLastError());	\
+		return -1;												\
+	} while (0)
+
+	int on = 1;
+	SOCKET fd;
+	struct linger lng = { 0, 0 };
+	struct sockaddr_in server;
+	struct hostent *hp = 0;
+	// open socket
+	if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) __err_connect("socket");
+	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&on, sizeof(on)) == -1) __err_connect("setsockopt");
+	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char*)&lng, sizeof(lng)) == -1) __err_connect("setsockopt");
+	// get host info
+	if (isalpha(host[0])) hp = gethostbyname(host);
+	else {
+		struct in_addr addr;
+		addr.s_addr = inet_addr(host);
+		hp = gethostbyaddr((char*)&addr, 4, AF_INET);
+	}
+	if (hp == 0) __err_connect("gethost");
+	// connect
+	server.sin_addr.s_addr = *((unsigned long*)hp->h_addr);
+	server.sin_family= AF_INET;
+	server.sin_port = htons(atoi(port));
+	if (connect(fd, (struct sockaddr*)&server, sizeof(server)) != 0) __err_connect("connect");
+	// freehostent(hp); // strangely in MSDN, hp is NOT freed (memory leak?!)
+	return fd;
+}
+#endif
+
+static off_t my_netread(int fd, void *buf, off_t len)
+{
+	off_t rest = len, curr, l = 0;
+	/* recv() and read() may not read the required length of data with
+	 * one call. They have to be called repeatedly. */
+	while (rest) {
+		if (socket_wait(fd, 1) <= 0) break; // socket is not ready for reading
+		curr = netread(fd, buf + l, rest);
+		/* According to the glibc manual, section 13.2, a zero returned
+		 * value indicates end-of-file (EOF), which should mean that
+		 * read() will not return zero if EOF has not been met but data
+		 * are not immediately available. */
+		if (curr == 0) break;
+		l += curr; rest -= curr;
+	}
+	return l;
+}
+
+/*************************
+ * FTP specific routines *
+ *************************/
+
+static int kftp_get_response(knetFile *ftp)
+{
+#ifndef _WIN32
+	unsigned char c;
+#else
+	char c;
+#endif
+	int n = 0;
+	char *p;
+	if (socket_wait(ftp->ctrl_fd, 1) <= 0) return 0;
+	while (netread(ftp->ctrl_fd, &c, 1)) { // FIXME: this is *VERY BAD* for unbuffered I/O
+		//fputc(c, stderr);
+		if (n >= ftp->max_response) {
+			ftp->max_response = ftp->max_response? ftp->max_response<<1 : 256;
+			ftp->response = realloc(ftp->response, ftp->max_response);
+		}
+		ftp->response[n++] = c;
+		if (c == '\n') {
+			if (n >= 4 && isdigit(ftp->response[0]) && isdigit(ftp->response[1]) && isdigit(ftp->response[2])
+				&& ftp->response[3] != '-') break;
+			n = 0;
+			continue;
+		}
+	}
+	if (n < 2) return -1;
+	ftp->response[n-2] = 0;
+	return strtol(ftp->response, &p, 0);
+}
+
+static int kftp_send_cmd(knetFile *ftp, const char *cmd, int is_get)
+{
+	if (socket_wait(ftp->ctrl_fd, 0) <= 0) return -1; // socket is not ready for writing
+	netwrite(ftp->ctrl_fd, cmd, strlen(cmd));
+	return is_get? kftp_get_response(ftp) : 0;
+}
+
+static int kftp_pasv_prep(knetFile *ftp)
+{
+	char *p;
+	int v[6];
+	kftp_send_cmd(ftp, "PASV\r\n", 1);
+	for (p = ftp->response; *p && *p != '('; ++p);
+	if (*p != '(') return -1;
+	++p;
+	sscanf(p, "%d,%d,%d,%d,%d,%d", &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]);
+	memcpy(ftp->pasv_ip, v, 4 * sizeof(int));
+	ftp->pasv_port = (v[4]<<8&0xff00) + v[5];
+	return 0;
+}
+
+
+static int kftp_pasv_connect(knetFile *ftp)
+{
+	char host[80], port[10];
+	if (ftp->pasv_port == 0) {
+		fprintf(stderr, "[kftp_pasv_connect] kftp_pasv_prep() is not called before hand.\n");
+		return -1;
+	}
+	sprintf(host, "%d.%d.%d.%d", ftp->pasv_ip[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);
+	sprintf(port, "%d", ftp->pasv_port);
+	ftp->fd = socket_connect(host, port);
+	if (ftp->fd == -1) return -1;
+	return 0;
+}
+
+int kftp_connect(knetFile *ftp)
+{
+	ftp->ctrl_fd = socket_connect(ftp->host, ftp->port);
+	if (ftp->ctrl_fd == -1) return -1;
+	kftp_get_response(ftp);
+	kftp_send_cmd(ftp, "USER anonymous\r\n", 1);
+	kftp_send_cmd(ftp, "PASS kftp@\r\n", 1);
+	kftp_send_cmd(ftp, "TYPE I\r\n", 1);
+	return 0;
+}
+
+int kftp_reconnect(knetFile *ftp)
+{
+	if (ftp->ctrl_fd != -1) {
+		netclose(ftp->ctrl_fd);
+		ftp->ctrl_fd = -1;
+	}
+	netclose(ftp->fd);
+	ftp->fd = -1;
+	return kftp_connect(ftp);
+}
+
+// initialize ->type, ->host, ->retr and ->size
+knetFile *kftp_parse_url(const char *fn, const char *mode)
+{
+	knetFile *fp;
+	char *p;
+	int l;
+	if (strstr(fn, "ftp://") != fn) return 0;
+	for (p = (char*)fn + 6; *p && *p != '/'; ++p);
+	if (*p != '/') return 0;
+	l = p - fn - 6;
+	fp = calloc(1, sizeof(knetFile));
+	fp->type = KNF_TYPE_FTP;
+	fp->fd = -1;
+	/* the Linux/Mac version of socket_connect() also recognizes a port
+	 * like "ftp", but the Windows version does not. */
+	fp->port = strdup("21");
+	fp->host = calloc(l + 1, 1);
+	if (strchr(mode, 'c')) fp->no_reconnect = 1;
+	strncpy(fp->host, fn + 6, l);
+	fp->retr = calloc(strlen(p) + 8, 1);
+	sprintf(fp->retr, "RETR %s\r\n", p);
+    fp->size_cmd = calloc(strlen(p) + 8, 1);
+    sprintf(fp->size_cmd, "SIZE %s\r\n", p);
+	fp->seek_offset = 0;
+	return fp;
+}
+// place ->fd at offset off
+int kftp_connect_file(knetFile *fp)
+{
+	int ret;
+	long long file_size;
+	if (fp->fd != -1) {
+		netclose(fp->fd);
+		if (fp->no_reconnect) kftp_get_response(fp);
+	}
+	kftp_pasv_prep(fp);
+    kftp_send_cmd(fp, fp->size_cmd, 1);
+#ifndef _WIN32
+    if ( sscanf(fp->response,"%*d %lld", &file_size) != 1 )
+    {
+        fprintf(stderr,"[kftp_connect_file] %s\n", fp->response);
+        return -1;
+    }
+#else
+	const char *p = fp->response;
+	while (*p != ' ') ++p;
+	while (*p < '0' || *p > '9') ++p;
+	file_size = strtoint64(p);
+#endif
+	fp->file_size = file_size;
+	if (fp->offset>=0) {
+		char tmp[32];
+#ifndef _WIN32
+		sprintf(tmp, "REST %lld\r\n", (long long)fp->offset);
+#else
+		strcpy(tmp, "REST ");
+		int64tostr(tmp + 5, fp->offset);
+		strcat(tmp, "\r\n");
+#endif
+		kftp_send_cmd(fp, tmp, 1);
+	}
+	kftp_send_cmd(fp, fp->retr, 0);
+	kftp_pasv_connect(fp);
+	ret = kftp_get_response(fp);
+	if (ret != 150) {
+		fprintf(stderr, "[kftp_connect_file] %s\n", fp->response);
+		netclose(fp->fd);
+		fp->fd = -1;
+		return -1;
+	}
+	fp->is_ready = 1;
+	return 0;
+}
+
+
+/**************************
+ * HTTP specific routines *
+ **************************/
+
+knetFile *khttp_parse_url(const char *fn, const char *mode)
+{
+	knetFile *fp;
+	char *p, *proxy, *q;
+	int l;
+	if (strstr(fn, "http://") != fn) return 0;
+	// set ->http_host
+	for (p = (char*)fn + 7; *p && *p != '/'; ++p);
+	l = p - fn - 7;
+	fp = calloc(1, sizeof(knetFile));
+	fp->http_host = calloc(l + 1, 1);
+	strncpy(fp->http_host, fn + 7, l);
+	fp->http_host[l] = 0;
+	for (q = fp->http_host; *q && *q != ':'; ++q);
+	if (*q == ':') *q++ = 0;
+	// get http_proxy
+	proxy = getenv("http_proxy");
+	// set ->host, ->port and ->path
+	if (proxy == 0) {
+		fp->host = strdup(fp->http_host); // when there is no proxy, server name is identical to http_host name.
+		fp->port = strdup(*q? q : "80");
+		fp->path = strdup(*p? p : "/");
+	} else {
+		fp->host = (strstr(proxy, "http://") == proxy)? strdup(proxy + 7) : strdup(proxy);
+		for (q = fp->host; *q && *q != ':'; ++q);
+		if (*q == ':') *q++ = 0; 
+		fp->port = strdup(*q? q : "80");
+		fp->path = strdup(fn);
+	}
+	fp->type = KNF_TYPE_HTTP;
+	fp->ctrl_fd = fp->fd = -1;
+	fp->seek_offset = 0;
+	return fp;
+}
+
+int khttp_connect_file(knetFile *fp)
+{
+	int ret, l = 0;
+	char *buf, *p;
+	if (fp->fd != -1) netclose(fp->fd);
+	fp->fd = socket_connect(fp->host, fp->port);
+	buf = calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
+	l += sprintf(buf + l, "GET %s HTTP/1.0\r\nHost: %s\r\n", fp->path, fp->http_host);
+    l += sprintf(buf + l, "Range: bytes=%lld-\r\n", (long long)fp->offset);
+	l += sprintf(buf + l, "\r\n");
+	netwrite(fp->fd, buf, l);
+	l = 0;
+	while (netread(fp->fd, buf + l, 1)) { // read HTTP header; FIXME: bad efficiency
+		if (buf[l] == '\n' && l >= 3)
+			if (strncmp(buf + l - 3, "\r\n\r\n", 4) == 0) break;
+		++l;
+	}
+	buf[l] = 0;
+	if (l < 14) { // prematured header
+		netclose(fp->fd);
+		fp->fd = -1;
+		return -1;
+	}
+	ret = strtol(buf + 8, &p, 0); // HTTP return code
+	if (ret == 200 && fp->offset>0) { // 200 (complete result); then skip beginning of the file
+		off_t rest = fp->offset;
+		while (rest) {
+			off_t l = rest < 0x10000? rest : 0x10000;
+			rest -= my_netread(fp->fd, buf, l);
+		}
+	} else if (ret != 206 && ret != 200) {
+		free(buf);
+		fprintf(stderr, "[khttp_connect_file] fail to open file (HTTP code: %d).\n", ret);
+		netclose(fp->fd);
+		fp->fd = -1;
+		return -1;
+	}
+	free(buf);
+	fp->is_ready = 1;
+	return 0;
+}
+
+/********************
+ * Generic routines *
+ ********************/
+
+knetFile *knet_open(const char *fn, const char *mode)
+{
+	knetFile *fp = 0;
+	if (mode[0] != 'r') {
+		fprintf(stderr, "[kftp_open] only mode \"r\" is supported.\n");
+		return 0;
+	}
+	if (strstr(fn, "ftp://") == fn) {
+		fp = kftp_parse_url(fn, mode);
+		if (fp == 0) return 0;
+		if (kftp_connect(fp) == -1) {
+			knet_close(fp);
+			return 0;
+		}
+		kftp_connect_file(fp);
+	} else if (strstr(fn, "http://") == fn) {
+		fp = khttp_parse_url(fn, mode);
+		if (fp == 0) return 0;
+		khttp_connect_file(fp);
+	} else { // local file
+#ifdef _WIN32
+		/* In windows, O_BINARY is necessary. In Linux/Mac, O_BINARY may
+		 * be undefined on some systems, although it is defined on my
+		 * Mac and the Linux I have tested on. */
+		int fd = open(fn, O_RDONLY | O_BINARY);
+#else		
+		int fd = open(fn, O_RDONLY);
+#endif
+		if (fd == -1) {
+			perror("open");
+			return 0;
+		}
+		fp = (knetFile*)calloc(1, sizeof(knetFile));
+		fp->type = KNF_TYPE_LOCAL;
+		fp->fd = fd;
+		fp->ctrl_fd = -1;
+	}
+	if (fp && fp->fd == -1) {
+		knet_close(fp);
+		return 0;
+	}
+	return fp;
+}
+
+knetFile *knet_dopen(int fd, const char *mode)
+{
+	knetFile *fp = (knetFile*)calloc(1, sizeof(knetFile));
+	fp->type = KNF_TYPE_LOCAL;
+	fp->fd = fd;
+	return fp;
+}
+
+off_t knet_read(knetFile *fp, void *buf, off_t len)
+{
+	off_t l = 0;
+	if (fp->fd == -1) return 0;
+	if (fp->type == KNF_TYPE_FTP) {
+		if (fp->is_ready == 0) {
+			if (!fp->no_reconnect) kftp_reconnect(fp);
+			kftp_connect_file(fp);
+		}
+	} else if (fp->type == KNF_TYPE_HTTP) {
+		if (fp->is_ready == 0)
+			khttp_connect_file(fp);
+	}
+	if (fp->type == KNF_TYPE_LOCAL) { // on Windows, the following block is necessary; not on UNIX
+		off_t rest = len, curr;
+		while (rest) {
+			curr = read(fp->fd, buf + l, rest);
+			if (curr == 0) break;
+			l += curr; rest -= curr;
+		}
+	} else l = my_netread(fp->fd, buf, len);
+	fp->offset += l;
+	return l;
+}
+
+off_t knet_seek(knetFile *fp, int64_t off, int whence)
+{
+	if (whence == SEEK_SET && off == fp->offset) return 0;
+	if (fp->type == KNF_TYPE_LOCAL) {
+		/* Be aware that lseek() returns the offset after seeking,
+		 * while fseek() returns zero on success. */
+		off_t offset = lseek(fp->fd, off, whence);
+		if (offset == -1) {
+            // Be silent, it is OK for knet_seek to fail when the file is streamed
+            // fprintf(stderr,"[knet_seek] %s\n", strerror(errno));
+			return -1;
+		}
+		fp->offset = offset;
+		return 0;
+	}
+    else if (fp->type == KNF_TYPE_FTP) 
+    {
+        if (whence==SEEK_CUR)
+            fp->offset += off;
+        else if (whence==SEEK_SET)
+            fp->offset = off;
+        else if ( whence==SEEK_END)
+            fp->offset = fp->file_size+off;
+		fp->is_ready = 0;
+		return 0;
+	} 
+    else if (fp->type == KNF_TYPE_HTTP) 
+    {
+		if (whence == SEEK_END) { // FIXME: can we allow SEEK_END in future?
+			fprintf(stderr, "[knet_seek] SEEK_END is not supported for HTTP. Offset is unchanged.\n");
+			errno = ESPIPE;
+			return -1;
+		}
+        if (whence==SEEK_CUR)
+            fp->offset += off;
+        else if (whence==SEEK_SET)
+            fp->offset = off;
+		fp->is_ready = 0;
+		return fp->offset;
+	}
+	errno = EINVAL;
+    fprintf(stderr,"[knet_seek] %s\n", strerror(errno));
+	return -1;
+}
+
+int knet_close(knetFile *fp)
+{
+	if (fp == 0) return 0;
+	if (fp->ctrl_fd != -1) netclose(fp->ctrl_fd); // FTP specific
+	if (fp->fd != -1) {
+		/* On Linux/Mac, netclose() is an alias of close(), but on
+		 * Windows, it is an alias of closesocket(). */
+		if (fp->type == KNF_TYPE_LOCAL) close(fp->fd);
+		else netclose(fp->fd);
+	}
+	free(fp->host); free(fp->port);
+	free(fp->response); free(fp->retr); // FTP specific
+	free(fp->path); free(fp->http_host); // HTTP specific
+	free(fp);
+	return 0;
+}
+
+#ifdef KNETFILE_MAIN
+int main(void)
+{
+	char *buf;
+	knetFile *fp;
+	int type = 4, l;
+#ifdef _WIN32
+	knet_win32_init();
+#endif
+	buf = calloc(0x100000, 1);
+	if (type == 0) {
+		fp = knet_open("knetfile.c", "r");
+		knet_seek(fp, 1000, SEEK_SET);
+	} else if (type == 1) { // NCBI FTP, large file
+		fp = knet_open("ftp://ftp.ncbi.nih.gov/1000genomes/ftp/data/NA12878/alignment/NA12878.chrom6.SLX.SRP000032.2009_06.bam", "r");
+		knet_seek(fp, 2500000000ll, SEEK_SET);
+		l = knet_read(fp, buf, 255);
+	} else if (type == 2) {
+		fp = knet_open("ftp://ftp.sanger.ac.uk/pub4/treefam/tmp/index.shtml", "r");
+		knet_seek(fp, 1000, SEEK_SET);
+	} else if (type == 3) {
+		fp = knet_open("http://www.sanger.ac.uk/Users/lh3/index.shtml", "r");
+		knet_seek(fp, 1000, SEEK_SET);
+	} else if (type == 4) {
+		fp = knet_open("http://www.sanger.ac.uk/Users/lh3/ex1.bam", "r");
+		knet_read(fp, buf, 10000);
+		knet_seek(fp, 20000, SEEK_SET);
+		knet_seek(fp, 10000, SEEK_SET);
+		l = knet_read(fp, buf+10000, 10000000) + 10000;
+	}
+	if (type != 4 && type != 1) {
+		knet_read(fp, buf, 255);
+		buf[255] = 0;
+		printf("%s\n", buf);
+	} else write(fileno(stdout), buf, l);
+	knet_close(fp);
+	free(buf);
+	return 0;
+}
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/knetfile.h b/ext/samtools-0.1.7a_getUnique-0.1.3/knetfile.h
new file mode 100644
index 0000000..0a0e66f
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/knetfile.h
@@ -0,0 +1,75 @@
+#ifndef KNETFILE_H
+#define KNETFILE_H
+
+#include <stdint.h>
+#include <fcntl.h>
+
+#ifndef _WIN32
+#define netread(fd, ptr, len) read(fd, ptr, len)
+#define netwrite(fd, ptr, len) write(fd, ptr, len)
+#define netclose(fd) close(fd)
+#else
+#include <winsock2.h>
+#define netread(fd, ptr, len) recv(fd, ptr, len, 0)
+#define netwrite(fd, ptr, len) send(fd, ptr, len, 0)
+#define netclose(fd) closesocket(fd)
+#endif
+
+// FIXME: currently I/O is unbuffered
+
+#define KNF_TYPE_LOCAL 1
+#define KNF_TYPE_FTP   2
+#define KNF_TYPE_HTTP  3
+
+typedef struct knetFile_s {
+	int type, fd;
+	int64_t offset;
+	char *host, *port;
+
+	// the following are for FTP only
+	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;
+	char *response, *retr, *size_cmd;
+	int64_t seek_offset; // for lazy seek
+    int64_t file_size;
+
+	// the following are for HTTP only
+	char *path, *http_host;
+} knetFile;
+
+#define knet_tell(fp) ((fp)->offset)
+#define knet_fileno(fp) ((fp)->fd)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _WIN32
+	int knet_win32_init();
+	void knet_win32_destroy();
+#endif
+
+	knetFile *knet_open(const char *fn, const char *mode);
+
+	/* 
+	   This only works with local files.
+	 */
+	knetFile *knet_dopen(int fd, const char *mode);
+
+	/*
+	  If ->is_ready==0, this routine updates ->fd; otherwise, it simply
+	  reads from ->fd.
+	 */
+	off_t knet_read(knetFile *fp, void *buf, off_t len);
+
+	/*
+	  This routine only sets ->offset and ->is_ready=0. It does not
+	  communicate with the FTP server.
+	 */
+	off_t knet_seek(knetFile *fp, int64_t off, int whence);
+	int knet_close(knetFile *fp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/kseq.h b/ext/samtools-0.1.7a_getUnique-0.1.3/kseq.h
new file mode 100644
index 0000000..82face0
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/kseq.h
@@ -0,0 +1,227 @@
+/* The MIT License
+
+   Copyright (c) 2008 Genome Research Ltd (GRL).
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Contact: Heng Li <lh3@sanger.ac.uk> */
+
+/*
+  2009-07-16 (lh3): in kstream_t, change "char*" to "unsigned char*"
+ */
+
+/* Last Modified: 12APR2009 */
+
+#ifndef AC_KSEQ_H
+#define AC_KSEQ_H
+
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+
+#define KS_SEP_SPACE 0 // isspace(): \t, \n, \v, \f, \r
+#define KS_SEP_TAB   1 // isspace() && !' '
+#define KS_SEP_MAX   1
+
+#define __KS_TYPE(type_t)						\
+	typedef struct __kstream_t {				\
+		unsigned char *buf;						\
+		int begin, end, is_eof;					\
+		type_t f;								\
+	} kstream_t;
+
+#define ks_eof(ks) ((ks)->is_eof && (ks)->begin >= (ks)->end)
+#define ks_rewind(ks) ((ks)->is_eof = (ks)->begin = (ks)->end = 0)
+
+#define __KS_BASIC(type_t, __bufsize)								\
+	static inline kstream_t *ks_init(type_t f)						\
+	{																\
+		kstream_t *ks = (kstream_t*)calloc(1, sizeof(kstream_t));	\
+		ks->f = f;													\
+		ks->buf = malloc(__bufsize);								\
+		return ks;													\
+	}																\
+	static inline void ks_destroy(kstream_t *ks)					\
+	{																\
+		if (ks) {													\
+			free(ks->buf);											\
+			free(ks);												\
+		}															\
+	}
+
+#define __KS_GETC(__read, __bufsize)						\
+	static inline int ks_getc(kstream_t *ks)				\
+	{														\
+		if (ks->is_eof && ks->begin >= ks->end) return -1;	\
+		if (ks->begin >= ks->end) {							\
+			ks->begin = 0;									\
+			ks->end = __read(ks->f, ks->buf, __bufsize);	\
+			if (ks->end < __bufsize) ks->is_eof = 1;		\
+			if (ks->end == 0) return -1;					\
+		}													\
+		return (int)ks->buf[ks->begin++];					\
+	}
+
+#ifndef KSTRING_T
+#define KSTRING_T kstring_t
+typedef struct __kstring_t {
+	size_t l, m;
+	char *s;
+} kstring_t;
+#endif
+
+#ifndef kroundup32
+#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
+#endif
+
+#define __KS_GETUNTIL(__read, __bufsize)								\
+	static int ks_getuntil(kstream_t *ks, int delimiter, kstring_t *str, int *dret) \
+	{																	\
+		if (dret) *dret = 0;											\
+		str->l = 0;														\
+		if (ks->begin >= ks->end && ks->is_eof) return -1;				\
+		for (;;) {														\
+			int i;														\
+			if (ks->begin >= ks->end) {									\
+				if (!ks->is_eof) {										\
+					ks->begin = 0;										\
+					ks->end = __read(ks->f, ks->buf, __bufsize);		\
+					if (ks->end < __bufsize) ks->is_eof = 1;			\
+					if (ks->end == 0) break;							\
+				} else break;											\
+			}															\
+			if (delimiter > KS_SEP_MAX) {								\
+				for (i = ks->begin; i < ks->end; ++i)					\
+					if (ks->buf[i] == delimiter) break;					\
+			} else if (delimiter == KS_SEP_SPACE) {						\
+				for (i = ks->begin; i < ks->end; ++i)					\
+					if (isspace(ks->buf[i])) break;						\
+			} else if (delimiter == KS_SEP_TAB) {						\
+				for (i = ks->begin; i < ks->end; ++i)					\
+					if (isspace(ks->buf[i]) && ks->buf[i] != ' ') break; \
+			} else i = 0; /* never come to here! */						\
+			if (str->m - str->l < i - ks->begin + 1) {					\
+				str->m = str->l + (i - ks->begin) + 1;					\
+				kroundup32(str->m);										\
+				str->s = (char*)realloc(str->s, str->m);				\
+			}															\
+			memcpy(str->s + str->l, ks->buf + ks->begin, i - ks->begin); \
+			str->l = str->l + (i - ks->begin);							\
+			ks->begin = i + 1;											\
+			if (i < ks->end) {											\
+				if (dret) *dret = ks->buf[i];							\
+				break;													\
+			}															\
+		}																\
+		if (str->l == 0) {												\
+			str->m = 1;													\
+			str->s = (char*)calloc(1, 1);								\
+		}																\
+		str->s[str->l] = '\0';											\
+		return str->l;													\
+	}
+
+#define KSTREAM_INIT(type_t, __read, __bufsize) \
+	__KS_TYPE(type_t)							\
+	__KS_BASIC(type_t, __bufsize)				\
+	__KS_GETC(__read, __bufsize)				\
+	__KS_GETUNTIL(__read, __bufsize)
+
+#define __KSEQ_BASIC(type_t)											\
+	static inline kseq_t *kseq_init(type_t fd)							\
+	{																	\
+		kseq_t *s = (kseq_t*)calloc(1, sizeof(kseq_t));					\
+		s->f = ks_init(fd);												\
+		return s;														\
+	}																	\
+	static inline void kseq_rewind(kseq_t *ks)							\
+	{																	\
+		ks->last_char = 0;												\
+		ks->f->is_eof = ks->f->begin = ks->f->end = 0;					\
+	}																	\
+	static inline void kseq_destroy(kseq_t *ks)							\
+	{																	\
+		if (!ks) return;												\
+		free(ks->name.s); free(ks->comment.s); free(ks->seq.s);	free(ks->qual.s); \
+		ks_destroy(ks->f);												\
+		free(ks);														\
+	}
+
+/* Return value:
+   >=0  length of the sequence (normal)
+   -1   end-of-file
+   -2   truncated quality string
+ */
+#define __KSEQ_READ														\
+	static int kseq_read(kseq_t *seq)									\
+	{																	\
+		int c;															\
+		kstream_t *ks = seq->f;											\
+		if (seq->last_char == 0) { /* then jump to the next header line */ \
+			while ((c = ks_getc(ks)) != -1 && c != '>' && c != '@');	\
+			if (c == -1) return -1; /* end of file */					\
+			seq->last_char = c;											\
+		} /* the first header char has been read */						\
+		seq->comment.l = seq->seq.l = seq->qual.l = 0;					\
+		if (ks_getuntil(ks, 0, &seq->name, &c) < 0) return -1;			\
+		if (c != '\n') ks_getuntil(ks, '\n', &seq->comment, 0);			\
+		while ((c = ks_getc(ks)) != -1 && c != '>' && c != '+' && c != '@') { \
+			if (isgraph(c)) { /* printable non-space character */		\
+				if (seq->seq.l + 1 >= seq->seq.m) { /* double the memory */ \
+					seq->seq.m = seq->seq.l + 2;						\
+					kroundup32(seq->seq.m); /* rounded to next closest 2^k */ \
+					seq->seq.s = (char*)realloc(seq->seq.s, seq->seq.m); \
+				}														\
+				seq->seq.s[seq->seq.l++] = (char)c;						\
+			}															\
+		}																\
+		if (c == '>' || c == '@') seq->last_char = c; /* the first header char has been read */	\
+		seq->seq.s[seq->seq.l] = 0;	/* null terminated string */		\
+		if (c != '+') return seq->seq.l; /* FASTA */					\
+		if (seq->qual.m < seq->seq.m) {	/* allocate enough memory */	\
+			seq->qual.m = seq->seq.m;									\
+			seq->qual.s = (char*)realloc(seq->qual.s, seq->qual.m);		\
+		}																\
+		while ((c = ks_getc(ks)) != -1 && c != '\n'); /* skip the rest of '+' line */ \
+		if (c == -1) return -2; /* we should not stop here */			\
+		while ((c = ks_getc(ks)) != -1 && seq->qual.l < seq->seq.l)		\
+			if (c >= 33 && c <= 127) seq->qual.s[seq->qual.l++] = (unsigned char)c;	\
+		seq->qual.s[seq->qual.l] = 0; /* null terminated string */		\
+		seq->last_char = 0;	/* we have not come to the next header line */ \
+		if (seq->seq.l != seq->qual.l) return -2; /* qual string is shorter than seq string */ \
+		return seq->seq.l;												\
+	}
+
+#define __KSEQ_TYPE(type_t)						\
+	typedef struct {							\
+		kstring_t name, comment, seq, qual;		\
+		int last_char;							\
+		kstream_t *f;							\
+	} kseq_t;
+
+#define KSEQ_INIT(type_t, __read)				\
+	KSTREAM_INIT(type_t, __read, 4096)			\
+	__KSEQ_TYPE(type_t)							\
+	__KSEQ_BASIC(type_t)						\
+	__KSEQ_READ
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/ksort.h b/ext/samtools-0.1.7a_getUnique-0.1.3/ksort.h
new file mode 100644
index 0000000..16a03fd
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/ksort.h
@@ -0,0 +1,271 @@
+/* The MIT License
+
+   Copyright (c) 2008 Genome Research Ltd (GRL).
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Contact: Heng Li <lh3@sanger.ac.uk> */
+
+/*
+  2008-11-16 (0.1.4):
+
+    * Fixed a bug in introsort() that happens in rare cases.
+
+  2008-11-05 (0.1.3):
+
+    * Fixed a bug in introsort() for complex comparisons.
+
+	* Fixed a bug in mergesort(). The previous version is not stable.
+
+  2008-09-15 (0.1.2):
+
+	* Accelerated introsort. On my Mac (not on another Linux machine),
+	  my implementation is as fast as std::sort on random input.
+
+	* Added combsort and in introsort, switch to combsort if the
+	  recursion is too deep.
+
+  2008-09-13 (0.1.1):
+
+	* Added k-small algorithm
+
+  2008-09-05 (0.1.0):
+
+	* Initial version
+
+*/
+
+#ifndef AC_KSORT_H
+#define AC_KSORT_H
+
+#include <stdlib.h>
+#include <string.h>
+
+typedef struct {
+	void *left, *right;
+	int depth;
+} ks_isort_stack_t;
+
+#define KSORT_SWAP(type_t, a, b) { register type_t t=(a); (a)=(b); (b)=t; }
+
+#define KSORT_INIT(name, type_t, __sort_lt)								\
+	void ks_mergesort_##name(size_t n, type_t array[], type_t temp[])	\
+	{																	\
+		type_t *a2[2], *a, *b;											\
+		int curr, shift;												\
+																		\
+		a2[0] = array;													\
+		a2[1] = temp? temp : (type_t*)malloc(sizeof(type_t) * n);		\
+		for (curr = 0, shift = 0; (1ul<<shift) < n; ++shift) {			\
+			a = a2[curr]; b = a2[1-curr];								\
+			if (shift == 0) {											\
+				type_t *p = b, *i, *eb = a + n;							\
+				for (i = a; i < eb; i += 2) {							\
+					if (i == eb - 1) *p++ = *i;							\
+					else {												\
+						if (__sort_lt(*(i+1), *i)) {					\
+							*p++ = *(i+1); *p++ = *i;					\
+						} else {										\
+							*p++ = *i; *p++ = *(i+1);					\
+						}												\
+					}													\
+				}														\
+			} else {													\
+				size_t i, step = 1ul<<shift;							\
+				for (i = 0; i < n; i += step<<1) {						\
+					type_t *p, *j, *k, *ea, *eb;						\
+					if (n < i + step) {									\
+						ea = a + n; eb = a;								\
+					} else {											\
+						ea = a + i + step;								\
+						eb = a + (n < i + (step<<1)? n : i + (step<<1)); \
+					}													\
+					j = a + i; k = a + i + step; p = b + i;				\
+					while (j < ea && k < eb) {							\
+						if (__sort_lt(*k, *j)) *p++ = *k++;				\
+						else *p++ = *j++;								\
+					}													\
+					while (j < ea) *p++ = *j++;							\
+					while (k < eb) *p++ = *k++;							\
+				}														\
+			}															\
+			curr = 1 - curr;											\
+		}																\
+		if (curr == 1) {												\
+			type_t *p = a2[0], *i = a2[1], *eb = array + n;				\
+			for (; p < eb; ++i) *p++ = *i;								\
+		}																\
+		if (temp == 0) free(a2[1]);										\
+	}																	\
+	void ks_heapadjust_##name(size_t i, size_t n, type_t l[])			\
+	{																	\
+		size_t k = i;													\
+		type_t tmp = l[i];												\
+		while ((k = (k << 1) + 1) < n) {								\
+			if (k != n - 1 && __sort_lt(l[k], l[k+1])) ++k;				\
+			if (__sort_lt(l[k], tmp)) break;							\
+			l[i] = l[k]; i = k;											\
+		}																\
+		l[i] = tmp;														\
+	}																	\
+	void ks_heapmake_##name(size_t lsize, type_t l[])					\
+	{																	\
+		size_t i;														\
+		for (i = (lsize >> 1) - 1; i != (size_t)(-1); --i)				\
+			ks_heapadjust_##name(i, lsize, l);							\
+	}																	\
+	void ks_heapsort_##name(size_t lsize, type_t l[])					\
+	{																	\
+		size_t i;														\
+		for (i = lsize - 1; i > 0; --i) {								\
+			type_t tmp;													\
+			tmp = *l; *l = l[i]; l[i] = tmp; ks_heapadjust_##name(0, i, l); \
+		}																\
+	}																	\
+	inline void __ks_insertsort_##name(type_t *s, type_t *t)			\
+	{																	\
+		type_t *i, *j, swap_tmp;										\
+		for (i = s + 1; i < t; ++i)										\
+			for (j = i; j > s && __sort_lt(*j, *(j-1)); --j) {			\
+				swap_tmp = *j; *j = *(j-1); *(j-1) = swap_tmp;			\
+			}															\
+	}																	\
+	void ks_combsort_##name(size_t n, type_t a[])						\
+	{																	\
+		const double shrink_factor = 1.2473309501039786540366528676643; \
+		int do_swap;													\
+		size_t gap = n;													\
+		type_t tmp, *i, *j;												\
+		do {															\
+			if (gap > 2) {												\
+				gap = (size_t)(gap / shrink_factor);					\
+				if (gap == 9 || gap == 10) gap = 11;					\
+			}															\
+			do_swap = 0;												\
+			for (i = a; i < a + n - gap; ++i) {							\
+				j = i + gap;											\
+				if (__sort_lt(*j, *i)) {								\
+					tmp = *i; *i = *j; *j = tmp;						\
+					do_swap = 1;										\
+				}														\
+			}															\
+		} while (do_swap || gap > 2);									\
+		if (gap != 1) __ks_insertsort_##name(a, a + n);					\
+	}																	\
+	void ks_introsort_##name(size_t n, type_t a[])						\
+	{																	\
+		int d;															\
+		ks_isort_stack_t *top, *stack;									\
+		type_t rp, swap_tmp;											\
+		type_t *s, *t, *i, *j, *k;										\
+																		\
+		if (n < 1) return;												\
+		else if (n == 2) {												\
+			if (__sort_lt(a[1], a[0])) { swap_tmp = a[0]; a[0] = a[1]; a[1] = swap_tmp; } \
+			return;														\
+		}																\
+		for (d = 2; 1ul<<d < n; ++d);									\
+		stack = (ks_isort_stack_t*)malloc(sizeof(ks_isort_stack_t) * ((sizeof(size_t)*d)+2)); \
+		top = stack; s = a; t = a + (n-1); d <<= 1;						\
+		while (1) {														\
+			if (s < t) {												\
+				if (--d == 0) {											\
+					ks_combsort_##name(t - s + 1, s);					\
+					t = s;												\
+					continue;											\
+				}														\
+				i = s; j = t; k = i + ((j-i)>>1) + 1;					\
+				if (__sort_lt(*k, *i)) {								\
+					if (__sort_lt(*k, *j)) k = j;						\
+				} else k = __sort_lt(*j, *i)? i : j;					\
+				rp = *k;												\
+				if (k != t) { swap_tmp = *k; *k = *t; *t = swap_tmp; }	\
+				for (;;) {												\
+					do ++i; while (__sort_lt(*i, rp));					\
+					do --j; while (i <= j && __sort_lt(rp, *j));		\
+					if (j <= i) break;									\
+					swap_tmp = *i; *i = *j; *j = swap_tmp;				\
+				}														\
+				swap_tmp = *i; *i = *t; *t = swap_tmp;					\
+				if (i-s > t-i) {										\
+					if (i-s > 16) { top->left = s; top->right = i-1; top->depth = d; ++top; } \
+					s = t-i > 16? i+1 : t;								\
+				} else {												\
+					if (t-i > 16) { top->left = i+1; top->right = t; top->depth = d; ++top; } \
+					t = i-s > 16? i-1 : s;								\
+				}														\
+			} else {													\
+				if (top == stack) {										\
+					free(stack);										\
+					__ks_insertsort_##name(a, a+n);						\
+					return;												\
+				} else { --top; s = (type_t*)top->left; t = (type_t*)top->right; d = top->depth; } \
+			}															\
+		}																\
+	}																	\
+	/* This function is adapted from: http://ndevilla.free.fr/median/ */ \
+	/* 0 <= kk < n */													\
+	type_t ks_ksmall_##name(size_t n, type_t arr[], size_t kk)			\
+	{																	\
+		type_t *low, *high, *k, *ll, *hh, *mid;							\
+		low = arr; high = arr + n - 1; k = arr + kk;					\
+		for (;;) {														\
+			if (high <= low) return *k;									\
+			if (high == low + 1) {										\
+				if (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \
+				return *k;												\
+			}															\
+			mid = low + (high - low) / 2;								\
+			if (__sort_lt(*high, *mid)) KSORT_SWAP(type_t, *mid, *high); \
+			if (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \
+			if (__sort_lt(*low, *mid)) KSORT_SWAP(type_t, *mid, *low);	\
+			KSORT_SWAP(type_t, *mid, *(low+1));							\
+			ll = low + 1; hh = high;									\
+			for (;;) {													\
+				do ++ll; while (__sort_lt(*ll, *low));					\
+				do --hh; while (__sort_lt(*low, *hh));					\
+				if (hh < ll) break;										\
+				KSORT_SWAP(type_t, *ll, *hh);							\
+			}															\
+			KSORT_SWAP(type_t, *low, *hh);								\
+			if (hh <= k) low = ll;										\
+			if (hh >= k) high = hh - 1;									\
+		}																\
+	}
+
+#define ks_mergesort(name, n, a, t) ks_mergesort_##name(n, a, t)
+#define ks_introsort(name, n, a) ks_introsort_##name(n, a)
+#define ks_combsort(name, n, a) ks_combsort_##name(n, a)
+#define ks_heapsort(name, n, a) ks_heapsort_##name(n, a)
+#define ks_heapmake(name, n, a) ks_heapmake_##name(n, a)
+#define ks_heapadjust(name, i, n, a) ks_heapadjust_##name(i, n, a)
+#define ks_ksmall(name, n, a, k) ks_ksmall_##name(n, a, k)
+
+#define ks_lt_generic(a, b) ((a) < (b))
+#define ks_lt_str(a, b) (strcmp((a), (b)) < 0)
+
+typedef const char *ksstr_t;
+
+#define KSORT_INIT_GENERIC(type_t) KSORT_INIT(type_t, type_t, ks_lt_generic)
+#define KSORT_INIT_STR KSORT_INIT(str, ksstr_t, ks_lt_str)
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/kstring.c b/ext/samtools-0.1.7a_getUnique-0.1.3/kstring.c
new file mode 100644
index 0000000..e0203fa
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/kstring.c
@@ -0,0 +1,165 @@
+#include <stdarg.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdint.h>
+#include "kstring.h"
+
+int ksprintf(kstring_t *s, const char *fmt, ...)
+{
+	va_list ap;
+	int l;
+	va_start(ap, fmt);
+	l = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap); // This line does not work with glibc 2.0. See `man snprintf'.
+	va_end(ap);
+	if (l + 1 > s->m - s->l) {
+		s->m = s->l + l + 2;
+		kroundup32(s->m);
+		s->s = (char*)realloc(s->s, s->m);
+		va_start(ap, fmt);
+		l = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap);
+	}
+	va_end(ap);
+	s->l += l;
+	return l;
+}
+
+// s MUST BE a null terminated string; l = strlen(s)
+int ksplit_core(char *s, int delimiter, int *_max, int **_offsets)
+{
+	int i, n, max, last_char, last_start, *offsets, l;
+	n = 0; max = *_max; offsets = *_offsets;
+	l = strlen(s);
+	
+#define __ksplit_aux do {												\
+		if (_offsets) {													\
+			s[i] = 0;													\
+			if (n == max) {												\
+				max = max? max<<1 : 2;									\
+				offsets = (int*)realloc(offsets, sizeof(int) * max);	\
+			}															\
+			offsets[n++] = last_start;									\
+		} else ++n;														\
+	} while (0)
+
+	for (i = 0, last_char = last_start = 0; i <= l; ++i) {
+		if (delimiter == 0) {
+			if (isspace(s[i]) || s[i] == 0) {
+				if (isgraph(last_char)) __ksplit_aux; // the end of a field
+			} else {
+				if (isspace(last_char) || last_char == 0) last_start = i;
+			}
+		} else {
+			if (s[i] == delimiter || s[i] == 0) {
+				if (last_char != 0 && last_char != delimiter) __ksplit_aux; // the end of a field
+			} else {
+				if (last_char == delimiter || last_char == 0) last_start = i;
+			}
+		}
+		last_char = s[i];
+	}
+	*_max = max; *_offsets = offsets;
+	return n;
+}
+
+/**********************
+ * Boyer-Moore search *
+ **********************/
+
+// reference: http://www-igm.univ-mlv.fr/~lecroq/string/node14.html
+int *ksBM_prep(const uint8_t *pat, int m)
+{
+	int i, *suff, *prep, *bmGs, *bmBc;
+	prep = calloc(m + 256, 1);
+	bmGs = prep; bmBc = prep + m;
+	{ // preBmBc()
+		for (i = 0; i < 256; ++i) bmBc[i] = m;
+		for (i = 0; i < m - 1; ++i) bmBc[pat[i]] = m - i - 1;
+	}
+	suff = calloc(m, sizeof(int));
+	{ // suffixes()
+		int f = 0, g;
+		suff[m - 1] = m;
+		g = m - 1;
+		for (i = m - 2; i >= 0; --i) {
+			if (i > g && suff[i + m - 1 - f] < i - g)
+				suff[i] = suff[i + m - 1 - f];
+			else {
+				if (i < g) g = i;
+				f = i;
+				while (g >= 0 && pat[g] == pat[g + m - 1 - f]) --g;
+				suff[i] = f - g;
+			}
+		}
+	}
+	{ // preBmGs()
+		int j = 0;
+		for (i = 0; i < m; ++i) bmGs[i] = m;
+		for (i = m - 1; i >= 0; --i)
+			if (suff[i] == i + 1)
+				for (; j < m - 1 - i; ++j)
+					if (bmGs[j] == m)
+						bmGs[j] = m - 1 - i;
+		for (i = 0; i <= m - 2; ++i)
+			bmGs[m - 1 - suff[i]] = m - 1 - i;
+	}
+	free(suff);
+	return prep;
+}
+
+int *ksBM_search(const uint8_t *str, int n, const uint8_t *pat, int m, int *_prep, int *n_matches)
+{
+	int i, j, *prep, *bmGs, *bmBc;
+	int *matches = 0, mm = 0, nm = 0;
+	prep = _prep? _prep : ksBM_prep(pat, m);
+	bmGs = prep; bmBc = prep + m;
+	j = 0;
+	while (j <= n - m) {
+		for (i = m - 1; i >= 0 && pat[i] == str[i+j]; --i);
+		if (i < 0) {
+			if (nm == mm) {
+				mm = mm? mm<<1 : 1;
+				matches = realloc(matches, mm * sizeof(int));
+			}
+			matches[nm++] = j;
+			j += bmGs[0];
+		} else {
+			int max = bmBc[str[i+j]] - m + 1 + i;
+			if (max < bmGs[i]) max = bmGs[i];
+			j += max;
+		}
+	}
+	*n_matches = nm;
+	if (_prep == 0) free(prep);
+	return matches;
+}
+
+#ifdef KSTRING_MAIN
+#include <stdio.h>
+int main()
+{
+	kstring_t *s;
+	int *fields, n, i;
+	s = (kstring_t*)calloc(1, sizeof(kstring_t));
+	// test ksprintf()
+	ksprintf(s, " abcdefg:    %d ", 100);
+	printf("'%s'\n", s->s);
+	// test ksplit()
+	fields = ksplit(s, 0, &n);
+	for (i = 0; i < n; ++i)
+		printf("field[%d] = '%s'\n", i, s->s + fields[i]);
+	free(s);
+
+	{
+		static char *str = "abcdefgcdg";
+		static char *pat = "cd";
+		int n, *matches;
+		matches = ksBM_search(str, strlen(str), pat, strlen(pat), 0, &n);
+		printf("%d: \n", n);
+		for (i = 0; i < n; ++i)
+			printf("- %d\n", matches[i]);
+		free(matches);
+	}
+	return 0;
+}
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/kstring.h b/ext/samtools-0.1.7a_getUnique-0.1.3/kstring.h
new file mode 100644
index 0000000..f4e5a99
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/kstring.h
@@ -0,0 +1,68 @@
+#ifndef KSTRING_H
+#define KSTRING_H
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+#ifndef kroundup32
+#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
+#endif
+
+#ifndef KSTRING_T
+#define KSTRING_T kstring_t
+typedef struct __kstring_t {
+	size_t l, m;
+	char *s;
+} kstring_t;
+#endif
+
+int ksprintf(kstring_t *s, const char *fmt, ...);
+int ksplit_core(char *s, int delimiter, int *_max, int **_offsets);
+
+// calculate the auxiliary array, allocated by calloc()
+int *ksBM_prep(const uint8_t *pat, int m);
+
+/* Search pat in str and returned the list of matches. The size of the
+ * list is returned as n_matches. _prep is the array returned by
+ * ksBM_prep(). If it is a NULL pointer, ksBM_prep() will be called. */
+int *ksBM_search(const uint8_t *str, int n, const uint8_t *pat, int m, int *_prep, int *n_matches);
+
+static inline int kputsn(const char *p, int l, kstring_t *s)
+{
+	if (s->l + l + 1 >= s->m) {
+		s->m = s->l + l + 2;
+		kroundup32(s->m);
+		s->s = (char*)realloc(s->s, s->m);
+	}
+	strncpy(s->s + s->l, p, l);
+	s->l += l;
+	s->s[s->l] = 0;
+	return l;
+}
+
+static inline int kputs(const char *p, kstring_t *s)
+{
+	return kputsn(p, strlen(p), s);
+}
+
+static inline int kputc(int c, kstring_t *s)
+{
+	if (s->l + 1 >= s->m) {
+		s->m = s->l + 2;
+		kroundup32(s->m);
+		s->s = (char*)realloc(s->s, s->m);
+	}
+	s->s[s->l++] = c;
+	s->s[s->l] = 0;
+	return c;
+}
+
+static inline int *ksplit(kstring_t *s, int delimiter, int *n)
+{
+	int max = 0, *offsets = 0;
+	*n = ksplit_core(s->s, delimiter, &max, &offsets);
+	return offsets;
+}
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/libbam.a b/ext/samtools-0.1.7a_getUnique-0.1.3/libbam.a
new file mode 100644
index 0000000..8cba34e
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/libbam.a differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/Makefile b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/Makefile
new file mode 100644
index 0000000..4404ccc
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/Makefile
@@ -0,0 +1,54 @@
+CC=			gcc
+CXX=		g++
+CFLAGS=		-g -Wall -O2 -m64 #-arch ppc
+CXXFLAGS=	$(CFLAGS)
+DFLAGS=		-D_FILE_OFFSET_BITS=64
+OBJS=		
+PROG=		md5sum-lite md5fa maq2sam-short maq2sam-long wgsim
+INCLUDES=	-I..
+SUBDIRS=	.
+
+.SUFFIXES:.c .o
+
+.c.o:
+		$(CC) -c $(CFLAGS) $(DFLAGS) $(INCLUDES) $< -o $@
+
+all:$(PROG)
+
+lib-recur all-recur clean-recur cleanlocal-recur install-recur:
+		@target=`echo $@ | sed s/-recur//`; \
+		wdir=`pwd`; \
+		list='$(SUBDIRS)'; for subdir in $$list; do \
+			cd $$subdir; \
+			$(MAKE) CC="$(CC)" DFLAGS="$(DFLAGS)" CFLAGS="$(CFLAGS)" \
+				INCLUDES="$(INCLUDES)" $$target || exit 1; \
+			cd $$wdir; \
+		done;
+
+lib:
+
+wgsim:wgsim.o
+		$(CC) $(CFLAGS) -o $@ wgsim.o -lm
+
+md5fa:md5.o md5fa.o md5.h ../kseq.h
+		$(CC) $(CFLAGS) -o $@ md5.o md5fa.o -lz
+
+md5sum-lite:md5sum-lite.o
+		$(CC) $(CFLAGS) -o $@ md5sum-lite.o
+
+md5sum-lite.o:md5.c md5.h
+		$(CC) -c $(CFLAGS) -DMD5SUM_MAIN -o $@ md5.c
+
+maq2sam-short:maq2sam.c
+		$(CC) $(CFLAGS) -o $@ maq2sam.c -lz
+
+maq2sam-long:maq2sam.c
+		$(CC) $(CFLAGS) -DMAQ_LONGREADS -o $@ maq2sam.c -lz
+
+md5fa.o:md5.h md5fa.c
+		$(CC) $(CFLAGS) -c -I.. -o $@ md5fa.c
+
+cleanlocal:
+		rm -fr gmon.out *.o a.out *.dSYM $(PROG) *~ *.a
+
+clean:cleanlocal-recur
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/blast2sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/blast2sam.pl
new file mode 100644
index 0000000..084f018
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/blast2sam.pl
@@ -0,0 +1,92 @@
+#!/usr/bin/perl -w
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+&blast2sam;
+
+sub blast2sam {
+  my %opts = ();
+  getopts('s', \%opts);
+  die("Usage: blast2sam.pl <in.blastn>\n") if (-t STDIN && @ARGV == 0);
+  my ($qlen, $slen, $q, $s, $qbeg, $qend, @sam, @cigar, @cmaux, $show_seq);
+  $show_seq = defined($opts{s});
+  @sam = (); @sam[0,4,6..8,10] = ('', 255, '*', 0, 0, '*');
+  while (<>) {
+	if (@cigar && (/^Query=/ || /Score =.*bits.*Expect/)) { # print
+	  &blast_print_sam(\@sam, \@cigar, \@cmaux, $qlen - $qend);
+	  @cigar = ();
+	}
+	if (/^Query= (\S+)/) {
+	  $sam[0] = $1;
+	} elsif (/\((\S+)\s+letters\)/) {
+	  $qlen = $1; $qlen =~ s/,//g;
+	} elsif (/^>(\S+)/) {
+	  $sam[2] = $1;
+	} elsif (/Length = (\d+)/) {
+	  $slen = $1;
+	} elsif (/Score =\s+(\S+) bits.+Expect(\(\d+\))? = (\S+)/) { # the start of an alignment block
+	  my ($as, $ev) = (int($1 + .499), $3);
+	  $ev = "1$ev" if ($ev =~ /^e/);
+	  @sam[1,3,9,11,12] = (0, 0, '', "AS:i:$as", "EV:Z:$ev");
+	  @cigar = (); $qbeg = 0;
+	  @cmaux = (0, 0, 0, '');
+	} elsif (/Strand = (\S+) \/ (\S+)/) {
+	  $sam[1] |= 0x10 if ($2 eq 'Minus');
+	} elsif (/Query\:\s(\d+)\s*(\S+)\s(\d+)/) {
+	  $q = $2;
+	  unless ($qbeg) {
+		$qbeg = $1;
+		push(@cigar, ($1-1) . "H") if ($1 > 1);
+	  }
+	  $qend = $3;
+	  if ($show_seq) {
+		my $x = $q;
+		$x =~ s/-//g; $sam[9] .= $x;
+	  }
+	} elsif (/Sbjct\:\s(\d+)\s*(\S+)\s(\d+)/) {
+	  $s = $2;
+	  if ($sam[1] & 0x10) {
+		$sam[3] = $3;
+	  } else {
+		$sam[3] = $1 unless ($sam[3]);
+	  }
+	  &aln2cm(\@cigar, \$q, \$s, \@cmaux);
+	}
+  }
+  &blast_print_sam(\@sam, \@cigar, \@cmaux, $qlen - $qend);
+}
+
+sub blast_print_sam {
+  my ($sam, $cigar, $cmaux, $qrest) = @_;
+  push(@$cigar, $cmaux->[1] . substr("MDI", $cmaux->[0], 1));
+  push(@$cigar, $qrest . 'H') if ($qrest);
+  if ($sam->[1] & 0x10) {
+	@$cigar = reverse(@$cigar);
+	$sam->[9] = reverse($sam->[9]);
+	$sam->[9] =~ tr/atgcrymkswATGCRYMKSW/tacgyrkmswTACGYRKMSW/;
+  }
+  $sam->[9] = '*' if (!$sam->[9]);
+  $sam->[5] = join('', @$cigar);
+  print join("\t", @$sam), "\n";
+}
+
+sub aln2cm {
+  my ($cigar, $q, $s, $cmaux) = @_;
+  my $l = length($$q);
+  for (my $i = 0; $i < $l; ++$i) {
+	my $op;
+	# set $op
+	if (substr($$q, $i, 1) eq '-') { $op = 2; }
+	elsif (substr($$s, $i, 1) eq '-') { $op = 1; }
+	else { $op = 0; }
+	# for CIGAR
+	if ($cmaux->[0] == $op) {
+	  ++$cmaux->[1];
+	} else {
+	  push(@$cigar, $cmaux->[1] . substr("MDI", $cmaux->[0], 1));
+	  $cmaux->[0] = $op; $cmaux->[1] = 1;
+	}
+  }
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/bowtie2sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/bowtie2sam.pl
new file mode 100644
index 0000000..5dff88d
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/bowtie2sam.pl
@@ -0,0 +1,92 @@
+#!/usr/bin/perl -w
+
+# Contact: lh3
+# Version: 0.1.1
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+&bowtie2sam;
+exit;
+
+sub bowtie2sam {
+  my %opts = ();
+  die("Usage: bowtie2sam.pl <aln.bowtie>\n") if (@ARGV == 0 && -t STDIN);
+  # core loop
+  my (@s, $last, @staging, $k, $best_s, $subbest_s, $best_k);
+  $last = '';
+  while (<>) {
+	my ($name, $nm) = &bowtie2sam_aux($_, \@s); # read_name, number of mismatches
+	if ($name eq $last) {
+	  # I do not know whether the multiple hits are ordered on the
+	  # number of mismatches. I assume they are not and so I have to
+	  # keep all these multiple hits in memory.
+	  @{$staging[$k]} = @s;
+	  if ($best_s > $nm) {
+		$subbest_s = $best_s;
+		$best_s = $nm;
+		$best_k = $k;
+	  } elsif ($subbest_s > $nm) {
+		$subbest_s = $nm;
+	  }
+	  ++$k;
+	} else {
+	  if ($last) {
+		if ($best_s == $subbest_s) {
+		  $staging[$best_k][4] = 0;
+		} elsif ($subbest_s - $best_s == 1) {
+		  $staging[$best_k][4] = 15 if ($staging[$best_k][4] > 15);
+		}
+		print join("\t", @{$staging[$best_k]}), "\n";
+	  }
+	  $k = 1; $best_s = $nm; $subbest_s = 1000; $best_k = 0;
+	  @{$staging[0]} = @s;
+	  $last = $name;
+	}
+  }
+  print join("\t", @{$staging[$best_k]}), "\n" if ($best_k >= 0);
+}
+
+sub bowtie2sam_aux {
+  my ($line, $s) = @_;
+  chomp($line);
+  my @t = split("\t", $line);
+  my $ret;
+  @$s = ();
+  # read name
+  $s->[0] = $ret = $t[0];
+  $s->[0] =~ s/\/[12]$//g;
+  # initial flag (will be updated later)
+  $s->[1] = 0;
+  # read & quality
+  $s->[9] = $t[4]; $s->[10] = $t[5];
+  # cigar
+  $s->[5] = length($s->[9]) . "M";
+  # coor
+  $s->[2] = $t[2]; $s->[3] = $t[3] + 1;
+  $s->[1] |= 0x10 if ($t[1] eq '-');
+  # mapQ
+  $s->[4] = $t[6] == 0? 25 : 0;
+  # mate coordinate
+  $s->[6] = '*'; $s->[7] = $s->[8] = 0;
+  # aux
+  my $nm = @t - 7;
+  push(@$s, "NM:i:" . (@t-7));
+  push(@$s, "X$nm:i:" . ($t[6]+1));
+  my $md = '';
+  if ($t[7]) {
+	$_ = $t[7];
+	my $a = 0;
+	while (/(\d+):[ACGTN]>([ACGTN])/gi) {
+	  my ($y, $z) = ($1, $2);
+	  $md .= (int($y)-$a) . $z;
+	  $a += $y - $a + 1;
+	}
+	$md .= length($s->[9]) - $a;
+  } else {
+	$md = length($s->[9]);
+  }
+  push(@$s, "MD:Z:$md");
+  return ($ret, $nm);
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/export2sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/export2sam.pl
new file mode 100644
index 0000000..8e3e280
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/export2sam.pl
@@ -0,0 +1,107 @@
+#!/usr/bin/perl -w
+
+# Contact: lh3
+# Version: 0.1.2 (03JAN2009)
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+&export2sam;
+exit;
+
+sub export2sam {
+  my ($fh1, $fh2, $is_paired);
+  $is_paired = (@ARGV >= 2);
+  die("export2sam.pl <read1.export> [<read2.export>]\n") if (@ARGV == 0);
+  open($fh1, $ARGV[0]) || die;
+  if ($is_paired) {
+	open($fh2, $ARGV[1]) || die;
+  }
+  # conversion table
+  my @conv_table;
+  for (-64..64) {
+	$conv_table[$_+64] = chr(int(33 + 10*log(1+10**($_/10.0))/log(10)+.499));
+  }
+  # core loop
+  while (<$fh1>) {
+	my (@s1, @s2);
+	&export2sam_aux($_, \@s1, \@conv_table, $is_paired);
+	if ($is_paired) {
+	  $_ = <$fh2>;
+	  &export2sam_aux($_, \@s2, \@conv_table, $is_paired);
+	  if (@s1 && @s2) { # then set mate coordinate
+		my $isize = 0;
+		if ($s1[2] ne '*' && $s1[2] eq $s2[2]) { # then calculate $isize
+		  my $x1 = ($s1[1] & 0x10)? $s1[3] + length($s1[9]) : $s1[3];
+		  my $x2 = ($s2[1] & 0x10)? $s2[3] + length($s2[9]) : $s2[3];
+		  $isize = $x2 - $x1;
+		}
+		# update mate coordinate
+		if ($s2[2] ne '*') {
+		  @s1[6..8] = (($s2[2] eq $s1[2])? "=" : $s2[2], $s2[3], $isize);
+		  $s1[1] |= 0x20 if ($s2[1] & 0x10);
+		} else {
+		  $s1[1] |= 0x8;
+		}
+		if ($s1[2] ne '*') {
+		  @s2[6..8] = (($s1[2] eq $s2[2])? "=" : $s1[2], $s1[3], -$isize);
+		  $s2[1] |= 0x20 if ($s1[1] & 0x10);
+		} else {
+		  $s2[1] |= 0x8;
+		}
+	  }
+	}
+	print join("\t", @s1), "\n" if (@s1);
+	print join("\t", @s2), "\n" if (@s2 && $is_paired);
+  }
+  close($fh1);
+  close($fh2) if ($is_paired);
+}
+
+sub export2sam_aux {
+  my ($line, $s, $ct, $is_paired) = @_;
+  chomp($line);
+  my @t = split("\t", $line);
+  @$s = ();
+  return if ($t[21] ne 'Y');
+  # read name
+  $s->[0] = $t[1]? "$t[0]_$t[1]:$t[2]:$t[3]:$t[4]:$t[5]" : "$t[0]:$t[2]:$t[3]:$t[4]:$t[5]";
+  # initial flag (will be updated later)
+  $s->[1] = 0;
+  $s->[1] |= 1 | 1<<(5 + $t[7]) if ($is_paired);
+  # read & quality
+  $s->[9] = $t[8]; $s->[10] = $t[9];
+  if ($t[13] eq 'R') { # then reverse the sequence and quality
+	$s->[9] = reverse($t[8]);
+	$s->[9] =~ tr/ACGTacgt/TGCAtgca/;
+	$s->[10] = reverse($t[9]);
+  }
+  $s->[10] =~ s/(.)/$ct->[ord($1)]/eg; # change coding
+  # cigar
+  $s->[5] = length($s->[9]) . "M";
+  # coor
+  my $has_coor = 0;
+  $s->[2] = "*";
+  if ($t[10] eq 'NM' || $t[10] eq 'QC') {
+	$s->[1] |= 0x4; # unmapped
+  } elsif ($t[10] =~ /(\d+):(\d+):(\d+)/) {
+	$s->[1] |= 0x4; # TODO: should I set BAM_FUNMAP in this case?
+	push(@$s, "H0:i:$1", "H1:i:$2", "H2:i:$3")
+  } else {
+	$s->[2] = $t[10];
+	$has_coor = 1;
+  }
+  $s->[3] = $has_coor? $t[12] : 0;
+  $s->[1] |= 0x10 if ($has_coor && $t[13] eq 'R');
+  # mapQ (TODO: should I choose the larger between $t[15] and $t[16]?)
+  $s->[4] = 0;
+  $s->[4] = $t[15] if ($t[15] ne '');
+  $s->[4] = $t[16] if ($t[16] ne '' && $s->[4] < $t[16]);
+  # mate coordinate
+  $s->[6] = '*'; $s->[7] = $s->[8] = 0;
+  # aux
+  push(@$s, "BC:Z:$t[6]") if ($t[6]);
+  push(@$s, "MD:Z:$t[14]") if ($has_coor);
+  push(@$s, "SM:i:$t[15]") if ($is_paired && $has_coor);
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/interpolate_sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/interpolate_sam.pl
new file mode 100644
index 0000000..6cd6831
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/interpolate_sam.pl
@@ -0,0 +1,125 @@
+#!/usr/bin/perl
+use strict;
+
+###Builds interpolated pileup from SAM file
+##@description counts bases between paired ends and piles up single end reads.
+##@output, uses a #header for the RNAME and then the number of reads per base
+##@author sm8@sanger.ac.uk, Stephen B. Montgomery
+
+##@caveats
+##Requires RNAME to have format as per example
+##      chromosome:NCBI36:18:1:76117153:1
+##      supercontig::NT_113883:1:137703:1
+##      clone::AC138827.3:1:149397:1
+##Expects simple CIGAR characters, M, I and D
+##Expects SAM file to be sorted.
+##Expects 0x0010 to mark second read in PE file (as has been the observed case from MAQ output) (important for line 77)
+
+##Verify and read in SAM file
+my $sam_file = $ARGV[0];
+if(!defined($sam_file)) { die("No sam file defined on arg 1"); }
+unless(-f $sam_file) { die("Sam file does not exist: $sam_file"); }
+open(SAM, $sam_file) || die("Cannot open sam file"); 
+
+##Globals
+my $current_location = ""; ##Current RNAME being processed
+my $current_size = 0; ##Size of sequence region being processed
+my $current_position = 1; ##Current base being processed
+my $open = 0; ##Number of open reads (PE reads that have not been closed)
+my %close = (); ##Hash of closing positions, when the current_position gets to this position it subtracts the
+    ##contained value from those open and deletes the indexed position from the hash
+
+while (my $line = <SAM>) {
+    my @tokens = split /\t/, $line;
+    
+    if ($current_location ne $tokens[2]) { ##Start a new sequence region 
+        for (my $i = $current_position; $i <= $current_size; $i++) { ##Close the previous sequence region
+            if (defined($close{$i})) {
+                $open = $open - $close{$i};
+                delete $close{$i};
+            }
+            print $open . "\n";
+        }
+        if ($current_location ne "") {
+            print "\n";
+        }
+        
+        ##Initiate a new sequence region
+        my @location_tokens = split /:/, $tokens[2]; 
+        $current_position = 1;
+        $current_location = $tokens[2];
+        $current_size = $location_tokens[4];
+        $open = 0;
+        %close = (); 
+        print "#" . $tokens[2] . "\n";
+        
+        ##Print pileup to just before the first read (will be 0)
+        for (my $current_position = 1; $current_position < $tokens[3]; $current_position++) {
+            print $open . "\n";
+        }
+        $current_position = $tokens[3];
+        
+    } else { ##Sequence region already open
+        if ($tokens[3] > $current_position) { ##If the new read's position is greater than the current position
+                                                ##cycle through to catch up to the current position
+            for (my $i = $current_position; $i < $tokens[3]; $i++) {
+                if (defined($close{$i})) {
+                    $open = $open - $close{$i};
+                    delete $close{$i};
+                }
+                print $open . "\n";
+            }
+            $current_position = $tokens[3];
+        }
+    }
+    $open++; ##Increment the number of open reads
+    
+    if (($tokens[1] & 0x0080 || $tokens[1] & 0x0040) && $tokens[1] & 0x0010 && $tokens[1] & 0x0002) { ##if second read of mate pair, add close condition
+        $open--;
+        my $parsed_cig = &parseCigar($tokens[5]);
+        my $seq_region_end = $tokens[3] + $parsed_cig->{'M'} + $parsed_cig->{'D'} - 1;
+        if (!defined($close{$seq_region_end + 1})) { $close{$seq_region_end + 1} = 0; }
+        $close{$seq_region_end + 1} = $close{$seq_region_end + 1} + 1;
+    } elsif (!($tokens[1] & 0x0001) || !($tokens[1] & 0x0002)) { ##if unpaired, add close condition
+        my $parsed_cig = &parseCigar($tokens[5]);
+        my $seq_region_end = $tokens[3] + $parsed_cig->{'M'} + $parsed_cig->{'D'} - 1;
+        if (!defined($close{$seq_region_end + 1})) { $close{$seq_region_end + 1} = 0; }
+        $close{$seq_region_end + 1} = $close{$seq_region_end + 1} + 1;
+    } else {
+        #do nothing
+    }
+}
+for (my $i = $current_position; $i <= $current_size; $i++) {  ##Finish up the last sequence region
+    if (defined($close{$i})) {
+        $open = $open - $close{$i};
+        delete $close{$i};
+    }
+    print $open . "\n";
+}
+print "\n";
+close(SAM);
+exit(0);
+
+##reads and tokenizes simple cigarline
+sub parseCigar() {
+    my $cigar_line = shift;
+    $cigar_line =~ s/([0-9]*[A-Z]{1})/$1\t/g;
+    my @cigar_tokens = split /\t/, $cigar_line;
+    my %parsed = ('M' => 0,
+                  'I' => 0,
+                  'D' => 0);
+    my @events = ();
+    for(my $i = 0; $i < scalar(@cigar_tokens); $i++) {
+        if ($cigar_tokens[$i] =~ /([0-9]+)([A-Z]{1})/g) {
+            if (!defined($parsed{$2})) { $parsed{$2} = 0; }
+            my $nt = $2;
+            if ($nt ne "M" && $nt ne "D"  && $nt ne "I") { $nt = "M"; }
+            $parsed{$nt} += $1;
+            my %event_el = ("t" => $nt,
+                            "n" => $1);
+            push @events, \%event_el;
+        }
+    }
+    $parsed{'events'} = \@events;
+    return \%parsed;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam-long b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam-long
new file mode 100755
index 0000000..2e6c51d
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam-long differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam-short b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam-short
new file mode 100755
index 0000000..4e535b6
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam-short differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam.c b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam.c
new file mode 100644
index 0000000..2bfbe2a
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/maq2sam.c
@@ -0,0 +1,173 @@
+#include <string.h>
+#include <zlib.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#define PACKAGE_VERSION "r439"
+
+//#define MAQ_LONGREADS
+
+#ifdef MAQ_LONGREADS
+#  define MAX_READLEN 128
+#else
+#  define MAX_READLEN 64
+#endif
+
+#define MAX_NAMELEN 36
+#define MAQMAP_FORMAT_OLD 0
+#define MAQMAP_FORMAT_NEW -1
+
+#define PAIRFLAG_FF      0x01
+#define PAIRFLAG_FR      0x02
+#define PAIRFLAG_RF      0x04
+#define PAIRFLAG_RR      0x08
+#define PAIRFLAG_PAIRED  0x10
+#define PAIRFLAG_DIFFCHR 0x20
+#define PAIRFLAG_NOMATCH 0x40
+#define PAIRFLAG_SW      0x80
+
+typedef struct
+{
+	uint8_t seq[MAX_READLEN]; /* the last base is the single-end mapping quality. */
+	uint8_t size, map_qual, info1, info2, c[2], flag, alt_qual;
+	uint32_t seqid, pos;
+	int dist;
+	char name[MAX_NAMELEN];
+} maqmap1_t;
+
+typedef struct
+{
+	int format, n_ref;
+	char **ref_name;
+	uint64_t n_mapped_reads;
+	maqmap1_t *mapped_reads;
+} maqmap_t;
+
+maqmap_t *maq_new_maqmap()
+{
+	maqmap_t *mm = (maqmap_t*)calloc(1, sizeof(maqmap_t));
+	mm->format = MAQMAP_FORMAT_NEW;
+	return mm;
+}
+void maq_delete_maqmap(maqmap_t *mm)
+{
+	int i;
+	if (mm == 0) return;
+	for (i = 0; i < mm->n_ref; ++i)
+		free(mm->ref_name[i]);
+	free(mm->ref_name);
+	free(mm->mapped_reads);
+	free(mm);
+}
+maqmap_t *maqmap_read_header(gzFile fp)
+{
+	maqmap_t *mm;
+	int k, len;
+	mm = maq_new_maqmap();
+	gzread(fp, &mm->format, sizeof(int));
+	if (mm->format != MAQMAP_FORMAT_NEW) {
+		if (mm->format > 0) {
+			fprintf(stderr, "** Obsolete map format is detected. Please use 'mapass2maq' command to convert the format.\n");
+			exit(3);
+		}
+		assert(mm->format == MAQMAP_FORMAT_NEW);
+	}
+	gzread(fp, &mm->n_ref, sizeof(int));
+	mm->ref_name = (char**)calloc(mm->n_ref, sizeof(char*));
+	for (k = 0; k != mm->n_ref; ++k) {
+		gzread(fp, &len, sizeof(int));
+		mm->ref_name[k] = (char*)malloc(len * sizeof(char));
+		gzread(fp, mm->ref_name[k], len);
+	}
+	/* read number of mapped reads */
+	gzread(fp, &mm->n_mapped_reads, sizeof(uint64_t));
+	return mm;
+}
+
+void maq2tam_core(gzFile fp, const char *rg)
+{
+	maqmap_t *mm;
+	maqmap1_t mm1, *m1;
+	int ret;
+	m1 = &mm1;
+	mm = maqmap_read_header(fp);
+	while ((ret = gzread(fp, m1, sizeof(maqmap1_t))) == sizeof(maqmap1_t)) {
+		int j, flag = 0, se_mapq = m1->seq[MAX_READLEN-1];
+		if (m1->flag) flag |= 1;
+		if ((m1->flag&PAIRFLAG_PAIRED) || ((m1->flag&PAIRFLAG_SW) && m1->flag != 192)) flag |= 2;
+		if (m1->flag == 192) flag |= 4;
+		if (m1->flag == 64) flag |= 8;
+		if (m1->pos&1) flag |= 0x10;
+		if ((flag&1) && m1->dist != 0) {
+			int c;
+			if (m1->dist > 0) {
+				if (m1->flag&(PAIRFLAG_FF|PAIRFLAG_RF)) c = 0;
+				else if (m1->flag&(PAIRFLAG_FR|PAIRFLAG_RR)) c = 1;
+				else c = m1->pos&1;				
+			} else {
+				if (m1->flag&(PAIRFLAG_FF|PAIRFLAG_FR)) c = 0;
+				else if (m1->flag&(PAIRFLAG_RF|PAIRFLAG_RR)) c = 1;
+				else c = m1->pos&1;
+			}
+			if (c) flag |= 0x20;
+		}
+		if (m1->flag) {
+			int l = strlen(m1->name);
+			if (m1->name[l-2] == '/') {
+				flag |= (m1->name[l-1] == '1')? 0x40 : 0x80;
+				m1->name[l-2] = '\0';
+			}
+		}
+		printf("%s\t%d\t", m1->name, flag);
+		printf("%s\t%d\t", mm->ref_name[m1->seqid], (m1->pos>>1)+1);
+		if (m1->flag == 130) {
+			int c = (int8_t)m1->seq[MAX_READLEN-1];
+			printf("%d\t", m1->alt_qual);
+			if (c == 0) printf("%dM\t", m1->size);
+			else {
+				if (c > 0) printf("%dM%dI%dM\t", m1->map_qual, c, m1->size - m1->map_qual - c);
+				else printf("%dM%dD%dM\t", m1->map_qual, -c, m1->size - m1->map_qual);
+			}
+			se_mapq = 0; // zero SE mapQ for reads aligned by SW
+		} else {
+			if (flag&4) printf("0\t*\t");
+			else printf("%d\t%dM\t", m1->map_qual, m1->size);
+		}
+		printf("*\t0\t%d\t", m1->dist);
+		for (j = 0; j != m1->size; ++j) {
+			if (m1->seq[j] == 0) putchar('N');
+			else putchar("ACGT"[m1->seq[j]>>6&3]);
+		}
+		putchar('\t');
+		for (j = 0; j != m1->size; ++j)
+			putchar((m1->seq[j]&0x3f) + 33);
+		putchar('\t');
+		if (rg) printf("RG:Z:%s\t", rg);
+		if (flag&4) { // unmapped
+			printf("MF:i:%d\n", m1->flag);
+		} else {
+			printf("MF:i:%d\t", m1->flag);
+			if (m1->flag) printf("AM:i:%d\tSM:i:%d\t", m1->alt_qual, se_mapq);
+			printf("NM:i:%d\tUQ:i:%d\tH0:i:%d\tH1:i:%d\n", m1->info1&0xf, m1->info2, m1->c[0], m1->c[1]);
+		}
+	}
+	if (ret > 0)
+		fprintf(stderr, "Truncated! Continue anyway.\n");
+	maq_delete_maqmap(mm);
+}
+
+int main(int argc, char *argv[])
+{
+	gzFile fp;
+	if (argc == 1) {
+		fprintf(stderr, "Version: %s\n", PACKAGE_VERSION);
+		fprintf(stderr, "Usage: maq2sam <in.map> [<readGroup>]\n");
+		return 1;
+	}
+	fp = strcmp(argv[1], "-")? gzopen(argv[1], "r") : gzdopen(fileno(stdin), "r");
+	maq2tam_core(fp, argc > 2? argv[2] : 0);
+	gzclose(fp);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.c b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.c
new file mode 100644
index 0000000..55ae181
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.c
@@ -0,0 +1,296 @@
+/*
+ * This code implements the MD5 message-digest algorithm.
+ * The algorithm is due to Ron Rivest.	This code was
+ * written by Colin Plumb in 1993, no copyright is claimed.
+ * This code is in the public domain; do with it what you wish.
+ *
+ * Equivalent code is available from RSA Data Security, Inc.
+ * This code has been tested against that, and is equivalent,
+ * except that you don't need to include two pages of legalese
+ * with every copy.
+ *
+ * To compute the message digest of a chunk of bytes, declare an
+ * MD5Context structure, pass it to MD5Init, call MD5Update as
+ * needed on buffers full of bytes, and then call MD5Final, which
+ * will fill a supplied 16-byte array with the digest.
+ */
+
+/* Brutally hacked by John Walker back from ANSI C to K&R (no
+   prototypes) to maintain the tradition that Netfone will compile
+   with Sun's original "cc". */
+
+#include <string.h>
+#include "md5.h"
+
+#ifndef HIGHFIRST
+#define byteReverse(buf, len)	/* Nothing */
+#else
+/*
+ * Note: this code is harmless on little-endian machines.
+ */
+void byteReverse(buf, longs)
+    unsigned char *buf; unsigned longs;
+{
+    uint32_t t;
+    do {
+	t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
+	    ((unsigned) buf[1] << 8 | buf[0]);
+	*(uint32_t *) buf = t;
+	buf += 4;
+    } while (--longs);
+}
+#endif
+
+void MD5Transform(uint32_t buf[4], uint32_t in[16]);
+
+
+/*
+ * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ */
+void MD5Init(ctx)
+    struct MD5Context *ctx;
+{
+    ctx->buf[0] = 0x67452301;
+    ctx->buf[1] = 0xefcdab89;
+    ctx->buf[2] = 0x98badcfe;
+    ctx->buf[3] = 0x10325476;
+
+    ctx->bits[0] = 0;
+    ctx->bits[1] = 0;
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+void MD5Update(ctx, buf, len)
+    struct MD5Context *ctx; unsigned char *buf; unsigned len;
+{
+    uint32_t t;
+
+    /* Update bitcount */
+
+    t = ctx->bits[0];
+    if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t)
+	ctx->bits[1]++; 	/* Carry from low to high */
+    ctx->bits[1] += len >> 29;
+
+    t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */
+
+    /* Handle any leading odd-sized chunks */
+
+    if (t) {
+	unsigned char *p = (unsigned char *) ctx->in + t;
+
+	t = 64 - t;
+	if (len < t) {
+	    memcpy(p, buf, len);
+	    return;
+	}
+	memcpy(p, buf, t);
+	byteReverse(ctx->in, 16);
+	MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+	buf += t;
+	len -= t;
+    }
+    /* Process data in 64-byte chunks */
+
+    while (len >= 64) {
+	memcpy(ctx->in, buf, 64);
+	byteReverse(ctx->in, 16);
+	MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+	buf += 64;
+	len -= 64;
+    }
+
+    /* Handle any remaining bytes of data. */
+
+    memcpy(ctx->in, buf, len);
+}
+
+/*
+ * Final wrapup - pad to 64-byte boundary with the bit pattern 
+ * 1 0* (64-bit count of bits processed, MSB-first)
+ */
+void MD5Final(digest, ctx)
+    unsigned char digest[16]; struct MD5Context *ctx;
+{
+    unsigned count;
+    unsigned char *p;
+
+    /* Compute number of bytes mod 64 */
+    count = (ctx->bits[0] >> 3) & 0x3F;
+
+    /* Set the first char of padding to 0x80.  This is safe since there is
+       always at least one byte free */
+    p = ctx->in + count;
+    *p++ = 0x80;
+
+    /* Bytes of padding needed to make 64 bytes */
+    count = 64 - 1 - count;
+
+    /* Pad out to 56 mod 64 */
+    if (count < 8) {
+	/* Two lots of padding:  Pad the first block to 64 bytes */
+	memset(p, 0, count);
+	byteReverse(ctx->in, 16);
+	MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+
+	/* Now fill the next block with 56 bytes */
+	memset(ctx->in, 0, 56);
+    } else {
+	/* Pad block to 56 bytes */
+	memset(p, 0, count - 8);
+    }
+    byteReverse(ctx->in, 14);
+
+    /* Append length in bits and transform */
+    ((uint32_t *) ctx->in)[14] = ctx->bits[0];
+    ((uint32_t *) ctx->in)[15] = ctx->bits[1];
+
+    MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+    byteReverse((unsigned char *) ctx->buf, 4);
+    memcpy(digest, ctx->buf, 16);
+    memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
+}
+
+
+/* The four core functions - F1 is optimized somewhat */
+
+/* #define F1(x, y, z) (x & y | ~x & z) */
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+/* This is the central step in the MD5 algorithm. */
+#define MD5STEP(f, w, x, y, z, data, s) \
+	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+
+/*
+ * The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data.  MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ */
+void MD5Transform(buf, in)
+    uint32_t buf[4]; uint32_t in[16];
+{
+    register uint32_t a, b, c, d;
+
+    a = buf[0];
+    b = buf[1];
+    c = buf[2];
+    d = buf[3];
+
+    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+    buf[0] += a;
+    buf[1] += b;
+    buf[2] += c;
+    buf[3] += d;
+}
+
+/* lh3: the following code is added by me */
+
+#ifdef MD5SUM_MAIN
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#define HEX_STR "0123456789abcdef"
+
+static void md5_one(const char *fn)
+{
+	unsigned char buf[4096], digest[16];
+	MD5_CTX md5;
+	int l;
+	FILE *fp;
+
+	fp = strcmp(fn, "-")? fopen(fn, "r") : stdin;
+	if (fp == 0) {
+		fprintf(stderr, "md5sum: %s: No such file or directory\n", fn);
+		exit(1);
+	}
+	MD5Init(&md5);
+	while ((l = fread(buf, 1, 4096, fp)) > 0)
+		MD5Update(&md5, buf, l);
+	MD5Final(digest, &md5);
+	if (fp != stdin) fclose(fp);
+	for (l = 0; l < 16; ++l)
+		printf("%c%c", HEX_STR[digest[l]>>4&0xf], HEX_STR[digest[l]&0xf]);
+	printf("  %s\n", fn);
+}
+int main(int argc, char *argv[])
+{
+	int i;
+	if (argc == 1) md5_one("-");
+	else for (i = 1; i < argc; ++i) md5_one(argv[i]);
+	return 0;
+}
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.h b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.h
new file mode 100644
index 0000000..44121e4
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.h
@@ -0,0 +1,57 @@
+/*
+  This file is adapted from a program in this page:
+
+  http://www.fourmilab.ch/md5/
+
+  The original source code does not work on 64-bit machines due to the
+  wrong typedef "uint32". I also added prototypes.
+
+  -lh3
+ */
+
+#ifndef MD5_H
+#define MD5_H
+
+/*  The following tests optimise behaviour on little-endian
+    machines, where there is no need to reverse the byte order
+    of 32 bit words in the MD5 computation.  By default,
+    HIGHFIRST is defined, which indicates we're running on a
+    big-endian (most significant byte first) machine, on which
+    the byteReverse function in md5.c must be invoked. However,
+    byteReverse is coded in such a way that it is an identity
+    function when run on a little-endian machine, so calling it
+    on such a platform causes no harm apart from wasting time. 
+    If the platform is known to be little-endian, we speed
+    things up by undefining HIGHFIRST, which defines
+    byteReverse as a null macro.  Doing things in this manner
+    insures we work on new platforms regardless of their byte
+    order.  */
+
+#define HIGHFIRST
+
+#if __LITTLE_ENDIAN__ != 0
+#undef HIGHFIRST
+#endif
+
+#include <stdint.h>
+
+struct MD5Context {
+        uint32_t buf[4];
+        uint32_t bits[2];
+        unsigned char in[64];
+};
+
+void MD5Init(struct MD5Context *ctx);
+void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned len);
+void MD5Final(unsigned char digest[16], struct MD5Context *ctx);
+
+/*
+ * This is needed to make RSAREF happy on some MS-DOS compilers.
+ */
+typedef struct MD5Context MD5_CTX;
+
+/*  Define CHECK_HARDWARE_PROPERTIES to have main,c verify
+    byte order and uint32_t settings.  */
+#define CHECK_HARDWARE_PROPERTIES
+
+#endif /* !MD5_H */
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.o b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.o
new file mode 100644
index 0000000..f21a61c
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5.o differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa
new file mode 100755
index 0000000..63886b6
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa.c b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa.c
new file mode 100644
index 0000000..7a165bf
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa.c
@@ -0,0 +1,58 @@
+#include <stdio.h>
+#include <zlib.h>
+#include "md5.h"
+#include "kseq.h"
+
+#define HEX_STR "0123456789abcdef"
+
+KSEQ_INIT(gzFile, gzread)
+
+static void md5_one(const char *fn)
+{
+	MD5_CTX md5_one, md5_all;
+	int l, i, k;
+	gzFile fp;
+	kseq_t *seq;
+	unsigned char unordered[16], digest[16];
+
+	for (l = 0; l < 16; ++l) unordered[l] = 0;
+	fp = strcmp(fn, "-")? gzopen(fn, "r") : gzdopen(fileno(stdin), "r");
+	if (fp == 0) {
+		fprintf(stderr, "md5fa: %s: No such file or directory\n", fn);
+		exit(1);
+	}
+	
+	MD5Init(&md5_all);
+	seq = kseq_init(fp);
+	while ((l = kseq_read(seq)) >= 0) {
+		for (i = k = 0; i < seq->seq.l; ++i) {
+			if (islower(seq->seq.s[i])) seq->seq.s[k++] = toupper(seq->seq.s[i]);
+			else if (isupper(seq->seq.s[i])) seq->seq.s[k++] = seq->seq.s[i];
+		}
+		MD5Init(&md5_one);
+		MD5Update(&md5_one, (unsigned char*)seq->seq.s, k);
+		MD5Final(digest, &md5_one);
+		for (l = 0; l < 16; ++l) {
+			printf("%c%c", HEX_STR[digest[l]>>4&0xf], HEX_STR[digest[l]&0xf]);
+			unordered[l] ^= digest[l];
+		}
+		printf("  %s  %s\n", fn, seq->name.s);
+		MD5Update(&md5_all, (unsigned char*)seq->seq.s, k);
+	}
+	MD5Final(digest, &md5_all);
+	kseq_destroy(seq);
+	for (l = 0; l < 16; ++l)
+		printf("%c%c", HEX_STR[digest[l]>>4&0xf], HEX_STR[digest[l]&0xf]);
+	printf("  %s  >ordered\n", fn);
+	for (l = 0; l < 16; ++l)
+		printf("%c%c", HEX_STR[unordered[l]>>4&0xf], HEX_STR[unordered[l]&0xf]);
+	printf("  %s  >unordered\n", fn);
+}
+
+int main(int argc, char *argv[])
+{
+	int i;
+	if (argc == 1) md5_one("-");
+	else for (i = 1; i < argc; ++i) md5_one(argv[i]);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa.o b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa.o
new file mode 100644
index 0000000..99b029b
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5fa.o differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5sum-lite b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5sum-lite
new file mode 100755
index 0000000..2865160
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5sum-lite differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5sum-lite.o b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5sum-lite.o
new file mode 100644
index 0000000..b0d3d60
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/md5sum-lite.o differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/novo2sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/novo2sam.pl
new file mode 100644
index 0000000..8b53c9e
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/novo2sam.pl
@@ -0,0 +1,281 @@
+#!/usr/bin/perl -w
+
+# Contact: lh3
+# Version: 0.1.3
+
+#Modified by Zayed Albertyn(zayed.albertyn@gmail.com) & Colin Hercus(colin@novocraft.com)
+
+#use strict;
+#use warnings;
+use Data::Dumper;
+use Getopt::Std;
+
+&novo2sam;
+exit;
+
+sub mating {
+  my ($s1, $s2) = @_;
+  my $isize = 0;
+  if ($s1->[2] ne '*' && $s1->[2] eq $s2->[2]) { # then calculate $isize
+	my $x1 = ($s1->[1] & 0x10)? $s1->[3] + length($s1->[9]) : $s1->[3];
+	my $x2 = ($s2->[1] & 0x10)? $s2->[3] + length($s2->[9]) : $s2->[3];
+	$isize = $x2 - $x1;
+  }
+  # update mate coordinate
+  if ($s2->[2] ne '*') {
+	@$s1[6..8] = (($s2->[2] eq $s1->[2])? "=" : $s2->[2], $s2->[3], $isize);
+	$s1->[1] |= 0x20 if ($s2->[1] & 0x10);
+  } else {
+	$s1->[1] |= 0x8;
+  }
+  if ($s1->[2] ne '*') {
+	@$s2[6..8] = (($s1->[2] eq $s2->[2])? "=" : $s1->[2], $s1->[3], -$isize);
+	$s2->[1] |= 0x20 if ($s1->[1] & 0x10);
+  } else {
+	$s2->[1] |= 0x8;
+  }
+}
+
+sub novo2sam {
+  my %opts = ();
+  getopts("p", \%opts);
+  die("Usage: novo2sam.pl [-p] <aln.novo>\n") if (@ARGV == 0);
+  my $is_paired = defined($opts{p});
+  # core loop
+  my @s1 = ();
+  my @s2 = ();
+  my ($s_last, $s_curr) = (\@s1, \@s2);
+  while (<>) {
+	next if (/^#/);
+	next if (/(QC|NM)\s*$/ || /(R\s+\d+)\s*$/);
+	&novo2sam_aux($_, $s_curr, $is_paired);
+	if (@$s_last != 0 && $s_last->[0] eq $s_curr->[0]) {
+	  &mating($s_last, $s_curr);
+	  print join("\t", @$s_last), "\n";
+	  print join("\t", @$s_curr), "\n";
+	  @$s_last = (); @$s_curr = ();
+	} else {
+	  print join("\t", @$s_last), "\n" if (@$s_last != 0);
+	  my $s = $s_last; $s_last = $s_curr; $s_curr = $s;
+	}
+  }
+  print join("\t", @$s_last), "\n" if (@$s_last != 0);
+}
+
+sub novo2sam_aux {
+  my ($line, $s, $is_paired) = @_;
+
+  chomp($line);
+  my @t = split(/\s+/, $line);
+  my @variations =  @t[13 .. $#t];
+  @$s = ();
+  return if ($t[4] ne 'U');
+  my $len = length($t[2]);
+  # read name
+  $s->[0] = substr($t[0], 1);
+  $s->[0] =~ s/\/[12]$//g;
+  # initial flag (will be updated later)
+  $s->[1] = 0;
+  $s->[1] |= 1 | 1<<($t[1] eq 'L'? 6 : 7);
+  $s->[1] |= 2 if ($t[10] eq '.');
+  # read & quality
+  if ($t[9] eq 'R') {
+	$s->[9] = reverse($t[2]);
+	$s->[10] = reverse($t[3]);
+	$s->[9] =~ tr/ACGTRYMKWSNacgtrymkwsn/TGCAYRKMWSNtgcayrkmwsn/;
+  } else {
+	$s->[9] = $t[2]; $s->[10] = $t[3];
+  }
+  # cigar
+   my $cigarstring ="";
+  if (scalar @variations ==0 ) {
+ 	 $s->[5] = $len . "M"; # IMPORTANT: this cigar is not correct for gapped alignment
+  } else {
+	#convert to correct CIGAR
+	my $tmpstr =  join" ",@variations ;
+	if ( $tmpstr=~ /\+|\-/ ) {
+		$cigarstring  = cigar_method($line,\@variations,$len);
+		$s->[5]=$cigarstring;
+	} else {
+		$s->[5]=$len. "M";
+	}
+}  
+
+# coor
+  $s->[2] = substr($t[7], 1); $s->[3] = $t[8];
+  $s->[1] |= 0x10 if ($t[9] eq 'R');
+  # mapQ
+  $s->[4] = $t[5] > $t[6]? $t[5] : $t[6];
+  # mate coordinate
+  $s->[6] = '*'; $s->[7] = $s->[8] = 0;
+  # aux
+  push(@$s, "NM:i:".(@t-13));
+  my $md = '';
+  $md = mdtag($md,$line,\@variations,$len);
+  push(@$s, "MD:Z:$md");
+
+}
+
+sub mdtag {
+	my $oldmd = shift;
+	my $line = shift;
+	my $ref =shift;
+	my $rdlen  = shift;
+	my @variations = @$ref;
+	my $string="";
+	my $mdtag="";
+	my $t=1;
+	my $q=1;
+	my $deleteflag=0;
+	my $len =0;
+	foreach $string (@variations) {
+		my ($indeltype,$insert) = indeltype($string);
+		if ($indeltype eq "+") {
+			$len = length ($insert);
+			$q+=$len;
+                  next;
+		}
+		my $pos = $1 if $string =~ /^(\d+)/;
+		$len = $pos - $t;	
+		if ($len !=0 || ($deleteflag eq 1 && $indeltype eq ">")) {
+			$mdtag.=$len;
+		}	
+		$t+=$len;
+		$q+=$len;
+		if ($indeltype eq ">") {
+			$mdtag.=$insert;
+			$deleteflag=0;
+		      $t+=1;
+		      $q+=1;
+		}
+		if ($indeltype eq "-") {
+			my $deletedbase = $2 if $string =~ /(\d+)\-([A-Za-z]+)/;
+			if ($deleteflag == 0 ) {
+				$mdtag.="^";
+			}
+			$mdtag.=$deletedbase;
+			$deleteflag=1;
+			$t+=1;
+		}
+	}
+	$len = $rdlen - $q + 1;
+	if ($len > 0) {
+		$mdtag.="$len";
+	}
+#	print "In:$line\n";
+#	print "MD: OLD => NEW\nMD: $oldmd => $mdtag\n\n";
+
+	return $mdtag;
+}
+
+sub indeltype {
+	my $string =  shift;
+	my $insert="";
+	my $indeltype;
+               if ($string =~ /([A-Za-z]+)\>/) {
+                        $indeltype=">";
+                        $insert=$1;
+                } elsif ($string =~ /\-/) {
+                        $indeltype="-";
+                } elsif ($string =~ /\+([A-Za-z]+)/) {
+                        $indeltype="+";
+                        $insert=$1;
+                }
+	 return ($indeltype,$insert);
+	
+}
+
+
+sub cigar_method {
+	my $line = shift;
+	my $ref =shift;
+	my $rdlen  = shift;
+	my @variations = @$ref;
+	my $string="";
+	my $type="";
+	my $t =1;
+	my $q=1;
+	my $indeltype="";
+	my $cigar=  "";	
+	my $insert = "";
+	my $len=0;
+	my @cig=();
+	foreach $string (@variations) {
+		next if $string =~  />/;
+		my $pos = $1 if $string =~ /^(\d+)/;
+		
+		if ($string =~ /\+([A-Za-z]+)/) {	
+			$indeltype="+";
+			$insert = $1;
+		}elsif ($string =~ /\-([A-Za-z]+)/) {
+			$indeltype="-";
+			$insert = $1;
+		}
+#print "$pos $indeltype $insert $t $q\n";	
+		$len = $pos - $t;
+		if ( $len > 0) {
+			$cigar.=$len."M";
+			push(@cig,$len."M");
+		}
+		$t+=$len;
+		$q+=$len;
+
+		if ($indeltype eq "-") {
+			$cigar.="D";
+			push(@cig,"D");
+			$t++;
+		}
+		if ($indeltype eq "+") {
+			$len = length ($insert);
+			if ($len == 1) {
+				$cigar.="I";
+				push(@cig,"I");
+			}
+			if ($len > 1) {
+				$cigar.=$len."I";
+				push(@cig,$len."I")
+			}
+			$q+=$len;
+		}
+		$insert="";
+	}
+	$len= $rdlen - $q + 1;
+	if ($len > 0) {
+		$cigar.=$len."M"; 
+		push(@cig,$len."M");
+	}
+	
+      $cigar = newcigar($cigar,'D');
+      $cigar = newcigar($cigar,'I');
+	
+	#print "$line\n";
+	#print "c CIGAR:\t$cigar\n\n";
+	return $cigar;
+
+}
+
+
+
+sub newcigar {
+	my $cigar = shift;
+	my $char = shift;
+	my $new = "";
+	my $copy = $cigar;
+#print "$cigar\n";
+	$copy =~ s/^($char+)/$1;/g;
+#print "$copy\n";
+	$copy =~ s/([^0-9$char])($char+)/$1;$2;/g;
+#print "$copy\n";
+	my @parts = split(/;/,$copy);
+	my $el="";
+	foreach $el (@parts) {
+#print "$el\n";
+		if ($el =~ /^$char+$/) {
+			$new.=length($el).$char;
+		}else {
+			$new.=$el;
+		}
+
+	}
+     return  $new;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/psl2sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/psl2sam.pl
new file mode 100644
index 0000000..a96a6de
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/psl2sam.pl
@@ -0,0 +1,65 @@
+#!/usr/bin/perl -w
+
+# Author: lh3
+
+# This script calculates a score using the BLAST scoring
+# system. However, I am not sure how to count gap opens and gap
+# extensions. It seems to me that column 5-8 are not what I am
+# after. This script counts gaps from the last three columns. It does
+# not generate reference skip (N) in the CIGAR as it is not easy to
+# directly tell which gaps correspond to introns.
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+my %opts = (a=>1, b=>3, q=>5, r=>2);
+getopts('a:b:q:r:', \%opts);
+die("Usage: psl2sam.pl [-a $opts{a}] [-b $opts{b}] [-q $opts{q}] [-r $opts{r}] <in.psl>\n") if (@ARGV == 0 && -t STDIN);
+
+my @stack;
+my $last = '';
+my ($a, $b, $q, $r) = ($opts{a}, $opts{b}, $opts{q}, $opts{r});
+while (<>) {
+  next unless (/^\d/);
+  my @t = split;
+  my @s;
+  my $cigar = '';
+  if ($t[8] eq '-') {
+	my $tmp = $t[11];
+	$t[11] = $t[10] - $t[12];
+	$t[12] = $t[10] - $tmp;
+  }
+  @s[0..4] = ($t[9], (($t[8] eq '+')? 0 : 16), $t[13], $t[15]+1, 0);
+  @s[6..10] = ('*', 0, 0, '*', '*');
+  $cigar .= $t[11].'H' if ($t[11]); # 5'-end clipping
+  my @x = split(',', $t[18]);
+  my @y = split(',', $t[19]);
+  my @z = split(',', $t[20]);
+  my ($y0, $z0) = ($y[0], $z[0]);
+  my ($gap_open, $gap_ext) = (0, 0, 0);
+  for (1 .. $t[17]-1) {
+	my $ly = $y[$_] - $y[$_-1] - $x[$_-1];
+	my $lz = $z[$_] - $z[$_-1] - $x[$_-1];
+	if ($ly < $lz) { # del: the reference gap is longer
+	  ++$gap_open;
+	  $gap_ext += $lz - $ly;
+	  $cigar .= ($y[$_] - $y0) . 'M';
+	  $cigar .= ($lz - $ly) . 'D';
+	  ($y0, $z0) = ($y[$_], $z[$_]);
+	} elsif ($lz < $ly) { # ins: the query gap is longer
+	  ++$gap_open;
+	  $gap_ext += $ly - $lz;
+	  $cigar .= ($z[$_] - $z0) . 'M';
+	  $cigar .= ($ly - $lz) . 'I';
+	  ($y0, $z0) = ($y[$_], $z[$_]);
+	}
+  }
+  $cigar .= ($t[12] - $y0) . 'M';
+  $cigar .= ($t[10] - $t[12]).'H' if ($t[10] != $t[12]); # 3'-end clipping
+  $s[5] = $cigar;
+  my $score = $a * $t[0] - $b * $t[1] - $q * $gap_open - $r * $gap_ext;
+  $score = 0 if ($score < 0);
+  $s[11] = "AS:i:$score";
+  print join("\t", @s), "\n";
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/sam2vcf.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/sam2vcf.pl
new file mode 100644
index 0000000..ede7bd8
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/sam2vcf.pl
@@ -0,0 +1,217 @@
+#!/usr/bin/perl -w
+# 
+# VCF specs: http://www.1000genomes.org/wiki/doku.php?id=1000_genomes:analysis:vcfv3.2
+
+# Contact: pd3@sanger
+# Version: 2009-10-08
+
+use strict;
+use warnings;
+use Carp;
+
+my $opts = parse_params();
+do_pileup_to_vcf($opts);
+
+exit;
+
+#---------------
+
+sub error
+{
+    my (@msg) = @_;
+    if ( scalar @msg ) { croak(@msg); }
+    die
+        "Usage: sam2vcf.pl [OPTIONS] < in.pileup > out.vcf\n",
+        "Options:\n",
+        "   -r, -refseq <file.fa>            The reference sequence, required when indels are present.\n",
+        "   -h, -?, --help                   This help message.\n",
+        "\n";
+}
+
+
+sub parse_params
+{
+    my %opts = ();
+
+    $opts{fh_in}  = *STDIN;
+    $opts{fh_out} = *STDOUT;
+
+    while (my $arg=shift(@ARGV))
+    {
+        if ( $arg eq '-r' || $arg eq '--refseq' ) { $opts{refseq}=shift(@ARGV); next; }
+        if ( $arg eq '-?' || $arg eq '-h' || $arg eq '--help' ) { error(); }
+
+        error("Unknown parameter \"$arg\". Run -h for help.\n");
+    }
+    return \%opts;
+}
+
+sub iupac_to_gtype
+{
+    my ($ref,$base) = @_;
+    my %iupac = (
+            'K' => ['G','T'],
+            'M' => ['A','C'],
+            'S' => ['C','G'],
+            'R' => ['A','G'],
+            'W' => ['A','T'],
+            'Y' => ['C','T'],
+            );
+    if ( !exists($iupac{$base}) ) 
+    { 
+        if ( $ref eq $base ) { return ('.','0|0'); }
+        return ($base,'1|1');
+    }
+    my $gt = $iupac{$base};
+    if ( $$gt[0] eq $ref  ) { return ($$gt[1],'0|1'); }
+    elsif ( $$gt[1] eq $ref ) { return ($$gt[0],'0|1'); }
+    return ("$$gt[0],$$gt[1]",'1|2');
+}
+
+
+sub parse_indel
+{
+    my ($cons) = @_;
+    if ( $cons=~/^-/ ) 
+    { 
+        my $len = length($');
+        return "D$len"; 
+    }
+    elsif ( $cons=~/^\+/ ) { return "I$'"; }
+    elsif ( $cons eq '*' ) { return undef; }
+    error("FIXME: could not parse [$cons]\n");
+}
+
+
+# An example of the pileup format:
+#   1       3000011 C       C       32      0       98      1       ^~,     A
+#   1       3002155 *       +T/+T   53      119     52      5       +T      *       4       1       0
+#   1       3003094 *       -TT/-TT 31      164     60      11      -TT     *       5       6       0
+#   1       3073986 *       */-AAAAAAAAAAAAAA       3       3       45      9       *       -AAAAAAAAAAAAAA 7       2       0
+#
+sub do_pileup_to_vcf
+{
+    my ($opts) = @_;
+
+    my $fh_in  = $$opts{fh_in};
+    my $fh_out = $$opts{fh_out};
+    my ($prev_chr,$prev_pos,$prev_ref);
+    my $refseq;
+
+    while (my $line=<$fh_in>)
+    {
+        chomp($line);
+        my ($chr,$pos,$ref,$cons,$cons_qual,$snp_qual,$rms_qual,$depth,@items) = split(/\t/,$line);
+
+        my ($alt,$gt);
+        if ( $ref eq '*' )
+        {
+            # An indel is involved.
+            if ($chr ne $prev_chr || $pos ne $prev_pos) 
+            {
+                if ( !$$opts{refseq} ) { error("Cannot do indels without the reference.\n"); }
+                if ( !$refseq ) { $refseq = Fasta->new(file=>$$opts{refseq}); }
+                $ref = $refseq->get_base($chr,$pos);
+            }
+            else { $ref = $prev_ref; }
+
+            # One of the alleles can be a reference and it can come in arbitrary order
+            my ($al1,$al2) = split(m{/},$cons);
+            my $alt1 = parse_indel($al1);
+            my $alt2 = parse_indel($al2);
+            if ( !$alt1 && !$alt2 ) { error("FIXME: could not parse indel:\n", $line); }
+            if ( $alt1 && $alt2 && $alt1 eq $alt2 ) { $alt2=''; }
+            if ( !$alt1 ) 
+            { 
+                $alt=$alt2; 
+                $gt='0|1'; 
+            }
+            elsif ( !$alt2 ) 
+            { 
+                $alt=$alt1; 
+                $gt='0|1'; 
+            }
+            else 
+            { 
+                $alt="$alt1,$alt2"; 
+                $gt='1|2'; 
+            }
+        }
+        else
+        {
+            # SNP
+            ($alt,$gt) = iupac_to_gtype($ref,$cons);
+        }
+
+        print $fh_out "$chr\t$pos\t.\t$ref\t$alt\t$snp_qual\t0\t\tGT:GQ:DP\t$gt:$cons_qual:$depth\n";
+
+        $prev_ref = $ref;
+        $prev_pos = $pos;
+        $prev_chr = $chr;
+    }
+}
+
+
+#------------- Fasta --------------------
+#
+# Uses samtools to get a requested base from a fasta file. For efficiency, preloads
+#   a chunk to memory. The size of the cached sequence can be controlled by the 'size'
+#   parameter.
+#
+package Fasta;
+
+use strict;
+use warnings;
+use Carp;
+
+sub Fasta::new
+{
+    my ($class,@args) = @_;
+    my $self = @args ? {@args} : {};
+    if ( !$$self{file} ) { $self->throw(qq[Missing the parameter "file"\n]); }
+    $$self{chr}  = undef;
+    $$self{from} = undef;
+    $$self{to}   = undef;
+    if ( !$$self{size} ) { $$self{size}=10_000_000; }
+    bless $self, ref($class) || $class;
+    return $self;
+}
+
+sub read_chunk
+{
+    my ($self,$chr,$pos) = @_;
+    my $to = $pos + $$self{size};
+    my $cmd = "samtools faidx $$self{file} $chr:$pos-$to";
+    my @out = `$cmd`;
+    if ( $? ) { $self->throw("$cmd: $!"); }
+    my $line = shift(@out);
+    if ( !($line=~/^>$chr:(\d+)-(\d+)/) ) { $self->throw("Could not parse: $line"); }
+    $$self{chr}  = $chr;
+    $$self{from} = $1;
+    $$self{to}   = $2;
+    my $chunk = '';
+    while ($line=shift(@out))
+    {
+        chomp($line);
+        $chunk .= $line;
+    }
+    $$self{chunk} = $chunk;
+    return;
+}
+
+sub get_base
+{
+    my ($self,$chr,$pos) = @_;
+    if ( !$$self{chr} || $chr ne $$self{chr} || $pos<$$self{from} || $pos>$$self{to} )
+    {
+        $self->read_chunk($chr,$pos);
+    }
+    my $idx = $pos - $$self{from};
+    return substr($$self{chunk},$idx,1);
+}
+
+sub throw
+{
+    my ($self,@msg) = @_;
+    croak(@msg);
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/samtools.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/samtools.pl
new file mode 100644
index 0000000..320e8aa
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/samtools.pl
@@ -0,0 +1,421 @@
+#!/usr/bin/perl -w
+
+# Author: lh3
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+my $version = '0.3.3';
+&usage if (@ARGV < 1);
+
+my $command = shift(@ARGV);
+my %func = (showALEN=>\&showALEN, pileup2fq=>\&pileup2fq, varFilter=>\&varFilter,
+			unique=>\&unique, uniqcmp=>\&uniqcmp, sra2hdr=>\&sra2hdr);
+
+die("Unknown command \"$command\".\n") if (!defined($func{$command}));
+&{$func{$command}};
+exit(0);
+
+#
+# showALEN
+#
+
+sub showALEN {
+  die(qq/Usage: samtools.pl showALEN <in.sam>\n/) if (@ARGV == 0 && -t STDIN);
+  while (<>) {
+	my @t = split;
+	next if (/^\@/ || @t < 11);
+	my $l = 0;
+	$_ = $t[5];
+	s/(\d+)[MI]/$l+=$1/eg;
+	print join("\t", @t[0..5]), "\t$l\t", join("\t", @t[6..$#t]), "\n";
+  }
+}
+
+#
+# varFilter
+#
+
+#
+# Filtration code:
+#
+# d low depth
+# D high depth
+# W too many SNPs in a window (SNP only)
+# G close to a high-quality indel (SNP only)
+# Q low RMS mapping quality (SNP only)
+# g close to another indel with higher quality (indel only)
+
+sub varFilter {
+  my %opts = (d=>3, D=>100, l=>30, Q=>25, q=>10, G=>25, s=>100, w=>10, W=>10, N=>2, p=>undef);
+  getopts('pq:d:D:l:Q:w:W:N:G:', \%opts);
+  die(qq/
+Usage:   samtools.pl varFilter [options] <in.cns-pileup>
+
+Options: -Q INT    minimum RMS mapping quality for SNPs [$opts{Q}]
+         -q INT    minimum RMS mapping quality for gaps [$opts{q}]
+         -d INT    minimum read depth [$opts{d}]
+         -D INT    maximum read depth [$opts{D}]
+
+         -G INT    min indel score for nearby SNP filtering [$opts{G}]
+         -w INT    SNP within INT bp around a gap to be filtered [$opts{w}]
+
+         -W INT    window size for filtering dense SNPs [$opts{W}]
+         -N INT    max number of SNPs in a window [$opts{N}]
+
+         -l INT    window size for filtering adjacent gaps [$opts{l}]
+
+         -p        print filtered variants
+\n/) if (@ARGV == 0 && -t STDIN);
+
+  # calculate the window size
+  my ($ol, $ow, $oW) = ($opts{l}, $opts{w}, $opts{W});
+  my $max_dist = $ol > $ow? $ol : $ow;
+  $max_dist = $oW if ($max_dist < $oW);
+  # the core loop
+  my @staging; # (indel_filtering_score, flt_tag)
+  while (<>) {
+	my @t = split;
+	next if (uc($t[2]) eq uc($t[3]) || $t[3] eq '*/*'); # skip non-var sites
+	# clear the out-of-range elements
+	while (@staging) {
+	  last if ($staging[0][2] eq $t[0] && $staging[0][3] + $max_dist >= $t[1]);
+	  varFilter_aux(shift(@staging), $opts{p}); # calling a function is a bit slower, not much
+	}
+	my ($flt, $score) = (0, -1);
+	# first a simple filter
+	if ($t[7] < $opts{d}) {
+	  $flt = 2;
+	} elsif ($t[7] > $opts{D}) {
+	  $flt = 3;
+	}
+	# site dependent filters
+	if ($flt == 0) {
+	  if ($t[2] eq '*') { # an indel
+		$flt = 1 if ($t[6] < $opts{q});
+		# filtering SNPs
+		if ($t[5] >= $opts{G}) {
+		  for my $x (@staging) {
+			next if ($x->[0] >= 0 || $x->[3] + $ow < $t[1]);
+			$x->[1] = 5 if ($x->[1] == 0);
+		  }
+		}
+		# calculate the filtering score (different from indel quality)
+		$score = $t[5];
+		$score += $opts{s} * $t[10] if ($t[8] ne '*');
+		$score += $opts{s} * $t[11] if ($t[9] ne '*');
+		# check the staging list for indel filtering
+		for my $x (@staging) {
+		  next if ($x->[0] < 0 || $x->[3] + $ol < $t[1]);
+		  if ($x->[0] < $score) {
+			$x->[1] = 6;
+		  } else {
+			$flt = 6; last;
+		  }
+		}
+	  } else { # a SNP
+		$flt = 1 if ($t[6] < $opts{Q});
+		# check adjacent SNPs
+		my $k = 1;
+		for my $x (@staging) {
+		  ++$k if ($x->[0] < 0 && $x->[3] + $oW >= $t[1] && ($x->[1] == 0 || $x->[1] == 4 || $x->[1] == 5));
+		}
+		# filtering is necessary
+		if ($k > $opts{N}) {
+		  $flt = 4;
+		  for my $x (@staging) {
+			 $x->[1] = 4 if ($x->[0] < 0 && $x->[3] + $oW >= $t[1] && $x->[1] == 0);
+		  }
+		} else { # then check gap filter
+		  for my $x (@staging) {
+			next if ($x->[0] < 0 || $x->[3] + $ow < $t[1]);
+			if ($x->[0] >= $opts{G}) {
+			  $flt = 5; last;
+			}
+		  }
+		}
+	  }
+	}
+	push(@staging, [$score, $flt, @t]);
+  }
+  # output the last few elements in the staging list
+  while (@staging) {
+	varFilter_aux(shift @staging, $opts{p});
+  }
+}
+
+sub varFilter_aux {
+  my ($first, $is_print) = @_;
+  if ($first->[1] == 0) {
+	print join("\t", @$first[2 .. @$first-1]), "\n";
+  } elsif ($is_print) {
+	print STDERR join("\t", substr("UQdDWGgX", $first->[1], 1), @$first[2 .. @$first-1]), "\n";
+  }
+}
+
+#
+# pileup2fq
+#
+
+sub pileup2fq {
+  my %opts = (d=>3, D=>255, Q=>25, G=>25, l=>10);
+  getopts('d:D:Q:G:l:', \%opts);
+  die(qq/
+Usage:   samtools.pl pileup2fq [options] <in.cns-pileup>
+
+Options: -d INT    minimum depth        [$opts{d}]
+         -D INT    maximum depth        [$opts{D}]
+         -Q INT    min RMS mapQ         [$opts{Q}]
+         -G INT    minimum indel score  [$opts{G}]
+         -l INT    indel filter winsize [$opts{l}]\n
+/) if (@ARGV == 0 && -t STDIN);
+
+  my ($last_chr, $seq, $qual, @gaps, $last_pos);
+  my $_Q = $opts{Q};
+  my $_d = $opts{d};
+  my $_D = $opts{D};
+
+  $last_chr = '';
+  while (<>) {
+	my @t = split;
+	if ($last_chr ne $t[0]) {
+	  &p2q_post_process($last_chr, \$seq, \$qual, \@gaps, $opts{l}) if ($last_chr);
+	  $last_chr = $t[0];
+	  $last_pos = 0;
+	  $seq = ''; $qual = '';
+	  @gaps = ();
+	}
+	if ($t[1] - $last_pos != 1) {
+	  $seq .= 'n' x ($t[1] - $last_pos - 1);
+	  $qual .= '!' x ($t[1] - $last_pos - 1);
+	}
+	if ($t[2] eq '*') {
+	  push(@gaps, $t[1]) if ($t[5] >= $opts{G});
+	} else {
+	  $seq .= ($t[6] >= $_Q && $t[7] >= $_d && $t[7] <= $_D)? uc($t[3]) : lc($t[3]);
+	  my $q = $t[4] + 33;
+	  $q = 126 if ($q > 126);
+	  $qual .= chr($q);
+	}
+	$last_pos = $t[1];
+  }
+  &p2q_post_process($last_chr, \$seq, \$qual, \@gaps, $opts{l});
+}
+
+sub p2q_post_process {
+  my ($chr, $seq, $qual, $gaps, $l) = @_;
+  &p2q_filter_gaps($seq, $gaps, $l);
+  print "\@$chr\n"; &p2q_print_str($seq);
+  print "+\n"; &p2q_print_str($qual);
+}
+
+sub p2q_filter_gaps {
+  my ($seq, $gaps, $l) = @_;
+  for my $g (@$gaps) {
+	my $x = $g > $l? $g - $l : 0;
+	substr($$seq, $x, $l + $l) = lc(substr($$seq, $x, $l + $l));
+  }
+}
+
+sub p2q_print_str {
+  my ($s) = @_;
+  my $l = length($$s);
+  for (my $i = 0; $i < $l; $i += 60) {
+	print substr($$s, $i, 60), "\n";
+  }
+}
+
+#
+# sra2hdr
+#
+
+# This subroutine does not use an XML parser. It requires that the SRA
+# XML files are properly formated.
+sub sra2hdr {
+  my %opts = ();
+  getopts('', \%opts);
+  die("Usage: samtools.pl sra2hdr <SRA.prefix>\n") if (@ARGV == 0);
+  my $pre = $ARGV[0];
+  my $fh;
+  # read sample
+  my $sample = 'UNKNOWN';
+  open($fh, "$pre.sample.xml") || die;
+  while (<$fh>) {
+	$sample = $1 if (/<SAMPLE.*alias="([^"]+)"/i);
+  }
+  close($fh);
+  # read experiment
+  my (%exp2lib, $exp);
+  open($fh, "$pre.experiment.xml") || die;
+  while (<$fh>) {
+	if (/<EXPERIMENT.*accession="([^\s"]+)"/i) {
+	  $exp = $1;
+	} elsif (/<LIBRARY_NAME>\s*(\S+)\s*<\/LIBRARY_NAME>/i) {
+	  $exp2lib{$exp} = $1;
+	}
+  }
+  close($fh);
+  # read run
+  my ($run, @fn);
+  open($fh, "$pre.run.xml") || die;
+  while (<$fh>) {
+	if (/<RUN.*accession="([^\s"]+)"/i) {
+	  $run = $1; @fn = ();
+	} elsif (/<EXPERIMENT_REF.*accession="([^\s"]+)"/i) {
+	  print "\@RG\tID:$run\tSM:$sample\tLB:$exp2lib{$1}\n";
+	} elsif (/<FILE.*filename="([^\s"]+)"/i) {
+	  push(@fn, $1);
+	} elsif (/<\/RUN>/i) {
+	  if (@fn == 1) {
+		print STDERR "$fn[0]\t$run\n";
+	  } else {
+		for (0 .. $#fn) {
+		  print STDERR "$fn[$_]\t$run", "_", $_+1, "\n";
+		}
+	  }
+	}
+  }
+  close($fh);
+}
+
+#
+# unique
+#
+
+sub unique {
+  my %opts = (f=>250.0, q=>5, r=>2, a=>1, b=>3);
+  getopts('Qf:q:r:a:b:', \%opts);
+  die("Usage: samtools.pl unique [-f $opts{f}] <in.sam>\n") if (@ARGV == 0 && -t STDIN);
+  my $last = '';
+  my $recal_Q = !defined($opts{Q});
+  my @a;
+  while (<>) {
+	my $score = -1;
+	print $_ if (/^\@/);
+	$score = $1 if (/AS:i:(\d+)/);
+	my @t = split("\t");
+	next if (@t < 11);
+	if ($score < 0) { # AS tag is unavailable
+	  my $cigar = $t[5];
+	  my ($mm, $go, $ge) = (0, 0, 0);
+	  $cigar =~ s/(\d+)[ID]/++$go,$ge+=$1/eg;
+	  $cigar = $t[5];
+	  $cigar =~ s/(\d+)M/$mm+=$1/eg;
+	  $score = $mm * $opts{a} - $go * $opts{q} - $ge * $opts{r}; # no mismatches...
+	}
+	$score = 1 if ($score < 1);
+	if ($t[0] ne $last) {
+	  &unique_aux(\@a, $opts{f}, $recal_Q) if (@a);
+	  $last = $t[0];
+	}
+	push(@a, [$score, \@t]);
+  }
+  &unique_aux(\@a, $opts{f}, $recal_Q) if (@a);
+}
+
+sub unique_aux {
+  my ($a, $fac, $is_recal) = @_;
+  my ($max, $max2, $max_i) = (0, 0, -1);
+  for (my $i = 0; $i < @$a; ++$i) {
+	if ($a->[$i][0] > $max) {
+	  $max2 = $max; $max = $a->[$i][0]; $max_i = $i;
+	} elsif ($a->[$i][0] > $max2) {
+	  $max2 = $a->[$i][0];
+	}
+  }
+  if ($is_recal) {
+	my $q = int($fac * ($max - $max2) / $max + .499);
+	$q = 250 if ($q > 250);
+	$a->[$max_i][1][4] = $q < 250? $q : 250;
+  }
+  print join("\t", @{$a->[$max_i][1]});
+  @$a = ();
+}
+
+#
+# uniqcmp: compare two SAM files
+#
+
+sub uniqcmp {
+  my %opts = (q=>10, s=>100);
+  getopts('pq:s:', \%opts);
+  die("Usage: samtools.pl uniqcmp <in1.sam> <in2.sam>\n") if (@ARGV < 2);
+  my ($fh, %a);
+  warn("[uniqcmp] read the first file...\n");
+  &uniqcmp_aux($ARGV[0], \%a, 0);
+  warn("[uniqcmp] read the second file...\n");
+  &uniqcmp_aux($ARGV[1], \%a, 1);
+  warn("[uniqcmp] stats...\n");
+  my @cnt;
+  $cnt[$_] = 0 for (0..9);
+  for my $x (keys %a) {
+	my $p = $a{$x};
+	my $z;
+	if (defined($p->[0]) && defined($p->[1])) {
+	  $z = ($p->[0][0] == $p->[1][0] && $p->[0][1] eq $p->[1][1] && abs($p->[0][2] - $p->[1][2]) < $opts{s})? 0 : 1;
+	  if ($p->[0][3] >= $opts{q} && $p->[1][3] >= $opts{q}) {
+		++$cnt[$z*3+0];
+	  } elsif ($p->[0][3] >= $opts{q}) {
+		++$cnt[$z*3+1];
+	  } elsif ($p->[1][3] >= $opts{q}) {
+		++$cnt[$z*3+2];
+	  }
+	  print STDERR "$x\t$p->[0][1]:$p->[0][2]\t$p->[0][3]\t$p->[0][4]\t$p->[1][1]:$p->[1][2]\t$p->[1][3]\t$p->[1][4]\t",
+		$p->[0][5]-$p->[1][5], "\n" if ($z && defined($opts{p}) && ($p->[0][3] >= $opts{q} || $p->[1][3] >= $opts{q}));
+	} elsif (defined($p->[0])) {
+	  ++$cnt[$p->[0][3]>=$opts{q}? 6 : 7];
+	  print STDERR "$x\t$p->[0][1]:$p->[0][2]\t$p->[0][3]\t$p->[0][4]\t*\t0\t*\t",
+		$p->[0][5], "\n" if (defined($opts{p}) && $p->[0][3] >= $opts{q});
+	} else {
+	  print STDERR "$x\t*\t0\t*\t$p->[1][1]:$p->[1][2]\t$p->[1][3]\t$p->[1][4]\t",
+		-$p->[1][5], "\n" if (defined($opts{p}) && $p->[1][3] >= $opts{q});
+	  ++$cnt[$p->[1][3]>=$opts{q}? 8 : 9];
+	}
+  }
+  print "Consistent (high, high):   $cnt[0]\n";
+  print "Consistent (high, low ):   $cnt[1]\n";
+  print "Consistent (low , high):   $cnt[2]\n";
+  print "Inconsistent (high, high): $cnt[3]\n";
+  print "Inconsistent (high, low ): $cnt[4]\n";
+  print "Inconsistent (low , high): $cnt[5]\n";
+  print "Second missing (high):     $cnt[6]\n";
+  print "Second missing (low ):     $cnt[7]\n";
+  print "First  missing (high):     $cnt[8]\n";
+  print "First  missing (low ):     $cnt[9]\n";
+}
+
+sub uniqcmp_aux {
+  my ($fn, $a, $which) = @_;
+  my $fh;
+  $fn = "samtools view $fn |" if ($fn =~ /\.bam/);
+  open($fh, $fn) || die;
+  while (<$fh>) {
+	my @t = split;
+	next if (@t < 11);
+#	my $l = ($t[5] =~ /^(\d+)S/)? $1 : 0;
+	my $l = 0;
+	my ($x, $nm) = (0, 0);
+	$nm = $1 if (/NM:i:(\d+)/);
+	$_ = $t[5];
+	s/(\d+)[MI]/$x+=$1/eg;
+	@{$a->{$t[0]}[$which]} = (($t[1]&0x10)? 1 : 0, $t[2], $t[3]-$l, $t[4], "$x:$nm", $x - 4 * $nm);
+  }
+  close($fh);
+}
+
+#
+# Usage
+#
+
+sub usage {
+  die(qq/
+Program: samtools.pl (helper script for SAMtools)
+Version: $version
+Contact: Heng Li <lh3\@sanger.ac.uk>\n
+Usage:   samtools.pl <command> [<arguments>]\n
+Command: varFilter     filtering SNPs and short indels
+         pileup2fq     generate fastq from `pileup -c'
+         showALEN      print alignment length (ALEN) following CIGAR
+\n/);
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/soap2sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/soap2sam.pl
new file mode 100644
index 0000000..b37135e
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/soap2sam.pl
@@ -0,0 +1,109 @@
+#!/usr/bin/perl -w
+
+# Contact: lh3
+# Version: 0.1.1
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+&soap2sam;
+exit;
+
+sub mating {
+  my ($s1, $s2) = @_;
+  my $isize = 0;
+  if ($s1->[2] ne '*' && $s1->[2] eq $s2->[2]) { # then calculate $isize
+	my $x1 = ($s1->[1] & 0x10)? $s1->[3] + length($s1->[9]) : $s1->[3];
+	my $x2 = ($s2->[1] & 0x10)? $s2->[3] + length($s2->[9]) : $s2->[3];
+	$isize = $x2 - $x1;
+  }
+  # update mate coordinate
+  if ($s2->[2] ne '*') {
+	@$s1[6..8] = (($s2->[2] eq $s1->[2])? "=" : $s2->[2], $s2->[3], $isize);
+	$s1->[1] |= 0x20 if ($s2->[1] & 0x10);
+  } else {
+	$s1->[1] |= 0x8;
+  }
+  if ($s1->[2] ne '*') {
+	@$s2[6..8] = (($s1->[2] eq $s2->[2])? "=" : $s1->[2], $s1->[3], -$isize);
+	$s2->[1] |= 0x20 if ($s1->[1] & 0x10);
+  } else {
+	$s2->[1] |= 0x8;
+  }
+}
+
+sub soap2sam {
+  my %opts = ();
+  getopts("p", \%opts);
+  die("Usage: soap2sam.pl [-p] <aln.soap>\n") if (@ARGV == 0 && -t STDIN);
+  my $is_paired = defined($opts{p});
+  # core loop
+  my @s1 = ();
+  my @s2 = ();
+  my ($s_last, $s_curr) = (\@s1, \@s2);
+  while (<>) {
+	s/[\177-\377]|[\000-\010]|[\012-\040]//g;
+	next if (&soap2sam_aux($_, $s_curr, $is_paired) < 0);
+	if (@$s_last != 0 && $s_last->[0] eq $s_curr->[0]) {
+	  &mating($s_last, $s_curr);
+	  print join("\t", @$s_last), "\n";
+	  print join("\t", @$s_curr), "\n";
+	  @$s_last = (); @$s_curr = ();
+	} else {
+	  print join("\t", @$s_last), "\n" if (@$s_last != 0);
+	  my $s = $s_last; $s_last = $s_curr; $s_curr = $s;
+	}
+  }
+  print join("\t", @$s_last), "\n" if (@$s_last != 0);
+}
+
+sub soap2sam_aux {
+  my ($line, $s, $is_paired) = @_;
+  chomp($line);
+  my @t = split(/\s+/, $line);
+  return -1 if (@t < 9 || $line =~ /^\s/ || !$t[0]);
+  @$s = ();
+  # fix SOAP-2.1.x bugs
+  @t = @t[0..2,4..$#t] unless ($t[3] =~ /^\d+$/);
+  # read name
+  $s->[0] = $t[0];
+  $s->[0] =~ s/\/[12]$//g;
+  # initial flag (will be updated later)
+  $s->[1] = 0;
+  $s->[1] |= 1 | 1<<($t[4] eq 'a'? 6 : 7);
+  $s->[1] |= 2 if ($is_paired);
+  # read & quality
+  $s->[9] = $t[1];
+  $s->[10] = (length($t[2]) > length($t[1]))? substr($t[2], 0, length($t[1])) : $t[2];
+  # cigar
+  $s->[5] = length($s->[9]) . "M";
+  # coor
+  $s->[2] = $t[7]; $s->[3] = $t[8];
+  $s->[1] |= 0x10 if ($t[6] eq '-');
+  # mapQ
+  $s->[4] = $t[3] == 1? 30 : 0;
+  # mate coordinate
+  $s->[6] = '*'; $s->[7] = $s->[8] = 0;
+  # aux
+  push(@$s, "NM:i:$t[9]");
+  my $md = '';
+  if ($t[9]) {
+	my @x;
+	for (10 .. $#t) {
+	  push(@x, sprintf("%.3d,$1", $2)) if ($t[$_] =~ /^([ACGT])->(\d+)/i);
+	}
+	@x = sort(@x);
+	my $a = 0;
+	for (@x) {
+	  my ($y, $z) = split(",");
+	  $md .= (int($y)-$a) . $z;
+	  $a += $y - $a + 1;
+	}
+	$md .= length($t[1]) - $a;
+  } else {
+	$md = length($t[1]);
+  }
+  push(@$s, "MD:Z:$md");
+  return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim
new file mode 100755
index 0000000..e637be0
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim.c b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim.c
new file mode 100644
index 0000000..1522eee
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim.c
@@ -0,0 +1,502 @@
+/* The MIT License
+
+   Copyright (c) 2008 Genome Research Ltd (GRL).
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Contact: Heng Li <lh3@sanger.ac.uk> */
+
+/* This program is separated from maq's read simulator with Colin
+ * Hercus' modification to allow longer indels. Colin is the chief
+ * developer of novoalign. */
+
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>
+#include <assert.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <ctype.h>
+#include <string.h>
+
+#define PACKAGE_VERSION "0.2.3"
+
+const uint8_t nst_nt4_table[256] = {
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 5 /*'-'*/, 4, 4,
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 
+	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4
+};
+
+const int nst_color_space_table[] = { 4, 0, 0, 1, 0, 2, 3, 4, 0, 3, 2, 4, 1, 4, 4, 4};
+
+/* Simple normal random number generator, copied from genran.c */
+
+double ran_normal()
+{ 
+	static int iset = 0; 
+	static double gset; 
+	double fac, rsq, v1, v2; 
+	if (iset == 0) {
+		do { 
+			v1 = 2.0 * drand48() - 1.0;
+			v2 = 2.0 * drand48() - 1.0; 
+			rsq = v1 * v1 + v2 * v2;
+		} while (rsq >= 1.0 || rsq == 0.0);
+		fac = sqrt(-2.0 * log(rsq) / rsq); 
+		gset = v1 * fac; 
+		iset = 1;
+		return v2 * fac;
+	} else {
+		iset = 0;
+		return gset;
+	}
+}
+
+/* FASTA parser, copied from seq.c */
+
+typedef struct {
+	int l, m; /* length and maximum buffer size */
+	unsigned char *s; /* sequence */
+} seq_t;
+
+#define INIT_SEQ(seq) (seq).s = 0; (seq).l = (seq).m = 0
+
+static int SEQ_BLOCK_SIZE = 512;
+
+void seq_set_block_size(int size)
+{
+	SEQ_BLOCK_SIZE = size;
+}
+
+int seq_read_fasta(FILE *fp, seq_t *seq, char *locus, char *comment)
+{
+	int c, l, max;
+	char *p;
+	
+	c = 0;
+	while (!feof(fp) && fgetc(fp) != '>');
+	if (feof(fp)) return -1;
+	p = locus;
+	while (!feof(fp) && (c = fgetc(fp)) != ' ' && c != '\t' && c != '\n')
+		if (c != '\r') *p++ = c;
+	*p = '\0';
+	if (comment) {
+		p = comment;
+		if (c != '\n') {
+			while (!feof(fp) && ((c = fgetc(fp)) == ' ' || c == '\t'));
+			if (c != '\n') {
+				*p++ = c;
+				while (!feof(fp) && (c = fgetc(fp)) != '\n')
+					if (c != '\r') *p++ = c;
+			}
+		}
+		*p = '\0';
+	} else if (c != '\n') while (!feof(fp) && fgetc(fp) != '\n');
+	l = 0; max = seq->m;
+	while (!feof(fp) && (c = fgetc(fp)) != '>') {
+		if (isalpha(c) || c == '-' || c == '.') {
+			if (l + 1 >= max) {
+				max += SEQ_BLOCK_SIZE;
+				seq->s = (unsigned char*)realloc(seq->s, sizeof(char) * max);
+			}
+			seq->s[l++] = (unsigned char)c;
+		}
+	}
+	if (c == '>') ungetc(c,fp);
+	seq->s[l] = 0;
+	seq->m = max; seq->l = l;
+	return l;
+}
+
+/* Error-checking open, copied from utils.c */
+
+#define xopen(fn, mode) err_xopen_core(__func__, fn, mode)
+
+FILE *err_xopen_core(const char *func, const char *fn, const char *mode)
+{
+	FILE *fp = 0;
+	if (strcmp(fn, "-") == 0)
+		return (strstr(mode, "r"))? stdin : stdout;
+	if ((fp = fopen(fn, mode)) == 0) {
+		fprintf(stderr, "[%s] fail to open file '%s'. Abort!\n", func, fn);
+		abort();
+	}
+	return fp;
+}
+
+/* wgsim */
+
+enum muttype_t {NOCHANGE = 0, INSERT = 0x1000, SUBSTITUTE = 0xe000, DELETE = 0xf000};
+typedef unsigned short mut_t;
+static mut_t mutmsk = (mut_t)0xf000;
+
+typedef struct {
+	int l, m; /* length and maximum buffer size */
+	mut_t *s; /* sequence */
+} mutseq_t;
+
+static double ERR_RATE = 0.02;
+static double MUT_RATE = 0.001;
+static double INDEL_FRAC = 0.1;
+static double INDEL_EXTEND = 0.3;
+static int IS_SOLID = 0;
+static int SHOW_MM_INFO = 1;
+
+void maq_mut_diref(const seq_t *seq, int is_hap, mutseq_t *hap1, mutseq_t *hap2)
+{
+	int i, deleting = 0;
+	mutseq_t *ret[2];
+
+	ret[0] = hap1; ret[1] = hap2;
+	ret[0]->l = seq->l; ret[1]->l = seq->l;
+	ret[0]->m = seq->m; ret[1]->m = seq->m;
+	ret[0]->s = (mut_t *)calloc(seq->m, sizeof(mut_t));
+	ret[1]->s = (mut_t *)calloc(seq->m, sizeof(mut_t));
+	for (i = 0; i != seq->l; ++i) {
+		int c;
+		c = ret[0]->s[i] = ret[1]->s[i] = (mut_t)nst_nt4_table[(int)seq->s[i]];
+        if (deleting) {
+            if (drand48() < INDEL_EXTEND) {
+                if (deleting & 1) ret[0]->s[i] |= DELETE;
+                if (deleting & 2) ret[1]->s[i] |= DELETE;
+                continue;
+            } else deleting = 0;
+        }
+		if (c < 4 && drand48() < MUT_RATE) { // mutation
+			if (drand48() >= INDEL_FRAC) { // substitution
+				double r = drand48();
+				c = (c + (int)(r * 3.0 + 1)) & 3;
+				if (is_hap || drand48() < 0.333333) { // hom
+					ret[0]->s[i] = ret[1]->s[i] = SUBSTITUTE|c;
+				} else { // het
+					ret[drand48()<0.5?0:1]->s[i] = SUBSTITUTE|c;
+				}
+			} else { // indel
+				if (drand48() < 0.5) { // deletion
+					if (is_hap || drand48() < 0.333333) { // hom-del
+						ret[0]->s[i] = ret[1]->s[i] = DELETE;
+                        deleting = 3;
+					} else { // het-del
+                        deleting = drand48()<0.5?1:2;
+						ret[deleting-1]->s[i] = DELETE;
+					}
+				} else { // insertion
+                    int num_ins = 0, ins = 0;
+                    do {
+                        num_ins++;
+                        ins = (ins << 2) | (int)(drand48() * 4.0);
+                    } while (num_ins < 4 && drand48() < INDEL_EXTEND);
+
+					if (is_hap || drand48() < 0.333333) { // hom-ins
+						ret[0]->s[i] = ret[1]->s[i] = (num_ins << 12) | (ins << 4) | c;
+					} else { // het-ins
+						ret[drand48()<0.5?0:1]->s[i] = (num_ins << 12) | (ins << 4) | c;
+					}
+				}
+			}
+		}
+	}
+}
+void maq_print_mutref(const char *name, const seq_t *seq, mutseq_t *hap1, mutseq_t *hap2)
+{
+	int i;
+	for (i = 0; i != seq->l; ++i) {
+		int c[3];
+		c[0] = nst_nt4_table[(int)seq->s[i]];
+		c[1] = hap1->s[i]; c[2] = hap2->s[i];
+		if (c[0] >= 4) continue;
+		if ((c[1] & mutmsk) != NOCHANGE || (c[1] & mutmsk) != NOCHANGE) {
+			printf("%s\t%d\t", name, i+1);
+			if (c[1] == c[2]) { // hom
+				if ((c[1]&mutmsk) == SUBSTITUTE) { // substitution
+					printf("%c\t%c\t-\n", "ACGTN"[c[0]], "ACGTN"[c[1]&0xf]);
+				} else if ((c[1]&mutmsk) == DELETE) { // del
+					printf("%c\t-\t-\n", "ACGTN"[c[0]]);
+				} else if (((c[1] & mutmsk) >> 12) <= 5) { // ins
+					printf("-\t");
+                    int n = (c[1]&mutmsk) >> 12, ins = c[1] >> 4;
+                    while(n > 0) {
+                        putchar("ACGTN"[ins & 0x3]);
+                        n--;
+                    }
+                    printf("\t-\n");
+				}  else assert(0);
+			} else { // het
+				if ((c[1]&mutmsk) == SUBSTITUTE || (c[2]&mutmsk) == SUBSTITUTE) { // substitution
+					printf("%c\t%c\t+\n", "ACGTN"[c[0]], "XACMGRSVTWYHKDBN"[1<<(c[1]&0x3)|1<<(c[2]&0x3)]);
+				} else if ((c[1]&mutmsk) == DELETE) {
+					printf("%c\t-\t+\n", "ACGTN"[c[0]]);
+				} else if ((c[2]&mutmsk) == DELETE) {
+					printf("%c\t-\t+\n", "ACGTN"[c[0]]);
+				} else if (((c[1] & mutmsk) >> 12) <= 4) { // ins1
+					printf("-\t");
+                    int n = (c[1]&mutmsk) >> 12, ins = c[1] >> 4;
+                    while (n > 0) {
+                        putchar("ACGTN"[ins & 0x3]);
+                        n--;
+                    }
+                    printf("\t+\n");
+				} else if (((c[2] & mutmsk) >> 12) <= 5) { // ins2
+					printf("-\t");
+                    int n = (c[2]&mutmsk) >> 12, ins = c[2] >> 4;
+                    while (n > 0) {
+                        putchar("ACGTN"[ins & 0x3]);
+                        ins >>= 2;
+                        n--;
+                    }
+                    printf("\t+\n");
+				} else assert(0);
+			}
+		}
+	}
+}
+
+void wgsim_core(FILE *fpout1, FILE *fpout2, FILE *fp_fa, int is_hap, uint64_t N, int dist, int std_dev, int size_l, int size_r)
+{
+	seq_t seq;
+    mutseq_t rseq[2];
+	uint64_t tot_len, ii;
+	int i, l, n_ref;
+	char name[256], *qstr;
+	int size[2], Q;
+	uint8_t *tmp_seq[2];
+    mut_t *target;
+
+	INIT_SEQ(seq);
+	srand48(time(0));
+	seq_set_block_size(0x1000000);
+	l = size_l > size_r? size_l : size_r;
+	qstr = (char*)calloc(l+1, 1);
+	tmp_seq[0] = (uint8_t*)calloc(l+2, 1);
+	tmp_seq[1] = (uint8_t*)calloc(l+2, 1);
+	size[0] = size_l; size[1] = size_r;
+
+	Q = (int)(-10.0 * log(ERR_RATE) / log(10.0) + 0.499) + 33;
+
+	tot_len = n_ref = 0;
+	while ((l = seq_read_fasta(fp_fa, &seq, name, 0)) >= 0) {
+		tot_len += l;
+		++n_ref;
+	}
+	fprintf(stderr, "[wgsim_core] %d sequences, total length: %llu\n", n_ref, (long long)tot_len);
+	rewind(fp_fa);
+
+	while ((l = seq_read_fasta(fp_fa, &seq, name, 0)) >= 0) {
+		uint64_t n_pairs = (uint64_t)((long double)l / tot_len * N + 0.5);
+		if (l < dist + 3 * std_dev) {
+			fprintf(stderr, "[wgsim_core] kkip sequence '%s' as it is shorter than %d!\n", name, dist + 3 * std_dev);
+			continue;
+		}
+
+		// generate mutations and print them out
+		maq_mut_diref(&seq, is_hap, rseq, rseq+1);
+		maq_print_mutref(name, &seq, rseq, rseq+1);
+
+		for (ii = 0; ii != n_pairs; ++ii) { // the core loop
+			double ran;
+			int d, pos, s[2], is_flip = 0;
+			int n_sub[2], n_indel[2], n_err[2], ext_coor[2], j, k;
+			FILE *fpo[2];
+
+			do { // avoid boundary failure
+				ran = ran_normal();
+				ran = ran * std_dev + dist;
+				d = (int)(ran + 0.5);
+				pos = (int)((l - d + 1) * drand48());
+			} while (pos < 0 || pos >= seq.l || pos + d - 1 >= seq.l);
+
+			// flip or not
+			if (drand48() < 0.5) {
+				fpo[0] = fpout1; fpo[1] = fpout2;
+				s[0] = size[0]; s[1] = size[1];
+			} else {
+				fpo[1] = fpout1; fpo[0] = fpout2;
+				s[1] = size[0]; s[0] = size[1];
+				is_flip = 1;
+			}
+
+			// generate the read sequences
+			target = rseq[drand48()<0.5?0:1].s; // haplotype from which the reads are generated
+			n_sub[0] = n_sub[1] = n_indel[0] = n_indel[1] = n_err[0] = n_err[1] = 0;
+
+#define __gen_read(x, start, iter) do {									\
+				for (i = (start), k = 0, ext_coor[x] = -10; i >= 0 && i < seq.l && k < s[x]; iter) {	\
+					int c = target[i], mut_type = c & mutmsk;			\
+					if (ext_coor[x] < 0) {								\
+						if (mut_type != NOCHANGE && mut_type != SUBSTITUTE) continue; \
+						ext_coor[x] = i;								\
+					}													\
+					if (mut_type == DELETE) ++n_indel[x];				\
+					else if (mut_type == NOCHANGE || mut_type == SUBSTITUTE) { \
+						tmp_seq[x][k++] = c & 0xf;						\
+						if (mut_type == SUBSTITUTE) ++n_sub[x];			\
+					} else {											\
+						int n, ins;										\
+						++n_indel[x];									\
+						tmp_seq[x][k++] = c & 0xf;						\
+						for (n = mut_type>>12, ins = c>>4; n > 0 && k < s[x]; --n, ins >>= 2) \
+							tmp_seq[x][k++] = ins & 0x3;				\
+					}													\
+				}														\
+				if (k != s[x]) ext_coor[x] = -10;						\
+			} while (0)
+
+			if (!IS_SOLID) {
+				__gen_read(0, pos, ++i);
+				__gen_read(1, pos + d - 1, --i);
+				for (k = 0; k < s[1]; ++k) tmp_seq[1][k] = tmp_seq[1][k] < 4? 3 - tmp_seq[1][k] : 4; // complement
+			} else {
+				int c1, c2, c;
+				++s[0]; ++s[1]; // temporarily increase read length by 1
+				if (is_flip) { // RR pair
+					__gen_read(0, pos + s[0], --i);
+					__gen_read(1, pos + d - 1, --i);
+				} else { // FF pair
+					__gen_read(0, pos, ++i);
+					__gen_read(1, pos + d - 1 - s[1], ++i);
+					++ext_coor[0]; ++ext_coor[1];
+				}
+				// change to color sequence: (0,1,2,3) -> (A,C,G,T)
+				for (j = 0; j < 2; ++j) {
+					c1 = tmp_seq[j][0];
+					for (i = 1; i < s[j]; ++i) {
+						c2 = tmp_seq[j][i];
+						c = (c1 >= 4 || c2 >= 4)? 4 : nst_color_space_table[(1<<c1)|(1<<c2)];
+						tmp_seq[j][i-1] = c;
+						c1 = c2;
+					}
+				}
+				--s[0]; --s[1]; // change back
+			}
+			if (ext_coor[0] < 0 || ext_coor[1] < 0) { // fail to generate the read(s)
+				--ii;
+				continue;
+			}
+
+			// generate sequencing errors
+			for (j = 0; j < 2; ++j) {
+				for (i = 0; i < s[j]; ++i) {
+					int c = tmp_seq[j][i];
+					if (c >= 4) c = 4; // actually c should be never larger than 4 if everything is correct
+					else if (drand48() < ERR_RATE) {
+						c = (c + (int)(drand48() * 3.0 + 1)) & 3;
+						++n_err[j];
+					}
+					tmp_seq[j][i] = c;
+				}
+			}
+
+			// print
+			for (j = 0; j < 2; ++j) {
+				for (i = 0; i < s[j]; ++i) qstr[i] = Q;
+				qstr[i] = 0;
+				if (SHOW_MM_INFO) {
+					fprintf(fpo[j], "@%s_%u_%u_%d:%d:%d_%d:%d:%d_%llx/%d\n", name, ext_coor[0]+1, ext_coor[1]+1,
+							n_err[0], n_sub[0], n_indel[0], n_err[1], n_sub[1], n_indel[1],
+							(long long)ii, j==0? is_flip+1 : 2-is_flip);
+				} else {
+					fprintf(fpo[j], "@%s_%u_%u_%llx/%d %d:%d:%d_%d:%d:%d\n", name, ext_coor[0]+1, ext_coor[1]+1,
+							(long long)ii, j==0? is_flip+1 : 2-is_flip,
+							n_err[0], n_sub[0], n_indel[0], n_err[1], n_sub[1], n_indel[1]);
+				}
+				for (i = 0; i < s[j]; ++i)
+					fputc("ACGTN"[(int)tmp_seq[j][i]], fpo[j]);
+				fprintf(fpo[j], "\n+\n%s\n", qstr);
+			}
+		}
+		free(rseq[0].s); free(rseq[1].s);
+	}
+	free(seq.s); free(qstr);
+	free(tmp_seq[0]); free(tmp_seq[1]);
+}
+
+static int simu_usage()
+{
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Program: wgsim (short read simulator)\n");
+	fprintf(stderr, "Version: %s\n", PACKAGE_VERSION);
+	fprintf(stderr, "Contact: Heng Li <lh3@sanger.ac.uk>\n\n");
+	fprintf(stderr, "Usage:   wgsim [options] <in.ref.fa> <out.read1.fq> <out.read2.fq>\n\n");
+	fprintf(stderr, "Options: -e FLOAT      base error rate [%.3f]\n", ERR_RATE);
+	fprintf(stderr, "         -d INT        outer distance between the two ends [500]\n");
+	fprintf(stderr, "         -s INT        standard deviation [50]\n");
+	fprintf(stderr, "         -N INT        number of read pairs [1000000]\n");
+	fprintf(stderr, "         -1 INT        length of the first read [70]\n");
+	fprintf(stderr, "         -2 INT        length of the second read [70]\n");
+	fprintf(stderr, "         -r FLOAT      rate of mutations [%.4f]\n", MUT_RATE);
+	fprintf(stderr, "         -R FLOAT      fraction of indels [%.2f]\n", INDEL_FRAC);
+	fprintf(stderr, "         -X FLOAT      probability an indel is extended [%.2f]\n", INDEL_EXTEND);
+	fprintf(stderr, "         -c            generate reads in color space (SOLiD reads)\n");
+	fprintf(stderr, "         -C            show mismatch info in comment rather than read name\n");
+	fprintf(stderr, "         -h            haplotype mode\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Note: For SOLiD reads, the first read is F3 and the second is R3.\n\n");
+	return 1;
+}
+
+int main(int argc, char *argv[])
+{
+	int64_t N;
+	int dist, std_dev, c, size_l, size_r, is_hap = 0;
+	FILE *fpout1, *fpout2, *fp_fa;
+
+	N = 1000000; dist = 500; std_dev = 50;
+	size_l = size_r = 70;
+	while ((c = getopt(argc, argv, "e:d:s:N:1:2:r:R:hX:cC")) >= 0) {
+		switch (c) {
+		case 'd': dist = atoi(optarg); break;
+		case 's': std_dev = atoi(optarg); break;
+		case 'N': N = atoi(optarg); break;
+		case '1': size_l = atoi(optarg); break;
+		case '2': size_r = atoi(optarg); break;
+		case 'e': ERR_RATE = atof(optarg); break;
+		case 'r': MUT_RATE = atof(optarg); break;
+		case 'R': INDEL_FRAC = atof(optarg); break;
+		case 'X': INDEL_EXTEND = atof(optarg); break;
+		case 'c': IS_SOLID = 1; break;
+		case 'C': SHOW_MM_INFO = 0; break;
+		case 'h': is_hap = 1; break;
+		}
+	}
+	if (argc - optind < 3) return simu_usage();
+	fp_fa = (strcmp(argv[optind+0], "-") == 0)? stdin : xopen(argv[optind+0], "r");
+	fpout1 = xopen(argv[optind+1], "w");
+	fpout2 = xopen(argv[optind+2], "w");
+	wgsim_core(fpout1, fpout2, fp_fa, is_hap, N, dist, std_dev, size_l, size_r);
+
+	fclose(fpout1); fclose(fpout2); fclose(fp_fa);
+	return 0;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim.o b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim.o
new file mode 100644
index 0000000..9270ef9
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim.o differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim_eval.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim_eval.pl
new file mode 100644
index 0000000..01038f1
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/wgsim_eval.pl
@@ -0,0 +1,79 @@
+#!/usr/bin/perl -w
+
+# Contact: lh3
+# Version: 0.1.5
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+&wgsim_eval;
+exit;
+
+sub wgsim_eval {
+  my %opts = (g=>5);
+  getopts('pcg:', \%opts);
+  die("Usage: wgsim_eval.pl [-pc] [-g $opts{g}] <in.sam>\n") if (@ARGV == 0 && -t STDIN);
+  my (@c0, @c1);
+  my ($max_q, $flag) = (0, 0);
+  my $gap = $opts{g};
+  $flag |= 1 if (defined $opts{p});
+  $flag |= 2 if (defined $opts{c});
+  while (<>) {
+	next if (/^\@/);
+	my @t = split("\t");
+	next if (@t < 11);
+	my $line = $_;
+	my ($q, $is_correct, $chr, $left, $rght) = (int($t[4]/10), 1, $t[2], $t[3], $t[3]);
+	$max_q = $q if ($q > $max_q);
+	# right coordinate
+	$_ = $t[5]; s/(\d+)[MDN]/$rght+=$1,'x'/eg;
+	--$rght;
+	# correct for soft clipping
+	my ($left0, $rght0) = ($left, $rght);
+	$left -= $1 if (/^(\d+)[SH]/);
+	$rght += $1 if (/(\d+)[SH]$/);
+	$left0 -= $1 if (/(\d+)[SH]$/);
+	$rght0 += $1 if (/^(\d+)[SH]/);
+	# skip unmapped reads
+	next if (($t[1]&0x4) || $chr eq '*');
+	# parse read name and check
+	if ($t[0] =~ /^(\S+)_(\d+)_(\d+)_/) {
+	  if ($1 ne $chr) { # different chr
+		$is_correct = 0;
+	  } else {
+		if ($flag & 2) {
+		  if (($t[1]&0x40) && !($t[1]&0x10)) { # F3, forward
+			$is_correct = 0 if (abs($2 - $left) > $gap && abs($2 - $left0) > $gap);
+		  } elsif (($t[1]&0x40) && ($t[1]&0x10)) { # F3, reverse
+			$is_correct = 0 if (abs($3 - $rght) > $gap && abs($3 - $rght0) > $gap);
+		  } elsif (($t[1]&0x80) && !($t[1]&0x10)) { # R3, forward
+			$is_correct = 0 if (abs($3 - $left) > $gap && abs($3 - $left0) > $gap);
+		  } else { # R3, reverse
+			$is_correct = 0 if (abs($2 - $rght) > $gap && abs($3 - $rght0) > $gap);
+		  }
+		} else {
+		  if ($t[1] & 0x10) { # reverse
+			$is_correct = 0 if (abs($3 - $rght) > $gap && abs($3 - $rght0) > $gap); # in case of indels that are close to the end of a reads
+		  } else {
+			$is_correct = 0 if (abs($2 - $left) > $gap && abs($2 - $left0) > $gap);
+		  }
+		}
+	  }
+	} else {
+	  warn("[wgsim_eval] read '$t[0]' was not generated by wgsim?\n");
+	  next;
+	}
+	++$c0[$q];
+	++$c1[$q] unless ($is_correct);
+	print STDERR $line if (($flag&1) && !$is_correct && $q > 0);
+  }
+  # print
+  my ($cc0, $cc1) = (0, 0);
+  for (my $i = $max_q; $i >= 0; --$i) {
+	$c0[$i] = 0 unless (defined $c0[$i]);
+	$c1[$i] = 0 unless (defined $c1[$i]);
+	$cc0 += $c0[$i]; $cc1 += $c1[$i];
+	printf("%.2dx %12d / %-12d  %12d  %.3e\n", $i, $c1[$i], $c0[$i], $cc0, $cc1/$cc0);
+  }
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/misc/zoom2sam.pl b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/zoom2sam.pl
new file mode 100644
index 0000000..5306bfa
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/misc/zoom2sam.pl
@@ -0,0 +1,97 @@
+#!/usr/bin/perl -w
+
+# Contact: lh3
+# Version: 0.1.0
+
+use strict;
+use warnings;
+use Getopt::Std;
+
+&zoom2sam;
+exit;
+
+sub mating {
+  my ($s1, $s2) = @_;
+  my $isize = 0;
+  if ($s1->[2] ne '*' && $s1->[2] eq $s2->[2]) { # then calculate $isize
+	my $x1 = ($s1->[1] & 0x10)? $s1->[3] + length($s1->[9]) : $s1->[3];
+	my $x2 = ($s2->[1] & 0x10)? $s2->[3] + length($s2->[9]) : $s2->[3];
+	$isize = $x2 - $x1;
+  }
+  # update mate coordinate
+  if ($s2->[2] ne '*') {
+	@$s1[6..8] = (($s2->[2] eq $s1->[2])? "=" : $s2->[2], $s2->[3], $isize);
+	$s1->[1] |= 0x20 if ($s2->[1] & 0x10);
+  } else {
+	$s1->[1] |= 0x8;
+  }
+  if ($s1->[2] ne '*') {
+	@$s2[6..8] = (($s1->[2] eq $s2->[2])? "=" : $s1->[2], $s1->[3], -$isize);
+	$s2->[1] |= 0x20 if ($s1->[1] & 0x10);
+  } else {
+	$s2->[1] |= 0x8;
+  }
+}
+
+sub zoom2sam {
+  my %opts = ();
+  getopts("p", \%opts);
+  die("Usage: zoom2sam.pl [-p] <readLen> <aln.zoom>
+Warnings: This script only supports the default Illumina outputs.\n") if (@ARGV < 2);
+  my $is_paired = defined($opts{p});
+  my $len = shift(@ARGV);
+  # core loop
+  my @s1 = ();
+  my @s2 = ();
+  my ($s_last, $s_curr) = (\@s1, \@s2);
+  while (<>) {
+	&zoom2sam_aux($_, $s_curr, $is_paired, $len);
+	if (@$s_last != 0 && $s_last->[0] eq $s_curr->[0]) {
+	  &mating($s_last, $s_curr);
+	  print join("\t", @$s_last), "\n";
+	  print join("\t", @$s_curr), "\n";
+	  @$s_last = (); @$s_curr = ();
+	} else {
+	  print join("\t", @$s_last), "\n" if (@$s_last != 0);
+	  my $s = $s_last; $s_last = $s_curr; $s_curr = $s;
+	}
+  }
+  print join("\t", @$s_last), "\n" if (@$s_last != 0);
+}
+
+sub zoom2sam_aux {
+  my ($line, $s, $is_paired, $len) = @_;
+  chomp($line);
+  my @t = split("\t", $line);
+  @$s = ();
+  # read name
+  $s->[0] = $t[0];
+  # initial flag (will be updated later)
+  $s->[1] = 0;
+  $s->[1] |= 1 | 1<<6 if ($s->[0] =~ /_F$/);
+  $s->[1] |= 1 | 1<<7 if ($s->[0] =~ /_R$/);
+  $s->[1] |= 2 if ($is_paired);
+  # read & quality
+  $s->[9] = "*"; $s->[10] = "*";
+  # cigar
+  $s->[5] = $len . "M";
+  # coor
+  my @s = split(/\s+/, $t[1]);
+  $s->[2] = $s[0];
+  $t[1] =~ /:(\d+)$/;
+  $s->[3] = $1 + 1;
+  if ($s->[0] =~ /_[FR]$/) {
+	my $u = ($s->[0] =~ /_F$/)? 1 : 0;
+	my $w = ($t[2] eq '+')? 1 : 0;
+	$s->[1] |= 0x10 if ($u ^ $w);
+	$s->[0] =~ s/_[FR]$//;
+  } else {
+	$s->[1] |= 0x10 if ($t[2] eq '-');
+  }
+  # mapQ
+  $s->[4] = 30;
+  # mate coordinate
+  $s->[6] = '*'; $s->[7] = $s->[8] = 0;
+  # aux
+  push(@$s, "NM:i:$t[3]");
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/razf.c b/ext/samtools-0.1.7a_getUnique-0.1.3/razf.c
new file mode 100644
index 0000000..e7499f9
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/razf.c
@@ -0,0 +1,853 @@
+/*
+ * RAZF : Random Access compressed(Z) File
+ * Version: 1.0
+ * Release Date: 2008-10-27
+ *
+ * Copyright 2008, Jue Ruan <ruanjue@gmail.com>, Heng Li <lh3@sanger.ac.uk>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _NO_RAZF
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include "razf.h"
+
+
+#if ZLIB_VERNUM < 0x1221
+struct _gz_header_s {
+    int     text;
+    uLong   time;
+    int     xflags;
+    int     os;
+    Bytef   *extra;
+    uInt    extra_len;
+    uInt    extra_max;
+    Bytef   *name;
+    uInt    name_max;
+    Bytef   *comment;
+    uInt    comm_max;
+    int     hcrc;
+    int     done;
+};
+#warning "zlib < 1.2.2.1; RAZF writing is disabled."
+#endif
+
+#define DEF_MEM_LEVEL 8
+
+static inline uint32_t byte_swap_4(uint32_t v){
+	v = ((v & 0x0000FFFFU) << 16) | (v >> 16);
+	return ((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8);
+}
+
+static inline uint64_t byte_swap_8(uint64_t v){
+	v = ((v & 0x00000000FFFFFFFFLLU) << 32) | (v >> 32);
+	v = ((v & 0x0000FFFF0000FFFFLLU) << 16) | ((v & 0xFFFF0000FFFF0000LLU) >> 16);
+	return ((v & 0x00FF00FF00FF00FFLLU) << 8) | ((v & 0xFF00FF00FF00FF00LLU) >> 8);
+}
+
+static inline int is_big_endian(){
+	int x = 0x01;
+	char *c = (char*)&x;
+	return (c[0] != 0x01);
+}
+
+#ifndef _RZ_READONLY
+static void add_zindex(RAZF *rz, int64_t in, int64_t out){
+	if(rz->index->size == rz->index->cap){
+		rz->index->cap = rz->index->cap * 1.5 + 2;
+		rz->index->cell_offsets = realloc(rz->index->cell_offsets, sizeof(int) * rz->index->cap);
+		rz->index->bin_offsets  = realloc(rz->index->bin_offsets, sizeof(int64_t) * (rz->index->cap/RZ_BIN_SIZE + 1));
+	}
+	if(rz->index->size % RZ_BIN_SIZE == 0) rz->index->bin_offsets[rz->index->size / RZ_BIN_SIZE] = out;
+	rz->index->cell_offsets[rz->index->size] = out - rz->index->bin_offsets[rz->index->size / RZ_BIN_SIZE];
+	rz->index->size ++;
+}
+
+static void save_zindex(RAZF *rz, int fd){
+	int32_t i, v32;
+	int is_be;
+	is_be = is_big_endian();
+	if(is_be) write(fd, &rz->index->size, sizeof(int));
+	else {
+		v32 = byte_swap_4((uint32_t)rz->index->size);
+		write(fd, &v32, sizeof(uint32_t));
+	}
+	v32 = rz->index->size / RZ_BIN_SIZE + 1;
+	if(!is_be){
+		for(i=0;i<v32;i++) rz->index->bin_offsets[i]  = byte_swap_8((uint64_t)rz->index->bin_offsets[i]);
+		for(i=0;i<rz->index->size;i++) rz->index->cell_offsets[i] = byte_swap_4((uint32_t)rz->index->cell_offsets[i]);
+	}
+	write(fd, rz->index->bin_offsets, sizeof(int64_t) * v32);
+	write(fd, rz->index->cell_offsets, sizeof(int32_t) * rz->index->size);
+}
+#endif
+
+#ifdef _USE_KNETFILE
+static void load_zindex(RAZF *rz, knetFile *fp){
+#else
+static void load_zindex(RAZF *rz, int fd){
+#endif
+	int32_t i, v32;
+	int is_be;
+	if(!rz->load_index) return;
+	if(rz->index == NULL) rz->index = malloc(sizeof(ZBlockIndex));
+	is_be = is_big_endian();
+#ifdef _USE_KNETFILE
+	knet_read(fp, &rz->index->size, sizeof(int));
+#else
+	read(fd, &rz->index->size, sizeof(int));
+#endif
+	if(!is_be) rz->index->size = byte_swap_4((uint32_t)rz->index->size);
+	rz->index->cap = rz->index->size;
+	v32 = rz->index->size / RZ_BIN_SIZE + 1;
+	rz->index->bin_offsets  = malloc(sizeof(int64_t) * v32);
+#ifdef _USE_KNETFILE
+	knet_read(fp, rz->index->bin_offsets, sizeof(int64_t) * v32);
+#else
+	read(fd, rz->index->bin_offsets, sizeof(int64_t) * v32);
+#endif
+	rz->index->cell_offsets = malloc(sizeof(int) * rz->index->size);
+#ifdef _USE_KNETFILE
+	knet_read(fp, rz->index->cell_offsets, sizeof(int) * rz->index->size);
+#else
+	read(fd, rz->index->cell_offsets, sizeof(int) * rz->index->size);
+#endif
+	if(!is_be){
+		for(i=0;i<v32;i++) rz->index->bin_offsets[i] = byte_swap_8((uint64_t)rz->index->bin_offsets[i]);
+		for(i=0;i<rz->index->size;i++) rz->index->cell_offsets[i] = byte_swap_4((uint32_t)rz->index->cell_offsets[i]);
+	}
+}
+
+#ifdef _RZ_READONLY
+static RAZF* razf_open_w(int fd)
+{
+	fprintf(stderr, "[razf_open_w] Writing is not available with zlib ver < 1.2.2.1\n");
+	return 0;
+}
+#else
+static RAZF* razf_open_w(int fd){
+	RAZF *rz;
+#ifdef _WIN32
+	setmode(fd, O_BINARY);
+#endif
+	rz = calloc(1, sizeof(RAZF));
+	rz->mode = 'w';
+#ifdef _USE_KNETFILE
+    rz->x.fpw = fd;
+#else
+	rz->filedes = fd;
+#endif
+	rz->stream = calloc(sizeof(z_stream), 1);
+	rz->inbuf  = malloc(RZ_BUFFER_SIZE);
+	rz->outbuf = malloc(RZ_BUFFER_SIZE);
+	rz->index = calloc(sizeof(ZBlockIndex), 1);
+	deflateInit2(rz->stream, RZ_COMPRESS_LEVEL, Z_DEFLATED, WINDOW_BITS + 16, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
+	rz->stream->avail_out = RZ_BUFFER_SIZE;
+	rz->stream->next_out  = rz->outbuf;
+	rz->header = calloc(sizeof(gz_header), 1);
+	rz->header->os    = 0x03; //Unix
+	rz->header->text  = 0;
+	rz->header->time  = 0;
+	rz->header->extra = malloc(7);
+	strncpy((char*)rz->header->extra, "RAZF", 4);
+	rz->header->extra[4] = 1; // obsolete field
+	// block size = RZ_BLOCK_SIZE, Big-Endian
+	rz->header->extra[5] = RZ_BLOCK_SIZE >> 8;
+	rz->header->extra[6] = RZ_BLOCK_SIZE & 0xFF;
+	rz->header->extra_len = 7;
+	rz->header->name = rz->header->comment  = 0;
+	rz->header->hcrc = 0;
+	deflateSetHeader(rz->stream, rz->header);
+	rz->block_pos = rz->block_off = 0;
+	return rz;
+}
+
+static void _razf_write(RAZF* rz, const void *data, int size){
+	int tout;
+	rz->stream->avail_in = size;
+	rz->stream->next_in  = (void*)data;
+	while(1){
+		tout = rz->stream->avail_out;
+		deflate(rz->stream, Z_NO_FLUSH);
+		rz->out += tout - rz->stream->avail_out;
+		if(rz->stream->avail_out) break;
+#ifdef _USE_KNETFILE
+		write(rz->x.fpw, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#else
+		write(rz->filedes, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#endif
+		rz->stream->avail_out = RZ_BUFFER_SIZE;
+		rz->stream->next_out  = rz->outbuf;
+		if(rz->stream->avail_in == 0) break;
+	};
+	rz->in += size - rz->stream->avail_in;
+	rz->block_off += size - rz->stream->avail_in;
+}
+
+static void razf_flush(RAZF *rz){
+	uint32_t tout;
+	if(rz->buf_len){
+		_razf_write(rz, rz->inbuf, rz->buf_len);
+		rz->buf_off = rz->buf_len = 0;
+	}
+	if(rz->stream->avail_out){
+#ifdef _USE_KNETFILE    
+		write(rz->x.fpw, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#else        
+		write(rz->filedes, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#endif
+		rz->stream->avail_out = RZ_BUFFER_SIZE;
+		rz->stream->next_out  = rz->outbuf;
+	}
+	while(1){
+		tout = rz->stream->avail_out;
+		deflate(rz->stream, Z_FULL_FLUSH);
+		rz->out += tout - rz->stream->avail_out;
+		if(rz->stream->avail_out == 0){
+#ifdef _USE_KNETFILE    
+			write(rz->x.fpw, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#else            
+			write(rz->filedes, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#endif
+			rz->stream->avail_out = RZ_BUFFER_SIZE;
+			rz->stream->next_out  = rz->outbuf;
+		} else break;
+	}
+	rz->block_pos = rz->out;
+	rz->block_off = 0;
+}
+
+static void razf_end_flush(RAZF *rz){
+	uint32_t tout;
+	if(rz->buf_len){
+		_razf_write(rz, rz->inbuf, rz->buf_len);
+		rz->buf_off = rz->buf_len = 0;
+	}
+	while(1){
+		tout = rz->stream->avail_out;
+		deflate(rz->stream, Z_FINISH);
+		rz->out += tout - rz->stream->avail_out;
+		if(rz->stream->avail_out < RZ_BUFFER_SIZE){
+#ifdef _USE_KNETFILE        
+			write(rz->x.fpw, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#else            
+			write(rz->filedes, rz->outbuf, RZ_BUFFER_SIZE - rz->stream->avail_out);
+#endif
+			rz->stream->avail_out = RZ_BUFFER_SIZE;
+			rz->stream->next_out  = rz->outbuf;
+		} else break;
+	}
+}
+
+static void _razf_buffered_write(RAZF *rz, const void *data, int size){
+	int i, n;
+	while(1){
+		if(rz->buf_len == RZ_BUFFER_SIZE){
+			_razf_write(rz, rz->inbuf, rz->buf_len);
+			rz->buf_len = 0;
+		}
+		if(size + rz->buf_len < RZ_BUFFER_SIZE){
+			for(i=0;i<size;i++) ((char*)rz->inbuf + rz->buf_len)[i] = ((char*)data)[i];
+			rz->buf_len += size;
+			return;
+		} else {
+			n = RZ_BUFFER_SIZE - rz->buf_len;
+			for(i=0;i<n;i++) ((char*)rz->inbuf + rz->buf_len)[i] = ((char*)data)[i];
+			size -= n;
+			data += n;
+			rz->buf_len += n;
+		}
+	}
+}
+
+int razf_write(RAZF* rz, const void *data, int size){
+	int ori_size, n;
+	int64_t next_block;
+	ori_size = size;
+	next_block = ((rz->in / RZ_BLOCK_SIZE) + 1) * RZ_BLOCK_SIZE;
+	while(rz->in + rz->buf_len + size >= next_block){
+		n = next_block - rz->in - rz->buf_len;
+		_razf_buffered_write(rz, data, n);
+		data += n;
+		size -= n;
+		razf_flush(rz);
+		add_zindex(rz, rz->in, rz->out);
+		next_block = ((rz->in / RZ_BLOCK_SIZE) + 1) * RZ_BLOCK_SIZE;
+	}
+	_razf_buffered_write(rz, data, size);
+	return ori_size;
+}
+#endif
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
+#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define RESERVED     0xE0 /* bits 5..7: reserved */
+
+static int _read_gz_header(unsigned char *data, int size, int *extra_off, int *extra_len){
+	int method, flags, n, len;
+	if(size < 2) return 0;
+	if(data[0] != 0x1f || data[1] != 0x8b) return 0;
+	if(size < 4) return 0;
+	method = data[2];
+	flags  = data[3];
+	if(method != Z_DEFLATED || (flags & RESERVED)) return 0;
+	n = 4 + 6; // Skip 6 bytes
+	*extra_off = n + 2;
+	*extra_len = 0;
+	if(flags & EXTRA_FIELD){
+		if(size < n + 2) return 0;
+		len = ((int)data[n + 1] << 8) | data[n];
+		n += 2;
+		*extra_off = n;
+		while(len){
+			if(n >= size) return 0;
+			n ++;
+			len --;
+		}
+		*extra_len = n - (*extra_off);
+	}
+	if(flags & ORIG_NAME) while(n < size && data[n++]);
+	if(flags & COMMENT) while(n < size && data[n++]);
+	if(flags & HEAD_CRC){
+		if(n + 2 > size) return 0;
+		n += 2;
+	}
+	return n;
+}
+
+#ifdef _USE_KNETFILE
+static RAZF* razf_open_r(knetFile *fp, int _load_index){
+#else
+static RAZF* razf_open_r(int fd, int _load_index){
+#endif
+	RAZF *rz;
+	int ext_off, ext_len;
+	int n, is_be, ret;
+	int64_t end;
+	unsigned char c[] = "RAZF";
+	rz = calloc(1, sizeof(RAZF));
+	rz->mode = 'r';
+#ifdef _USE_KNETFILE
+    rz->x.fpr = fp;
+#else
+#ifdef _WIN32
+	setmode(fd, O_BINARY);
+#endif
+	rz->filedes = fd;
+#endif
+	rz->stream = calloc(sizeof(z_stream), 1);
+	rz->inbuf  = malloc(RZ_BUFFER_SIZE);
+	rz->outbuf = malloc(RZ_BUFFER_SIZE);
+	rz->end = rz->src_end = 0x7FFFFFFFFFFFFFFFLL;
+#ifdef _USE_KNETFILE
+    n = knet_read(rz->x.fpr, rz->inbuf, RZ_BUFFER_SIZE);
+#else
+	n = read(rz->filedes, rz->inbuf, RZ_BUFFER_SIZE);
+#endif
+	ret = _read_gz_header(rz->inbuf, n, &ext_off, &ext_len);
+	if(ret == 0){
+		PLAIN_FILE:
+		rz->in = n;
+		rz->file_type = FILE_TYPE_PLAIN;
+		memcpy(rz->outbuf, rz->inbuf, n);
+		rz->buf_len = n;
+		free(rz->stream);
+		rz->stream = NULL;
+		return rz;
+	}
+	rz->header_size = ret;
+	ret = inflateInit2(rz->stream, -WINDOW_BITS);
+	if(ret != Z_OK){ inflateEnd(rz->stream); goto PLAIN_FILE;}
+	rz->stream->avail_in = n - rz->header_size;
+	rz->stream->next_in  = rz->inbuf + rz->header_size;
+	rz->stream->avail_out = RZ_BUFFER_SIZE;
+	rz->stream->next_out  = rz->outbuf;
+	rz->file_type = FILE_TYPE_GZ;
+	rz->in = rz->header_size;
+	rz->block_pos = rz->header_size;
+	rz->next_block_pos = rz->header_size;
+	rz->block_off = 0;
+	if(ext_len < 7 || memcmp(rz->inbuf + ext_off, c, 4) != 0) return rz;
+	if(((((unsigned char*)rz->inbuf)[ext_off + 5] << 8) | ((unsigned char*)rz->inbuf)[ext_off + 6]) != RZ_BLOCK_SIZE){
+		fprintf(stderr, " -- WARNING: RZ_BLOCK_SIZE is not %d, treat source as gz file.  in %s -- %s:%d --\n", RZ_BLOCK_SIZE, __FUNCTION__, __FILE__, __LINE__);
+		return rz;
+	}
+	rz->load_index = _load_index;
+	rz->file_type = FILE_TYPE_RZ;
+#ifdef _USE_KNETFILE
+	if(knet_seek(fp, -16, SEEK_END) == -1){
+#else
+	if(lseek(fd, -16, SEEK_END) == -1){
+#endif
+		UNSEEKABLE:
+		rz->seekable = 0;
+		rz->index = NULL;
+		rz->src_end = rz->end = 0x7FFFFFFFFFFFFFFFLL;
+	} else {
+		is_be = is_big_endian();
+		rz->seekable = 1;
+#ifdef _USE_KNETFILE
+        knet_read(fp, &end, sizeof(int64_t));
+#else
+		read(fd, &end, sizeof(int64_t));
+#endif        
+		if(!is_be) rz->src_end = (int64_t)byte_swap_8((uint64_t)end);
+		else rz->src_end = end;
+
+#ifdef _USE_KNETFILE
+		knet_read(fp, &end, sizeof(int64_t));
+#else
+		read(fd, &end, sizeof(int64_t));
+#endif        
+		if(!is_be) rz->end = (int64_t)byte_swap_8((uint64_t)end);
+		else rz->end = end;
+		if(n > rz->end){
+			rz->stream->avail_in -= n - rz->end;
+			n = rz->end;
+		}
+		if(rz->end > rz->src_end){
+#ifdef _USE_KNETFILE
+            knet_seek(fp, rz->in, SEEK_SET);
+#else
+			lseek(fd, rz->in, SEEK_SET);
+#endif
+			goto UNSEEKABLE;
+		}
+#ifdef _USE_KNETFILE
+        knet_seek(fp, rz->end, SEEK_SET);
+		if(knet_tell(fp) != rz->end){
+			knet_seek(fp, rz->in, SEEK_SET);
+#else
+		if(lseek(fd, rz->end, SEEK_SET) != rz->end){
+			lseek(fd, rz->in, SEEK_SET);
+#endif
+			goto UNSEEKABLE;
+		}
+#ifdef _USE_KNETFILE
+		load_zindex(rz, fp);
+		knet_seek(fp, n, SEEK_SET);
+#else
+		load_zindex(rz, fd);
+		lseek(fd, n, SEEK_SET);
+#endif
+	}
+	return rz;
+}
+
+#ifdef _USE_KNETFILE
+RAZF* razf_dopen(int fd, const char *mode){
+    if (strstr(mode, "r")) fprintf(stderr,"[razf_dopen] implement me\n");
+    else if(strstr(mode, "w")) return razf_open_w(fd);
+	return NULL;
+}
+
+RAZF* razf_dopen2(int fd, const char *mode)
+{
+    fprintf(stderr,"[razf_dopen2] implement me\n");
+    return NULL;
+}
+#else
+RAZF* razf_dopen(int fd, const char *mode){
+	if(strstr(mode, "r")) return razf_open_r(fd, 1);
+	else if(strstr(mode, "w")) return razf_open_w(fd);
+	else return NULL;
+}
+
+RAZF* razf_dopen2(int fd, const char *mode)
+{
+	if(strstr(mode, "r")) return razf_open_r(fd, 0);
+	else if(strstr(mode, "w")) return razf_open_w(fd);
+	else return NULL;
+}
+#endif
+
+static inline RAZF* _razf_open(const char *filename, const char *mode, int _load_index){
+	int fd;
+	RAZF *rz;
+	if(strstr(mode, "r")){
+#ifdef _USE_KNETFILE
+        knetFile *fd = knet_open(filename, "r");
+        if (fd == 0) {
+            fprintf(stderr, "[_razf_open] fail to open %s\n", filename);
+            return NULL;
+        }
+#else
+#ifdef _WIN32
+		fd = open(filename, O_RDONLY | O_BINARY);
+#else
+		fd = open(filename, O_RDONLY);
+#endif
+#endif
+		if(fd < 0) return NULL;
+		rz = razf_open_r(fd, _load_index);
+	} else if(strstr(mode, "w")){
+#ifdef _WIN32
+		fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
+#else
+		fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+#endif
+		if(fd < 0) return NULL;
+		rz = razf_open_w(fd);
+	} else return NULL;
+	return rz;
+}
+
+RAZF* razf_open(const char *filename, const char *mode){
+	return _razf_open(filename, mode, 1);
+}
+
+RAZF* razf_open2(const char *filename, const char *mode){
+	return _razf_open(filename, mode, 0);
+}
+
+int razf_get_data_size(RAZF *rz, int64_t *u_size, int64_t *c_size){
+	int64_t n;
+	if(rz->mode != 'r' && rz->mode != 'R') return 0;
+	switch(rz->file_type){
+		case FILE_TYPE_PLAIN:
+			if(rz->end == 0x7fffffffffffffffLL){
+#ifdef _USE_KNETFILE
+				if(knet_seek(rz->x.fpr, 0, SEEK_CUR) == -1) return 0;
+                n = knet_tell(rz->x.fpr);
+				knet_seek(rz->x.fpr, 0, SEEK_END);
+                rz->end = knet_tell(rz->x.fpr);
+				knet_seek(rz->x.fpr, n, SEEK_SET);
+#else
+				if((n = lseek(rz->filedes, 0, SEEK_CUR)) == -1) return 0;
+				rz->end = lseek(rz->filedes, 0, SEEK_END);
+				lseek(rz->filedes, n, SEEK_SET);
+#endif                
+			}
+			*u_size = *c_size = rz->end;
+			return 1;
+		case FILE_TYPE_GZ:
+			return 0;
+		case FILE_TYPE_RZ:
+			if(rz->src_end == rz->end) return 0;
+			*u_size = rz->src_end;
+			*c_size = rz->end;
+			return 1;
+		default:
+			return 0;
+	}
+}
+
+static int _razf_read(RAZF* rz, void *data, int size){
+	int ret, tin;
+	if(rz->z_eof || rz->z_err) return 0;
+	if (rz->file_type == FILE_TYPE_PLAIN) {
+#ifdef _USE_KNETFILE
+		ret = knet_read(rz->x.fpr, data, size);
+#else
+		ret = read(rz->filedes, data, size);
+#endif        
+		if (ret == 0) rz->z_eof = 1;
+		return ret;
+	}
+	rz->stream->avail_out = size;
+	rz->stream->next_out  = data;
+	while(rz->stream->avail_out){
+		if(rz->stream->avail_in == 0){
+			if(rz->in >= rz->end){ rz->z_eof = 1; break; }
+			if(rz->end - rz->in < RZ_BUFFER_SIZE){
+#ifdef _USE_KNETFILE
+				rz->stream->avail_in = knet_read(rz->x.fpr, rz->inbuf, rz->end -rz->in);
+#else
+				rz->stream->avail_in = read(rz->filedes, rz->inbuf, rz->end -rz->in);
+#endif        
+			} else {
+#ifdef _USE_KNETFILE
+				rz->stream->avail_in = knet_read(rz->x.fpr, rz->inbuf, RZ_BUFFER_SIZE);
+#else
+				rz->stream->avail_in = read(rz->filedes, rz->inbuf, RZ_BUFFER_SIZE);
+#endif        
+			}
+			if(rz->stream->avail_in == 0){
+				rz->z_eof = 1;
+				break;
+			}
+			rz->stream->next_in = rz->inbuf;
+		}
+		tin = rz->stream->avail_in;
+		ret = inflate(rz->stream, Z_BLOCK);
+		rz->in += tin - rz->stream->avail_in;
+		if(ret == Z_NEED_DICT || ret == Z_MEM_ERROR || ret == Z_DATA_ERROR){
+			fprintf(stderr, "[_razf_read] inflate error: %d %s (at %s:%d)\n", ret, rz->stream->msg ? rz->stream->msg : "", __FILE__, __LINE__);
+			rz->z_err = 1;
+			break;
+		}
+		if(ret == Z_STREAM_END){
+			rz->z_eof = 1;
+			break;
+		}
+		if ((rz->stream->data_type&128) && !(rz->stream->data_type&64)){
+			rz->buf_flush = 1;
+			rz->next_block_pos = rz->in;
+			break;
+		}
+	}
+	return size - rz->stream->avail_out;
+}
+
+int razf_read(RAZF *rz, void *data, int size){
+	int ori_size, i;
+	ori_size = size;
+	while(size > 0){
+		if(rz->buf_len){
+			if(size < rz->buf_len){
+				for(i=0;i<size;i++) ((char*)data)[i] = ((char*)rz->outbuf + rz->buf_off)[i];
+				rz->buf_off += size;
+				rz->buf_len -= size;
+				data += size;
+				rz->block_off += size;
+				size = 0;
+				break;
+			} else {
+				for(i=0;i<rz->buf_len;i++) ((char*)data)[i] = ((char*)rz->outbuf + rz->buf_off)[i];
+				data += rz->buf_len;
+				size -= rz->buf_len;
+				rz->block_off += rz->buf_len;
+				rz->buf_off = 0;
+				rz->buf_len = 0;
+				if(rz->buf_flush){
+					rz->block_pos = rz->next_block_pos;
+					rz->block_off = 0;
+					rz->buf_flush = 0;
+				}
+			}
+		} else if(rz->buf_flush){
+			rz->block_pos = rz->next_block_pos;
+			rz->block_off = 0;
+			rz->buf_flush = 0;
+		}
+		if(rz->buf_flush) continue;
+		rz->buf_len = _razf_read(rz, rz->outbuf, RZ_BUFFER_SIZE);
+		if(rz->z_eof && rz->buf_len == 0) break;
+	}
+	rz->out += ori_size - size;
+	return ori_size - size;
+}
+
+int razf_skip(RAZF* rz, int size){
+	int ori_size;
+	ori_size = size;
+	while(size > 0){
+		if(rz->buf_len){
+			if(size < rz->buf_len){
+				rz->buf_off += size;
+				rz->buf_len -= size;
+				rz->block_off += size;
+				size = 0;
+				break;
+			} else {
+				size -= rz->buf_len;
+				rz->buf_off = 0;
+				rz->buf_len = 0;
+				rz->block_off += rz->buf_len;
+				if(rz->buf_flush){
+					rz->block_pos = rz->next_block_pos;
+					rz->block_off = 0;
+					rz->buf_flush = 0;
+				}
+			}
+		} else if(rz->buf_flush){
+			rz->block_pos = rz->next_block_pos;
+			rz->block_off = 0;
+			rz->buf_flush = 0;
+		}
+		if(rz->buf_flush) continue;
+		rz->buf_len = _razf_read(rz, rz->outbuf, RZ_BUFFER_SIZE);
+		if(rz->z_eof || rz->z_err) break;
+	}
+	rz->out += ori_size - size;
+	return ori_size - size;
+}
+
+static void _razf_reset_read(RAZF *rz, int64_t in, int64_t out){
+#ifdef _USE_KNETFILE
+	knet_seek(rz->x.fpr, in, SEEK_SET);
+#else
+	lseek(rz->filedes, in, SEEK_SET);
+#endif
+	rz->in  = in;
+	rz->out = out;
+	rz->block_pos = in;
+	rz->next_block_pos = in;
+	rz->block_off = 0;
+	rz->buf_flush = 0;
+	rz->z_eof = rz->z_err = 0;
+	inflateReset(rz->stream);
+	rz->stream->avail_in = 0;
+	rz->buf_off = rz->buf_len = 0;
+}
+
+int64_t razf_jump(RAZF *rz, int64_t block_start, int block_offset){
+	int64_t pos;
+	rz->z_eof = 0;
+	if(rz->file_type == FILE_TYPE_PLAIN){
+		rz->buf_off = rz->buf_len = 0;
+		pos = block_start + block_offset;
+#ifdef _USE_KNETFILE
+		knet_seek(rz->x.fpr, pos, SEEK_SET);
+        pos = knet_tell(rz->x.fpr);
+#else
+		pos = lseek(rz->filedes, pos, SEEK_SET);
+#endif
+		rz->out = rz->in = pos;
+		return pos;
+	}
+	if(block_start == rz->block_pos && block_offset >= rz->block_off) {
+		block_offset -= rz->block_off;
+		goto SKIP; // Needn't reset inflate
+	}
+	if(block_start  == 0) block_start = rz->header_size; // Automaticly revist wrong block_start
+	_razf_reset_read(rz, block_start, 0);
+	SKIP:
+	if(block_offset) razf_skip(rz, block_offset);
+	return rz->block_off;
+}
+
+int64_t razf_seek(RAZF* rz, int64_t pos, int where){
+	int64_t idx;
+	int64_t seek_pos, new_out;
+	rz->z_eof = 0;
+	if (where == SEEK_CUR) pos += rz->out;
+	else if (where == SEEK_END) pos += rz->src_end;
+	if(rz->file_type == FILE_TYPE_PLAIN){
+#ifdef _USE_KNETFILE
+		knet_seek(rz->x.fpr, pos, SEEK_SET);
+        seek_pos = knet_tell(rz->x.fpr);
+#else
+		seek_pos = lseek(rz->filedes, pos, SEEK_SET);
+#endif
+		rz->buf_off = rz->buf_len = 0;
+		rz->out = rz->in = seek_pos;
+		return seek_pos;
+	} else if(rz->file_type == FILE_TYPE_GZ){
+		if(pos >= rz->out) goto SKIP;
+		return rz->out;
+	}
+	if(pos == rz->out) return pos;
+	if(pos > rz->src_end) return rz->out;
+	if(!rz->seekable || !rz->load_index){
+		if(pos >= rz->out) goto SKIP;
+	}
+	idx = pos / RZ_BLOCK_SIZE - 1;
+	seek_pos = (idx < 0)? rz->header_size:(rz->index->cell_offsets[idx] + rz->index->bin_offsets[idx / RZ_BIN_SIZE]);
+	new_out  = (idx + 1) * RZ_BLOCK_SIZE;
+	if(pos > rz->out && new_out <= rz->out) goto SKIP;
+	_razf_reset_read(rz, seek_pos, new_out);
+	SKIP:
+	razf_skip(rz, (int)(pos - rz->out));
+	return rz->out;
+}
+
+uint64_t razf_tell2(RAZF *rz)
+{
+	/*
+	if (rz->load_index) {
+		int64_t idx, seek_pos;
+		idx = rz->out / RZ_BLOCK_SIZE - 1;
+		seek_pos = (idx < 0)? rz->header_size:(rz->index->cell_offsets[idx] + rz->index->bin_offsets[idx / RZ_BIN_SIZE]);
+		if (seek_pos != rz->block_pos || rz->out%RZ_BLOCK_SIZE != rz->block_off)
+			fprintf(stderr, "[razf_tell2] inconsistent block offset: (%lld, %lld) != (%lld, %lld)\n",
+					(long long)seek_pos, (long long)rz->out%RZ_BLOCK_SIZE, (long long)rz->block_pos, (long long) rz->block_off);
+	}
+	*/
+	return (uint64_t)rz->block_pos<<16 | (rz->block_off&0xffff);
+}
+
+int64_t razf_seek2(RAZF *rz, uint64_t voffset, int where)
+{
+	if (where != SEEK_SET) return -1;
+	return razf_jump(rz, voffset>>16, voffset&0xffff);
+}
+
+void razf_close(RAZF *rz){
+	if(rz->mode == 'w'){
+#ifndef _RZ_READONLY
+		razf_end_flush(rz);
+		deflateEnd(rz->stream);
+#ifdef _USE_KNETFILE
+		save_zindex(rz, rz->x.fpw);
+		if(is_big_endian()){
+			write(rz->x.fpw, &rz->in, sizeof(int64_t));
+			write(rz->x.fpw, &rz->out, sizeof(int64_t));
+		} else {
+			uint64_t v64 = byte_swap_8((uint64_t)rz->in);
+			write(rz->x.fpw, &v64, sizeof(int64_t));
+			v64 = byte_swap_8((uint64_t)rz->out);
+			write(rz->x.fpw, &v64, sizeof(int64_t));
+		}
+#else
+		save_zindex(rz, rz->filedes);
+		if(is_big_endian()){
+			write(rz->filedes, &rz->in, sizeof(int64_t));
+			write(rz->filedes, &rz->out, sizeof(int64_t));
+		} else {
+			uint64_t v64 = byte_swap_8((uint64_t)rz->in);
+			write(rz->filedes, &v64, sizeof(int64_t));
+			v64 = byte_swap_8((uint64_t)rz->out);
+			write(rz->filedes, &v64, sizeof(int64_t));
+		}
+#endif
+#endif
+	} else if(rz->mode == 'r'){
+		if(rz->stream) inflateEnd(rz->stream);
+	}
+	if(rz->inbuf) free(rz->inbuf);
+	if(rz->outbuf) free(rz->outbuf);
+	if(rz->header){
+		free(rz->header->extra);
+		free(rz->header->name);
+		free(rz->header->comment);
+		free(rz->header);
+	}
+	if(rz->index){
+		free(rz->index->bin_offsets);
+		free(rz->index->cell_offsets);
+		free(rz->index);
+	}
+	free(rz->stream);
+#ifdef _USE_KNETFILE
+    if (rz->mode == 'r')
+        knet_close(rz->x.fpr);
+    if (rz->mode == 'w')
+        close(rz->x.fpw);
+#else
+	close(rz->filedes);
+#endif
+	free(rz);
+}
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/razf.h b/ext/samtools-0.1.7a_getUnique-0.1.3/razf.h
new file mode 100644
index 0000000..60a0c96
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/razf.h
@@ -0,0 +1,134 @@
+ /*-
+ * RAZF : Random Access compressed(Z) File
+ * Version: 1.0
+ * Release Date: 2008-10-27
+ *
+ * Copyright 2008, Jue Ruan <ruanjue@gmail.com>, Heng Li <lh3@sanger.ac.uk>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+#ifndef __RAZF_RJ_H
+#define __RAZF_RJ_H
+
+#include <stdint.h>
+#include <stdio.h>
+#include "zlib.h"
+
+#ifdef _USE_KNETFILE
+#include "knetfile.h"
+#endif
+
+#if ZLIB_VERNUM < 0x1221
+#define _RZ_READONLY
+struct _gz_header_s;
+typedef struct _gz_header_s _gz_header;
+#define gz_header _gz_header
+#endif
+
+#define WINDOW_BITS   15
+
+#ifndef RZ_BLOCK_SIZE
+#define RZ_BLOCK_SIZE (1<<WINDOW_BITS)
+#endif
+
+#ifndef RZ_BUFFER_SIZE
+#define RZ_BUFFER_SIZE 4096
+#endif
+
+#ifndef RZ_COMPRESS_LEVEL
+#define RZ_COMPRESS_LEVEL 6
+#endif
+
+#define RZ_BIN_SIZE ((1LLU << 32) / RZ_BLOCK_SIZE)
+
+typedef struct {
+	uint32_t *cell_offsets; // i
+	int64_t  *bin_offsets; // i / BIN_SIZE
+	int size;
+	int cap;
+} ZBlockIndex;
+/* When storing index, output bytes in Big-Endian everywhere */
+
+#define FILE_TYPE_RZ	1
+#define FILE_TYPE_PLAIN	2
+#define FILE_TYPE_GZ	3
+
+typedef struct RandomAccessZFile  {
+	char mode; /* 'w' : write mode; 'r' : read mode */
+	int file_type;
+	/* plain file or rz file, razf_read support plain file as input too, in this case, razf_read work as buffered fread */
+#ifdef _USE_KNETFILE
+    union {
+        knetFile *fpr;
+        int fpw;
+    } x;
+#else
+	int filedes; /* the file descriptor */
+#endif
+	z_stream *stream;
+	ZBlockIndex *index;
+	int64_t in, out, end, src_end;
+	/* in: n bytes total in; out: n bytes total out; */
+	/* end: the end of all data blocks, while the start of index; src_end: the true end position in uncompressed file */
+	int buf_flush; // buffer should be flush, suspend inflate util buffer is empty
+	int64_t block_pos, block_off, next_block_pos;
+	/* block_pos: the start postiion of current block  in compressed file */
+	/* block_off: tell how many bytes have been read from current block */
+	void *inbuf, *outbuf;
+	int header_size;
+	gz_header *header;
+	/* header is used to transfer inflate_state->mode from HEAD to TYPE after call inflateReset */
+	int buf_off, buf_len;
+	int z_err, z_eof;
+	int seekable;
+	/* Indice where the source is seekable */
+	int load_index;
+	/* set has_index to 0 in mode 'w', then index will be discarded */
+} RAZF;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	RAZF* razf_dopen(int data_fd, const char *mode);
+	RAZF *razf_open(const char *fn, const char *mode);
+	int razf_write(RAZF* rz, const void *data, int size);
+	int razf_read(RAZF* rz, void *data, int size);
+	int64_t razf_seek(RAZF* rz, int64_t pos, int where);
+	void razf_close(RAZF* rz);
+
+#define razf_tell(rz) ((rz)->out)
+
+	RAZF* razf_open2(const char *filename, const char *mode);
+	RAZF* razf_dopen2(int fd, const char *mode);
+	uint64_t razf_tell2(RAZF *rz);
+	int64_t razf_seek2(RAZF *rz, uint64_t voffset, int where);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/razip.c b/ext/samtools-0.1.7a_getUnique-0.1.3/razip.c
new file mode 100644
index 0000000..dff9347
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/razip.c
@@ -0,0 +1,141 @@
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include "razf.h"
+
+#define WINDOW_SIZE 4096
+
+static int razf_main_usage()
+{
+	printf("\n");
+	printf("Usage:   razip [options] [file] ...\n\n");
+	printf("Options: -c      write on standard output, keep original files unchanged\n");
+	printf("         -d      decompress\n");
+	printf("         -l      list compressed file contents\n");
+	printf("         -b INT  decompress at INT position in the uncompressed file\n");
+	printf("         -s INT  decompress INT bytes in the uncompressed file\n");
+	printf("         -h      give this help\n");
+	printf("\n");
+	return 0;
+}
+
+static int write_open(const char *fn, int is_forced)
+{
+	int fd = -1;
+	char c;
+	if (!is_forced) {
+		if ((fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0666)) < 0 && errno == EEXIST) {
+			printf("razip: %s already exists; do you wish to overwrite (y or n)? ", fn);
+			scanf("%c", &c);
+			if (c != 'Y' && c != 'y') {
+				printf("razip: not overwritten\n");
+				exit(1);
+			}
+		}
+	}
+	if (fd < 0) {
+		if ((fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, 0666)) < 0) {
+			fprintf(stderr, "razip: %s: Fail to write\n", fn);
+			exit(1);
+		}
+	}
+	return fd;
+}
+
+int main(int argc, char **argv)
+{
+	int c, compress, pstdout, is_forced;
+	RAZF *rz;
+	void *buffer;
+	long start, end, size;
+
+	compress = 1; pstdout = 0; start = 0; size = -1; end = -1; is_forced = 0;
+	while((c  = getopt(argc, argv, "cdlhfb:s:")) >= 0){
+		switch(c){
+		case 'h': return razf_main_usage();
+		case 'd': compress = 0; break;
+		case 'c': pstdout = 1; break;
+		case 'l': compress = 2; break;
+		case 'b': start = atol(optarg); break;
+		case 's': size = atol(optarg); break;
+		case 'f': is_forced = 1; break;
+		}
+	}
+	if (size >= 0) end = start + size;
+	if(end >= 0 && end < start){
+		fprintf(stderr, " -- Illegal region: [%ld, %ld] --\n", start, end);
+		return 1;
+	}
+	if(compress == 1){
+		int f_src, f_dst = -1;
+		if(argc > optind){
+			if((f_src = open(argv[optind], O_RDONLY)) < 0){
+				fprintf(stderr, " -- Cannot open file: %s --\n", argv[optind]);
+				return 1;
+			}
+			if(pstdout){
+				f_dst = fileno(stdout);
+			} else {
+				char *name = malloc(sizeof(strlen(argv[optind]) + 5));
+				strcpy(name, argv[optind]);
+				strcat(name, ".rz");
+				f_dst = write_open(name, is_forced);
+				if (f_dst < 0) return 1;
+				free(name);
+			}
+		} else if(pstdout){ 
+			f_src = fileno(stdin);
+			f_dst = fileno(stdout);
+		} else return razf_main_usage();
+		rz = razf_dopen(f_dst, "w");
+		buffer = malloc(WINDOW_SIZE);
+		while((c = read(f_src, buffer, WINDOW_SIZE)) > 0) razf_write(rz, buffer, c);
+		razf_close(rz); // f_dst will be closed here
+		if (argc > optind) unlink(argv[optind]);
+		free(buffer);
+		close(f_src);
+		return 0;
+	} else {
+		if(argc <= optind) return razf_main_usage();
+		if(compress == 2){
+			rz = razf_open(argv[optind], "r");
+			if(rz->file_type == FILE_TYPE_RZ) {
+							printf("%20s%20s%7s %s\n", "compressed", "uncompressed", "ratio", "name");
+				printf("%20lld%20lld%6.1f%% %s\n", (long long)rz->end, (long long)rz->src_end, rz->end * 100.0f / rz->src_end,
+					   argv[optind]);
+			} else fprintf(stdout, "%s is not a regular rz file\n", argv[optind]);
+		} else {
+			int f_dst;
+			if (argc > optind && !pstdout) {
+				char *name;
+				if (strstr(argv[optind], ".rz") - argv[optind] != strlen(argv[optind]) - 3) {
+					printf("razip: %s: unknown suffix -- ignored\n", argv[optind]);
+					return 1;
+				}
+				name = strdup(argv[optind]);
+				name[strlen(name) - 3] = '\0';
+				f_dst = write_open(name, is_forced);
+				free(name);
+			} else f_dst = fileno(stdout);
+			rz = razf_open(argv[optind], "r");
+			buffer = malloc(WINDOW_SIZE);
+			razf_seek(rz, start, SEEK_SET);
+			while(1){
+				if(end < 0) c = razf_read(rz, buffer, WINDOW_SIZE);
+				else c = razf_read(rz, buffer, (end - start > WINDOW_SIZE)? WINDOW_SIZE:(end - start));
+				if(c <= 0) break;
+				start += c;
+				write(f_dst, buffer, c);
+				if(end >= 0 && start >= end) break;
+			}
+			free(buffer);
+			if (!pstdout) unlink(argv[optind]);
+		}
+		razf_close(rz);
+		return 0;
+	}
+}
+
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/sam.c b/ext/samtools-0.1.7a_getUnique-0.1.3/sam.c
new file mode 100644
index 0000000..ad4325b
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/sam.c
@@ -0,0 +1,174 @@
+#include <string.h>
+#include <unistd.h>
+#include "faidx.h"
+#include "sam.h"
+
+#define TYPE_BAM  1
+#define TYPE_READ 2
+
+bam_header_t *bam_header_dup(const bam_header_t *h0)
+{
+	bam_header_t *h;
+	int i;
+	h = bam_header_init();
+	*h = *h0;
+	h->hash = h->dict = h->rg2lib = 0;
+	h->text = (char*)calloc(h->l_text + 1, 1);
+	memcpy(h->text, h0->text, h->l_text);
+	h->target_len = (uint32_t*)calloc(h->n_targets, 4);
+	h->target_name = (char**)calloc(h->n_targets, sizeof(void*));
+	for (i = 0; i < h->n_targets; ++i) {
+		h->target_len[i] = h0->target_len[i];
+		h->target_name[i] = strdup(h0->target_name[i]);
+	}
+	return h;
+}
+static void append_header_text(bam_header_t *header, char* text, int len)
+{
+	int x = header->l_text + 1;
+	int y = header->l_text + len + 1; // 1 byte null
+	if (text == 0) return;
+	kroundup32(x); 
+	kroundup32(y);
+	if (x < y) header->text = (char*)realloc(header->text, y);
+	strncpy(header->text + header->l_text, text, len); // we cannot use strcpy() here.
+	header->l_text += len;
+	header->text[header->l_text] = 0;
+}
+
+samfile_t *samopen(const char *fn, const char *mode, const void *aux)
+{
+	samfile_t *fp;
+	fp = (samfile_t*)calloc(1, sizeof(samfile_t));
+	if (mode[0] == 'r') { // read
+		fp->type |= TYPE_READ;
+		if (mode[1] == 'b') { // binary
+			fp->type |= TYPE_BAM;
+			fp->x.bam = strcmp(fn, "-")? bam_open(fn, "r") : bam_dopen(fileno(stdin), "r");
+			if (fp->x.bam == 0) goto open_err_ret;
+			fp->header = bam_header_read(fp->x.bam);
+		} else { // text
+			fp->x.tamr = sam_open(fn);
+			if (fp->x.tamr == 0) goto open_err_ret;
+			fp->header = sam_header_read(fp->x.tamr);
+			if (fp->header->n_targets == 0) { // no @SQ fields
+				if (aux) { // check if aux is present
+					bam_header_t *textheader = fp->header;
+					fp->header = sam_header_read2((const char*)aux);
+					append_header_text(fp->header, textheader->text, textheader->l_text);
+					bam_header_destroy(textheader);
+				}
+				if (fp->header->n_targets == 0)
+					fprintf(stderr, "[samopen] no @SQ lines in the header.\n");
+			} else fprintf(stderr, "[samopen] SAM header is present: %d sequences.\n", fp->header->n_targets);
+		}
+	} else if (mode[0] == 'w') { // write
+		fp->header = bam_header_dup((const bam_header_t*)aux);
+		if (mode[1] == 'b') { // binary
+			char bmode[3];
+			bmode[0] = 'w'; bmode[1] = strstr(mode, "u")? 'u' : 0; bmode[2] = 0;
+			fp->type |= TYPE_BAM;
+			fp->x.bam = strcmp(fn, "-")? bam_open(fn, bmode) : bam_dopen(fileno(stdout), bmode);
+			if (fp->x.bam == 0) goto open_err_ret;
+			bam_header_write(fp->x.bam, fp->header);
+		} else { // text
+			// open file
+			fp->x.tamw = strcmp(fn, "-")? fopen(fn, "w") : stdout;
+			if (fp->x.tamr == 0) goto open_err_ret;
+			if (strstr(mode, "X")) fp->type |= BAM_OFSTR<<2;
+			else if (strstr(mode, "x")) fp->type |= BAM_OFHEX<<2;
+			else fp->type |= BAM_OFDEC<<2;
+			// write header
+			if (strstr(mode, "h")) {
+				int i;
+				bam_header_t *alt;
+				// parse the header text 
+				alt = bam_header_init();
+				alt->l_text = fp->header->l_text; alt->text = fp->header->text;
+				sam_header_parse(alt);
+				alt->l_text = 0; alt->text = 0;
+				// check if there are @SQ lines in the header
+				fwrite(fp->header->text, 1, fp->header->l_text, fp->x.tamw);
+				if (alt->n_targets) { // then write the header text without dumping ->target_{name,len}
+					if (alt->n_targets != fp->header->n_targets)
+						fprintf(stderr, "[samopen] inconsistent number of target sequences.\n");
+				} else { // then dump ->target_{name,len}
+					for (i = 0; i < fp->header->n_targets; ++i)
+						fprintf(fp->x.tamw, "@SQ\tSN:%s\tLN:%d\n", fp->header->target_name[i], fp->header->target_len[i]);
+				}
+				bam_header_destroy(alt);
+			}
+		}
+	}
+	return fp;
+
+open_err_ret:
+	free(fp);
+	return 0;
+}
+
+void samclose(samfile_t *fp)
+{
+	if (fp == 0) return;
+	if (fp->header) bam_header_destroy(fp->header);
+	if (fp->type & TYPE_BAM) bam_close(fp->x.bam);
+	else if (fp->type & TYPE_READ) sam_close(fp->x.tamr);
+	else fclose(fp->x.tamw);
+	free(fp);
+}
+
+int samread(samfile_t *fp, bam1_t *b)
+{
+	if (fp == 0 || !(fp->type & TYPE_READ)) return -1; // not open for reading
+	if (fp->type & TYPE_BAM) return bam_read1(fp->x.bam, b);
+	else return sam_read1(fp->x.tamr, fp->header, b);
+}
+
+int samwrite(samfile_t *fp, const bam1_t *b)
+{
+	if (fp == 0 || (fp->type & TYPE_READ)) return -1; // not open for writing
+	if (fp->type & TYPE_BAM) return bam_write1(fp->x.bam, b);
+	else {
+		char *s = bam_format1_core(fp->header, b, fp->type>>2&3);
+		int l = strlen(s);
+		fputs(s, fp->x.tamw); fputc('\n', fp->x.tamw);
+		free(s);
+		return l + 1;
+	}
+}
+
+int sampileup(samfile_t *fp, int mask, bam_pileup_f func, void *func_data)
+{
+	bam_plbuf_t *buf;
+	int ret;
+	bam1_t *b;
+	b = bam_init1();
+	buf = bam_plbuf_init(func, func_data);
+	bam_plbuf_set_mask(buf, mask);
+	while ((ret = samread(fp, b)) >= 0)
+		bam_plbuf_push(b, buf);
+	bam_plbuf_push(0, buf);
+	bam_plbuf_destroy(buf);
+	bam_destroy1(b);
+	return 0;
+}
+
+char *samfaipath(const char *fn_ref)
+{
+	char *fn_list = 0;
+	if (fn_ref == 0) return 0;
+	fn_list = calloc(strlen(fn_ref) + 5, 1);
+	strcat(strcpy(fn_list, fn_ref), ".fai");
+	if (access(fn_list, R_OK) == -1) { // fn_list is unreadable
+		if (access(fn_ref, R_OK) == -1) {
+			fprintf(stderr, "[samfaipath] fail to read file %s.\n", fn_ref);
+		} else {
+			fprintf(stderr, "[samfaipath] build FASTA index...\n");
+			if (fai_build(fn_ref) == -1) {
+				fprintf(stderr, "[samfaipath] fail to build FASTA index.\n");
+				free(fn_list); fn_list = 0;
+			}
+		}
+	}
+	return fn_list;
+}
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/sam.h b/ext/samtools-0.1.7a_getUnique-0.1.3/sam.h
new file mode 100644
index 0000000..0b87194
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/sam.h
@@ -0,0 +1,98 @@
+#ifndef BAM_SAM_H
+#define BAM_SAM_H
+
+#include "bam.h"
+
+/*!
+  @header
+
+  This file provides higher level of I/O routines and unifies the APIs
+  for SAM and BAM formats. These APIs are more convenient and
+  recommended.
+
+  @copyright Genome Research Ltd.
+ */
+
+/*! @typedef
+  @abstract SAM/BAM file handler
+  @field  type    type of the handler; bit 1 for BAM, 2 for reading and bit 3-4 for flag format
+  @field  bam   BAM file handler; valid if (type&1) == 1
+  @field  tamr  SAM file handler for reading; valid if type == 2
+  @field  tamw  SAM file handler for writing; valid if type == 0
+  @field  header  header struct
+ */
+typedef struct {
+	int type;
+	union {
+		tamFile tamr;
+		bamFile bam;
+		FILE *tamw;
+	} x;
+	bam_header_t *header;
+} samfile_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	/*!
+	  @abstract     Open a SAM/BAM file
+
+	  @param fn SAM/BAM file name; "-" is recognized as stdin (for
+	  reading) or stdout (for writing).
+
+	  @param mode open mode /[rw](b?)(u?)(h?)([xX]?)/: 'r' for reading,
+	  'w' for writing, 'b' for BAM I/O, 'u' for uncompressed BAM output,
+	  'h' for outputing header in SAM, 'x' for HEX flag and 'X' for
+	  string flag. If 'b' present, it must immediately follow 'r' or
+	  'w'. Valid modes are "r", "w", "wh", "wx", "whx", "wX", "whX",
+	  "rb", "wb" and "wbu" exclusively.
+
+	  @param aux auxiliary data; if mode[0]=='w', aux points to
+	  bam_header_t; if strcmp(mode, "rb")!=0 and @SQ header lines in SAM
+	  are absent, aux points the file name of the list of the reference;
+	  aux is not used otherwise. If @SQ header lines are present in SAM,
+	  aux is not used, either.
+
+	  @return       SAM/BAM file handler
+	 */
+	samfile_t *samopen(const char *fn, const char *mode, const void *aux);
+
+	/*!
+	  @abstract     Close a SAM/BAM handler
+	  @param  fp    file handler to be closed
+	 */
+	void samclose(samfile_t *fp);
+
+	/*!
+	  @abstract     Read one alignment
+	  @param  fp    file handler
+	  @param  b     alignment
+	  @return       bytes read
+	 */
+	int samread(samfile_t *fp, bam1_t *b);
+
+	/*!
+	  @abstract     Write one alignment
+	  @param  fp    file handler
+	  @param  b     alignment
+	  @return       bytes written
+	 */
+	int samwrite(samfile_t *fp, const bam1_t *b);
+
+	/*!
+	  @abstract     Get the pileup for a whole alignment file
+	  @param  fp    file handler
+	  @param  mask  mask transferred to bam_plbuf_set_mask()
+	  @param  func  user defined function called in the pileup process
+	  #param  data  user provided data for func()
+	 */
+	int sampileup(samfile_t *fp, int mask, bam_pileup_f func, void *data);
+
+	char *samfaipath(const char *fn_ref);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/sam_header.c b/ext/samtools-0.1.7a_getUnique-0.1.3/sam_header.c
new file mode 100644
index 0000000..a119c02
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/sam_header.c
@@ -0,0 +1,701 @@
+#include "sam_header.h"
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include "khash.h"
+KHASH_MAP_INIT_STR(str, const char *)
+
+struct _HeaderList
+{
+    struct _HeaderList *next;
+    void *data;
+};
+typedef struct _HeaderList list_t;
+typedef list_t HeaderDict;
+
+typedef struct
+{
+    char key[2];
+    char *value;
+}
+HeaderTag;
+
+typedef struct
+{
+    char type[2];
+    list_t *tags;
+}
+HeaderLine;
+
+const char *o_hd_tags[] = {"SO","GO",NULL};
+const char *r_hd_tags[] = {"VN",NULL};
+
+const char *o_sq_tags[] = {"AS","M5","UR","SP",NULL};
+const char *r_sq_tags[] = {"SN","LN",NULL};
+const char *u_sq_tags[] = {"SN",NULL};
+
+const char *o_rg_tags[] = {"LB","DS","PU","PI","CN","DT","PL",NULL};
+const char *r_rg_tags[] = {"ID",NULL};
+const char *u_rg_tags[] = {"ID",NULL};
+
+const char *o_pg_tags[] = {"VN","CL",NULL};
+const char *r_pg_tags[] = {"ID",NULL};
+
+const char *types[]          = {"HD","SQ","RG","PG","CO",NULL};
+const char **optional_tags[] = {o_hd_tags,o_sq_tags,o_rg_tags,o_pg_tags,NULL,NULL};
+const char **required_tags[] = {r_hd_tags,r_sq_tags,r_rg_tags,r_pg_tags,NULL,NULL};
+const char **unique_tags[]   = {NULL,     u_sq_tags,u_rg_tags,NULL,NULL,NULL};
+
+
+static void debug(const char *format, ...)
+{
+    va_list ap;
+    va_start(ap, format);
+    vfprintf(stderr, format, ap);
+    va_end(ap);
+}
+
+static list_t *list_append(list_t *root, void *data)
+{
+    list_t *l = root;
+    while (l && l->next)
+        l = l->next;
+    if ( l ) 
+    {
+        l->next = malloc(sizeof(list_t));
+        l = l->next;
+    }
+    else
+    {
+        l = malloc(sizeof(list_t));
+        root = l;
+    }
+    l->data = data;
+    l->next = NULL;
+    return root;
+}
+
+static void list_free(list_t *root)
+{
+    list_t *l = root;
+    while (root)
+    {
+        l = root;
+        root = root->next;
+        free(l);
+    }
+}
+
+
+
+// Look for a tag "XY" in a predefined const char *[] array.
+static int tag_exists(const char *tag, const char **tags)
+{
+    int itag=0;
+    if ( !tags ) return -1;
+    while ( tags[itag] )
+    {
+        if ( tags[itag][0]==tag[0] && tags[itag][1]==tag[1] ) return itag; 
+        itag++;
+    }
+    return -1;
+}
+
+
+
+// Mimics the behaviour of getline, except it returns pointer to the next chunk of the text
+//  or NULL if everything has been read. The lineptr should be freed by the caller. The
+//  newline character is stripped.
+static const char *nextline(char **lineptr, size_t *n, const char *text)
+{
+    int len;
+    const char *to = text;
+
+    if ( !*to ) return NULL;
+
+    while ( *to && *to!='\n' && *to!='\r' ) to++;
+    len = to - text + 1;
+
+    if ( *to )
+    {
+        // Advance the pointer for the next call
+        if ( *to=='\n' ) to++;
+        else if ( *to=='\r' && *(to+1)=='\n' ) to+=2;
+    }
+    if ( !len )
+        return to;
+
+    if ( !*lineptr ) 
+    {
+        *lineptr = malloc(len);
+        *n = len;
+    }
+    else if ( *n<len ) 
+    {
+        *lineptr = realloc(*lineptr, len);
+        *n = len;
+    }
+    if ( !*lineptr ) {
+		debug("[nextline] Insufficient memory!\n");
+		return 0;
+	}
+
+    memcpy(*lineptr,text,len);
+    (*lineptr)[len-1] = 0;
+
+    return to;
+}
+
+// name points to "XY", value_from points to the first character of the value string and
+//  value_to points to the last character of the value string.
+static HeaderTag *new_tag(const char *name, const char *value_from, const char *value_to)
+{
+    HeaderTag *tag = malloc(sizeof(HeaderTag));
+    int len = value_to-value_from+1;
+
+    tag->key[0] = name[0];
+    tag->key[1] = name[1];
+    tag->value = malloc(len+1);
+    memcpy(tag->value,value_from,len+1);
+    tag->value[len] = 0;
+    return tag;
+}
+
+static HeaderTag *header_line_has_tag(HeaderLine *hline, const char *key)
+{
+    list_t *tags = hline->tags;
+    while (tags)
+    {
+        HeaderTag *tag = tags->data;
+        if ( tag->key[0]==key[0] && tag->key[1]==key[1] ) return tag;
+        tags = tags->next;
+    }
+    return NULL;
+}
+
+
+// Return codes:
+//   0 .. different types or unique tags differ or conflicting tags, cannot be merged
+//   1 .. all tags identical -> no need to merge, drop one
+//   2 .. the unique tags match and there are some conflicting tags (same tag, different value) -> error, cannot be merged nor duplicated
+//   3 .. there are some missing complementary tags and no unique conflict -> can be merged into a single line
+static int sam_header_compare_lines(HeaderLine *hline1, HeaderLine *hline2)
+{
+    HeaderTag *t1, *t2;
+
+    if ( hline1->type[0]!=hline2->type[0] || hline1->type[1]!=hline2->type[1] )
+        return 0;
+
+    int itype = tag_exists(hline1->type,types);
+    if ( itype==-1 ) {
+		debug("[sam_header_compare_lines] Unknown type [%c%c]\n", hline1->type[0],hline1->type[1]);
+		return -1; // FIXME (lh3): error; I do not know how this will be handled in Petr's code
+	}
+
+    if ( unique_tags[itype] )
+    {
+        t1 = header_line_has_tag(hline1,unique_tags[itype][0]);
+        t2 = header_line_has_tag(hline2,unique_tags[itype][0]);
+        if ( !t1 || !t2 ) // this should never happen, the unique tags are required
+            return 2;
+
+        if ( strcmp(t1->value,t2->value) )
+            return 0;   // the unique tags differ, cannot be merged
+    }
+    if ( !required_tags[itype] && !optional_tags[itype] )
+    {
+        t1 = hline1->tags->data;
+        t2 = hline2->tags->data;
+        if ( !strcmp(t1->value,t2->value) ) return 1; // identical comments
+        return 0;
+    }
+
+    int missing=0, itag=0;
+    while ( required_tags[itype] && required_tags[itype][itag] )
+    {
+        t1 = header_line_has_tag(hline1,required_tags[itype][itag]);
+        t2 = header_line_has_tag(hline2,required_tags[itype][itag]);
+        if ( !t1 && !t2 )
+            return 2;       // this should never happen
+        else if ( !t1 || !t2 )
+            missing = 1;    // there is some tag missing in one of the hlines
+        else if ( strcmp(t1->value,t2->value) )
+        {
+            if ( unique_tags[itype] )
+                return 2;   // the lines have a matching unique tag but have a conflicting tag
+                    
+            return 0;    // the lines contain conflicting tags, cannot be merged
+        }
+        itag++;
+    }
+    itag = 0;
+    while ( optional_tags[itype] && optional_tags[itype][itag] )
+    {
+        t1 = header_line_has_tag(hline1,optional_tags[itype][itag]);
+        t2 = header_line_has_tag(hline2,optional_tags[itype][itag]);
+        if ( !t1 && !t2 )
+        {
+            itag++;
+            continue;
+        }
+        if ( !t1 || !t2 )
+            missing = 1;    // there is some tag missing in one of the hlines
+        else if ( strcmp(t1->value,t2->value) )
+        {
+            if ( unique_tags[itype] )
+                return 2;   // the lines have a matching unique tag but have a conflicting tag
+
+            return 0;   // the lines contain conflicting tags, cannot be merged
+        }
+        itag++;
+    }
+    if ( missing ) return 3;    // there are some missing complementary tags with no conflicts, can be merged
+    return 1;
+}
+
+
+static HeaderLine *sam_header_line_clone(const HeaderLine *hline)
+{
+    list_t *tags;
+    HeaderLine *out = malloc(sizeof(HeaderLine));
+    out->type[0] = hline->type[0];
+    out->type[1] = hline->type[1];
+    out->tags = NULL;
+
+    tags = hline->tags;
+    while (tags)
+    {
+        HeaderTag *old = tags->data;
+
+        HeaderTag *new = malloc(sizeof(HeaderTag));
+        new->key[0] = old->key[0];
+        new->key[1] = old->key[1];
+        new->value  = strdup(old->value);
+        out->tags = list_append(out->tags, new);
+
+        tags = tags->next;
+    }
+    return out;
+}
+
+static int sam_header_line_merge_with(HeaderLine *out_hline, const HeaderLine *tmpl_hline)
+{
+    list_t *tmpl_tags;
+
+    if ( out_hline->type[0]!=tmpl_hline->type[0] || out_hline->type[1]!=tmpl_hline->type[1] )
+        return 0;
+    
+    tmpl_tags = tmpl_hline->tags;
+    while (tmpl_tags)
+    {
+        HeaderTag *tmpl_tag = tmpl_tags->data;
+        HeaderTag *out_tag  = header_line_has_tag(out_hline, tmpl_tag->key);
+        if ( !out_tag )
+        {
+            HeaderTag *tag = malloc(sizeof(HeaderTag));
+            tag->key[0] = tmpl_tag->key[0];
+            tag->key[1] = tmpl_tag->key[1];
+            tag->value  = strdup(tmpl_tag->value);
+            out_hline->tags = list_append(out_hline->tags,tag);
+        }
+        tmpl_tags = tmpl_tags->next;
+    }
+    return 1;
+}
+
+
+static HeaderLine *sam_header_line_parse(const char *headerLine)
+{
+    HeaderLine *hline;
+    HeaderTag *tag;
+    const char *from, *to;
+    from = headerLine;
+
+    if ( *from != '@' ) {
+		debug("[sam_header_line_parse] expected '@', got [%s]\n", headerLine);
+		return 0;
+	}
+    to = ++from;
+
+    while (*to && *to!='\t') to++;
+    if ( to-from != 2 ) {
+		debug("[sam_header_line_parse] expected '@XY', got [%s]\n", headerLine);
+		return 0;
+	}
+    
+    hline = malloc(sizeof(HeaderLine));
+    hline->type[0] = from[0];
+    hline->type[1] = from[1];
+    hline->tags = NULL;
+
+    int itype = tag_exists(hline->type, types);
+    
+    from = to;
+    while (*to && *to=='\t') to++;
+    if ( to-from != 1 ) {
+        debug("[sam_header_line_parse] multiple tabs on line [%s] (%d)\n", headerLine,(int)(to-from));
+		return 0;
+	}
+    from = to;
+    while (*from)
+    {
+        while (*to && *to!='\t') to++;
+
+        if ( !required_tags[itype] && !optional_tags[itype] )
+            tag = new_tag("  ",from,to-1);
+        else
+            tag = new_tag(from,from+3,to-1);
+
+        if ( header_line_has_tag(hline,tag->key) ) 
+                debug("The tag '%c%c' present (at least) twice on line [%s]\n", tag->key[0],tag->key[1], headerLine);
+        hline->tags = list_append(hline->tags, tag);
+
+        from = to;
+        while (*to && *to=='\t') to++;
+        if ( *to && to-from != 1 ) {
+			debug("[sam_header_line_parse] multiple tabs on line [%s] (%d)\n", headerLine,(int)(to-from));
+			return 0;
+		}
+
+        from = to;
+    }
+    return hline;
+}
+
+
+// Must be of an existing type, all tags must be recognised and all required tags must be present
+static int sam_header_line_validate(HeaderLine *hline)
+{
+    list_t *tags;
+    HeaderTag *tag;
+    int itype, itag;
+    
+    // Is the type correct?
+    itype = tag_exists(hline->type, types);
+    if ( itype==-1 ) 
+    {
+        debug("The type [%c%c] not recognised.\n", hline->type[0],hline->type[1]);
+        return 0;
+    }
+
+    // Has all required tags?
+    itag = 0;
+    while ( required_tags[itype] && required_tags[itype][itag] )
+    {
+        if ( !header_line_has_tag(hline,required_tags[itype][itag]) )
+        {
+            debug("The tag [%c%c] required for [%c%c] not present.\n", required_tags[itype][itag][0],required_tags[itype][itag][1],
+                hline->type[0],hline->type[1]);
+            return 0;
+        }
+        itag++;
+    }
+
+    // Are all tags recognised?
+    tags = hline->tags;
+    while ( tags )
+    {
+        tag = tags->data;
+        if ( !tag_exists(tag->key,required_tags[itype]) && !tag_exists(tag->key,optional_tags[itype]) )
+        {
+            debug("Unknown tag [%c%c] for [%c%c].\n", tag->key[0],tag->key[1], hline->type[0],hline->type[1]);
+            return 0;
+        }
+        tags = tags->next;
+    }
+
+    return 1;
+}
+
+
+static void print_header_line(FILE *fp, HeaderLine *hline)
+{
+    list_t *tags = hline->tags;
+    HeaderTag *tag;
+
+    fprintf(fp, "@%c%c", hline->type[0],hline->type[1]);
+    while (tags)
+    {
+        tag = tags->data;
+
+        fprintf(fp, "\t");
+        if ( tag->key[0]!=' ' || tag->key[1]!=' ' )
+            fprintf(fp, "%c%c:", tag->key[0],tag->key[1]);
+        fprintf(fp, "%s", tag->value);
+
+        tags = tags->next;
+    }
+    fprintf(fp,"\n");
+}
+
+
+static void sam_header_line_free(HeaderLine *hline)
+{
+    list_t *tags = hline->tags;
+    while (tags)
+    {
+        HeaderTag *tag = tags->data;
+        free(tag->value);
+        free(tag);
+        tags = tags->next;
+    }
+    list_free(hline->tags);
+    free(hline);
+}
+
+void sam_header_free(void *_header)
+{
+	HeaderDict *header = (HeaderDict*)_header;
+    list_t *hlines = header;
+    while (hlines)
+    {
+        sam_header_line_free(hlines->data);
+        hlines = hlines->next;
+    }
+    list_free(header);
+}
+
+HeaderDict *sam_header_clone(const HeaderDict *dict)
+{
+    HeaderDict *out = NULL;
+    while (dict)
+    {
+        HeaderLine *hline = dict->data;
+        out = list_append(out, sam_header_line_clone(hline));
+        dict = dict->next;
+    }
+    return out;
+}
+
+// Returns a newly allocated string
+char *sam_header_write(const void *_header)
+{
+	const HeaderDict *header = (const HeaderDict*)_header;
+    char *out = NULL;
+    int len=0, nout=0;
+    const list_t *hlines;
+
+    // Calculate the length of the string to allocate
+    hlines = header;
+    while (hlines)
+    {
+        len += 4;   // @XY and \n
+
+        HeaderLine *hline = hlines->data;
+        list_t *tags = hline->tags;
+        while (tags)
+        {
+            HeaderTag *tag = tags->data;
+            len += strlen(tag->value) + 1;                  // \t
+            if ( tag->key[0]!=' ' || tag->key[1]!=' ' )
+                len += strlen(tag->value) + 3;              // XY:
+            tags = tags->next;
+        }
+        hlines = hlines->next;
+    }
+
+    nout = 0;
+    out  = malloc(len+1);
+    hlines = header;
+    while (hlines)
+    {
+        HeaderLine *hline = hlines->data;
+
+        nout += sprintf(out+nout,"@%c%c",hline->type[0],hline->type[1]);
+
+        list_t *tags = hline->tags;
+        while (tags)
+        {
+            HeaderTag *tag = tags->data;
+            nout += sprintf(out+nout,"\t");
+            if ( tag->key[0]!=' ' || tag->key[1]!=' ' )
+                nout += sprintf(out+nout,"%c%c:", tag->key[0],tag->key[1]);
+            nout += sprintf(out+nout,"%s", tag->value);
+            tags = tags->next;
+        }
+        hlines = hlines->next;
+        nout += sprintf(out+nout,"\n");
+    }
+    out[len] = 0;
+    return out;
+}
+
+void *sam_header_parse2(const char *headerText)
+{
+    list_t *hlines = NULL;
+    HeaderLine *hline;
+    const char *text;
+    char *buf=NULL;
+    size_t nbuf = 0;
+
+    if ( !headerText )
+		return 0;
+
+    text = headerText;
+    while ( (text=nextline(&buf, &nbuf, text)) )
+    {
+        hline = sam_header_line_parse(buf);
+        if ( hline && sam_header_line_validate(hline) )
+            hlines = list_append(hlines, hline);
+        else
+        {
+			if (hline) sam_header_line_free(hline);
+			sam_header_free(hlines);
+            if ( buf ) free(buf);
+            return NULL;
+        }
+    }
+    if ( buf ) free(buf);
+
+    return hlines;
+}
+
+void *sam_header2tbl(const void *_dict, char type[2], char key_tag[2], char value_tag[2])
+{
+	const HeaderDict *dict = (const HeaderDict*)_dict;
+    const list_t *l   = dict;
+    khash_t(str) *tbl = kh_init(str);
+    khiter_t k;
+    int ret;
+
+	if (_dict == 0) return tbl; // return an empty (not null) hash table
+    while (l)
+    {
+        HeaderLine *hline = l->data;
+        if ( hline->type[0]!=type[0] || hline->type[1]!=type[1] ) 
+        {
+            l = l->next;
+            continue;
+        }
+        
+        HeaderTag *key, *value;
+        key   = header_line_has_tag(hline,key_tag);
+        value = header_line_has_tag(hline,value_tag); 
+        if ( !key || !value )
+        {
+            l = l->next;
+            continue;
+        }
+        
+        k = kh_get(str, tbl, key->value);
+        if ( k != kh_end(tbl) )
+            debug("[sam_header_lookup_table] They key %s not unique.\n", key->value);
+        k = kh_put(str, tbl, key->value, &ret);
+        kh_value(tbl, k) = value->value;
+
+        l = l->next;
+    }
+    return tbl;
+}
+
+char **sam_header2list(const void *_dict, char type[2], char key_tag[2], int *_n)
+{
+	const HeaderDict *dict = (const HeaderDict*)_dict;
+    const list_t *l   = dict;
+    int max, n;
+	char **ret;
+
+	ret = 0; *_n = max = n = 0;
+    while (l)
+    {
+        HeaderLine *hline = l->data;
+        if ( hline->type[0]!=type[0] || hline->type[1]!=type[1] ) 
+        {
+            l = l->next;
+            continue;
+        }
+        
+        HeaderTag *key;
+        key   = header_line_has_tag(hline,key_tag);
+        if ( !key )
+        {
+            l = l->next;
+            continue;
+        }
+
+		if (n == max) {
+			max = max? max<<1 : 4;
+			ret = realloc(ret, max * sizeof(void*));
+		}
+		ret[n++] = key->value;
+
+        l = l->next;
+    }
+	*_n = n;
+    return ret;
+}
+
+const char *sam_tbl_get(void *h, const char *key)
+{
+	khash_t(str) *tbl = (khash_t(str)*)h;
+	khint_t k;
+	k = kh_get(str, tbl, key);
+	return k == kh_end(tbl)? 0 : kh_val(tbl, k);
+}
+
+int sam_tbl_size(void *h)
+{
+	khash_t(str) *tbl = (khash_t(str)*)h;
+	return h? kh_size(tbl) : 0;
+}
+
+void sam_tbl_destroy(void *h)
+{
+	khash_t(str) *tbl = (khash_t(str)*)h;
+	kh_destroy(str, tbl);
+}
+
+void *sam_header_merge(int n, const void **_dicts)
+{
+	const HeaderDict **dicts = (const HeaderDict**)_dicts;
+    HeaderDict *out_dict;
+    int idict, status;
+
+    if ( n<2 ) return NULL;
+
+    out_dict = sam_header_clone(dicts[0]);
+
+    for (idict=1; idict<n; idict++)
+    {
+        const list_t *tmpl_hlines = dicts[idict];
+
+        while ( tmpl_hlines )
+        {
+            list_t *out_hlines = out_dict;
+            int inserted = 0;
+            while ( out_hlines )
+            {
+                status = sam_header_compare_lines(tmpl_hlines->data, out_hlines->data);
+                if ( status==0 )
+                {
+                    out_hlines = out_hlines->next;
+                    continue;
+                }
+                
+                if ( status==2 ) 
+                {
+                    print_header_line(stderr,tmpl_hlines->data);
+                    print_header_line(stderr,out_hlines->data);
+                    debug("Conflicting lines, cannot merge the headers.\n");
+					return 0;
+                }
+                if ( status==3 )
+                    sam_header_line_merge_with(out_hlines->data, tmpl_hlines->data);
+
+                inserted = 1;
+                break;
+            }
+            if ( !inserted )
+                out_dict = list_append(out_dict, sam_header_line_clone(tmpl_hlines->data));
+
+            tmpl_hlines = tmpl_hlines->next;
+        }
+    }
+
+    return out_dict;
+}
+
+
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/sam_header.h b/ext/samtools-0.1.7a_getUnique-0.1.3/sam_header.h
new file mode 100644
index 0000000..e5c754f
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/sam_header.h
@@ -0,0 +1,24 @@
+#ifndef __SAM_HEADER_H__
+#define __SAM_HEADER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	void *sam_header_parse2(const char *headerText);
+	void *sam_header_merge(int n, const void **dicts);
+	void sam_header_free(void *header);
+	char *sam_header_write(const void *headerDict);   // returns a newly allocated string
+
+	char **sam_header2list(const void *_dict, char type[2], char key_tag[2], int *_n);
+
+	void *sam_header2tbl(const void *dict, char type[2], char key_tag[2], char value_tag[2]);
+	const char *sam_tbl_get(void *h, const char *key);
+	int sam_tbl_size(void *h);
+	void sam_tbl_destroy(void *h);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/sam_view.c b/ext/samtools-0.1.7a_getUnique-0.1.3/sam_view.c
new file mode 100644
index 0000000..4414a83
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/sam_view.c
@@ -0,0 +1,253 @@
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+#include "sam_header.h"
+#include "sam.h"
+#include "faidx.h"
+#include "getUniqueRead/getUniqueRead.h"
+
+static int g_min_mapQ = 0, g_flag_on = 0, g_flag_off = 0;
+static char *g_library, *g_rg;
+static int g_sol2sanger_tbl[128];
+
+static void sol2sanger(bam1_t *b)
+{
+	int l;
+	uint8_t *qual = bam1_qual(b);
+	if (g_sol2sanger_tbl[30] == 0) {
+		for (l = 0; l != 128; ++l) {
+			g_sol2sanger_tbl[l] = (int)(10.0 * log(1.0 + pow(10.0, (l - 64 + 33) / 10.0)) / log(10.0) + .499);
+			if (g_sol2sanger_tbl[l] >= 93) g_sol2sanger_tbl[l] = 93;
+		}
+	}
+	for (l = 0; l < b->core.l_qseq; ++l) {
+		int q = qual[l];
+		if (q > 127) q = 127;
+		qual[l] = g_sol2sanger_tbl[q];
+	}
+}
+
+static inline int __g_skip_aln(const bam_header_t *h, const bam1_t *b)
+{
+	if (b->core.qual < g_min_mapQ || ((b->core.flag & g_flag_on) != g_flag_on) || (b->core.flag & g_flag_off))
+		return 1;
+	if (g_rg) {
+		uint8_t *s = bam_aux_get(b, "RG");
+		return (s && strcmp(g_rg, (char*)(s + 1)) == 0) ? 0:1;
+	}
+	if (g_library) {
+		const char *p = bam_get_library((bam_header_t*)h, b);
+		return (p && strcmp(p, g_library) == 0)? 0 : 1;
+	}
+	return 0;
+}
+
+// callback function for bam_fetch()
+static int view_func(const bam1_t *b, void *data)
+{
+	if (!__g_skip_aln(((samfile_t*)data)->header, b))
+		samwrite((samfile_t*)data, b);
+	return 0;
+}
+
+static int usage(int is_long_help);
+
+
+
+int main_samview(int argc, char *argv[])
+{
+	int c, is_header = 0, is_header_only = 0, is_bamin = 1, ret = 0, is_uncompressed = 0, is_bamout = 0, slx2sngr = 0;
+	int of_type = BAM_OFDEC, is_long_help = 0;
+	samfile_t *in = 0, *out = 0;
+	char in_mode[5], out_mode[5], *fn_out = 0, *fn_list = 0, *fn_ref = 0;
+
+	char *args_unique=NULL; /*argument for getting unqiue reads*/
+	int ReadLengthSummary = 0;
+
+
+	/* parse command-line options */
+	strcpy(in_mode, "r"); strcpy(out_mode, "w");
+	while ((c = getopt(argc, argv, "i:ed:Sbt:hHo:q:f:F:ul:r:xX?T:CU:R")) >= 0) {
+		switch (c) {
+		case 'U': args_unique = strdup(optarg); get_Unique_args(args_unique); break;
+		case 'R': ReadLengthSummary = 1; break;
+		case 'C': slx2sngr = 1; break;
+		case 'S': is_bamin = 0; break;
+		case 'b': is_bamout = 1; break;
+		case 't': fn_list = strdup(optarg); is_bamin = 0; break;
+		case 'h': is_header = 1; break;
+		case 'H': is_header_only = 1; break;
+		case 'o': fn_out = strdup(optarg); break;
+		case 'f': g_flag_on = strtol(optarg, 0, 0); break;
+		case 'F': g_flag_off = strtol(optarg, 0, 0); break;
+		case 'q': g_min_mapQ = atoi(optarg); break;
+		case 'u': is_uncompressed = 1; break;
+		case 'l': g_library = strdup(optarg); break;
+		case 'r': g_rg = strdup(optarg); break;
+		case 'x': of_type = BAM_OFHEX; break;
+		case 'X': of_type = BAM_OFSTR; break;
+		case '?': is_long_help = 1; break;
+		case 'T': fn_ref = strdup(optarg); is_bamin = 0; break;
+		default: return usage(is_long_help);
+		}
+	}
+
+	if (is_uncompressed) is_bamout = 1;
+	if (is_header_only) is_header = 1;
+	if (is_bamout) strcat(out_mode, "b");
+	else {
+		if (of_type == BAM_OFHEX) strcat(out_mode, "x");
+		else if (of_type == BAM_OFSTR) strcat(out_mode, "X");
+	}
+	if (is_bamin) strcat(in_mode, "b");
+	if (is_header) strcat(out_mode, "h");
+	if (is_uncompressed) strcat(out_mode, "u");
+	if (argc == optind) return usage(is_long_help);
+
+
+	// generate the fn_list if necessary
+	if (fn_list == 0 && fn_ref) fn_list = samfaipath(fn_ref);
+	// open file handlers
+	if ((in = samopen(argv[optind], in_mode, fn_list)) == 0) {
+		fprintf(stderr, "[main_samview] fail to open file for reading.\n");
+		goto view_end;
+	}
+	if (in->header == 0) {
+		fprintf(stderr, "[main_samview] fail to read the header.\n");
+		goto view_end;
+	}
+	if ((out = samopen(fn_out? fn_out : "-", out_mode, in->header)) == 0) {
+		fprintf(stderr, "[main_samview] fail to open file for writing.\n");
+		goto view_end;
+	}
+	if (is_header_only) goto view_end; // no need to print alignments
+
+	if(args_unique!=NULL)report_unique_read(in->header,NULL);
+
+	if (argc == optind + 1) { // convert/print the entire file
+		bam1_t *b = bam_init1();
+		int r;
+		while ((r = samread(in, b)) >= 0) { // read one alignment from `in'
+			if (!__g_skip_aln(in->header, b)) {
+				if (slx2sngr) sol2sanger(b);
+				if(args_unique==NULL && ReadLengthSummary!=1) samwrite(out, b); // write the alignment to `out'
+				else if(args_unique!=NULL) {report_unique_read(in->header,b);}
+				else if(ReadLengthSummary==1) {summarizeReadLength(b);}
+				//samwrite(out, b);
+			}
+		}
+
+		if (r < -1) fprintf(stderr, "[main_samview] truncated file.\n");
+		bam_destroy1(b);
+		if(args_unique!=NULL){report_unique_read(NULL,NULL);}
+		if(ReadLengthSummary==1) {reportReadLength(stdout);}
+	} else { // retrieve alignments in specified regions
+		int i;
+		bam_index_t *idx = 0;
+		if (is_bamin) idx = bam_index_load(argv[optind]); // load BAM index
+		if (idx == 0) { // index is unavailable
+			fprintf(stderr, "[main_samview] random alignment retrieval only works for indexed BAM files.\n");
+			ret = 1;
+			goto view_end;
+		}
+		for (i = optind + 1; i < argc; ++i) {
+			int tid, beg, end;
+			bam_parse_region(in->header, argv[i], &tid, &beg, &end); // parse a region in the format like `chr2:100-200'
+			if (tid < 0) { // reference name is not found
+				fprintf(stderr, "[main_samview] fail to get the reference name. Continue anyway.\n");
+				continue;
+			}
+			bam_fetch(in->x.bam, idx, tid, beg, end, out, view_func); // fetch alignments
+		}
+		bam_index_destroy(idx); // destroy the BAM index
+
+
+	}
+
+view_end:
+	// close files, free and return
+	free(fn_list); free(fn_ref); free(fn_out); free(g_library); free(g_rg);
+	samclose(in);
+	samclose(out);
+	return ret;
+}
+
+static int usage(int is_long_help)
+{
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Usage:   samtools view [options] <in.bam>|<in.sam> [region1 [...]]\n\n");
+	fprintf(stderr, "Options: -b       output BAM\n");
+	fprintf(stderr, "         -U STR   If specified, get the uique reads. STR should be <Aligner,OutputPrefix,ChromNameReport?,StrandReport?> or <Aligner,OutputPrefix,ChromNameReport?,StrandReport?minLen,maxLen>\n");
+	fprintf(stderr,"                   e.g. <BWA,output,N,N> means that the aligner is BWA, the prefix of the output is output, and that the chromosome names and strands will not be reported\n");
+	fprintf(stderr,"                   StrandReport should be S (separate positive and negative reads), Y, or N\n");
+	fprintf(stderr,"                   minLen and maxLen specifies the length range of the reported reads\n");
+	fprintf(stderr, "         -R       Report the read length summary\n");
+	fprintf(stderr, "         -h       print header for the SAM output\n");
+	fprintf(stderr, "         -H       print header only (no alignments)\n");
+	fprintf(stderr, "         -S       input is SAM\n");
+	fprintf(stderr, "         -u       uncompressed BAM output (force -b)\n");
+	fprintf(stderr, "         -x       output FLAG in HEX (samtools-C specific)\n");
+	fprintf(stderr, "         -X       output FLAG in string (samtools-C specific)\n");
+	fprintf(stderr, "         -t FILE  list of reference names and lengths (force -S) [null]\n");
+	fprintf(stderr, "         -T FILE  reference sequence file (force -S) [null]\n");
+	fprintf(stderr, "         -o FILE  output file name [stdout]\n");
+	fprintf(stderr, "         -f INT   required flag, 0 for unset [0]\n");
+	fprintf(stderr, "         -F INT   filtering flag, 0 for unset [0]\n");
+	fprintf(stderr, "         -q INT   minimum mapping quality [0]\n");
+	fprintf(stderr, "         -l STR   only output reads in library STR [null]\n");
+	fprintf(stderr, "         -r STR   only output reads in read group STR [null]\n");
+	fprintf(stderr, "         -?       longer help\n");
+	fprintf(stderr, "\n");
+	if (is_long_help)
+		fprintf(stderr, "Notes:\n\
+\n\
+  1. By default, this command assumes the file on the command line is in\n\
+     the BAM format and it prints the alignments in SAM. If `-t' is\n\
+     applied, the input file is assumed to be in the SAM format. The\n\
+     file supplied with `-t' is SPACE/TAB delimited with the first two\n\
+     fields of each line consisting of the reference name and the\n\
+     corresponding sequence length. The `.fai' file generated by `faidx'\n\
+     can be used here. This file may be empty if reads are unaligned.\n\
+\n\
+  2. SAM->BAM conversion: `samtools view -bT ref.fa in.sam.gz'.\n\
+\n\
+  3. BAM->SAM conversion: `samtools view in.bam'.\n\
+\n\
+  4. A region should be presented in one of the following formats:\n\
+     `chr1', `chr2:1,000' and `chr3:1000-2,000'. When a region is\n\
+     specified, the input alignment file must be an indexed BAM file.\n\
+\n\
+  5. Option `-u' is preferred over `-b' when the output is piped to\n\
+     another samtools command.\n\
+\n\
+  6. In a string FLAG, each character represents one bit with\n\
+     p=0x1 (paired), P=0x2 (properly paired), u=0x4 (unmapped),\n\
+     U=0x8 (mate unmapped), r=0x10 (reverse), R=0x20 (mate reverse)\n\
+     1=0x40 (first), 2=0x80 (second), s=0x100 (not primary), \n\
+     f=0x200 (failure) and d=0x400 (duplicate). Note that `-x' and\n\
+     `-X' are samtools-C specific. Picard and older samtools do not\n\
+     support HEX or string flags.\n\
+\n");
+	return 1;
+}
+
+
+
+
+int main_import(int argc, char *argv[])
+{
+	int argc2, ret;
+	char **argv2;
+	if (argc != 4) {
+		fprintf(stderr, "Usage: bamtk import <in.ref_list> <in.sam> <out.bam>\n");
+		return 1;
+	}
+	argc2 = 6;
+	argv2 = calloc(6, sizeof(char*));
+	argv2[0] = "import", argv2[1] = "-o", argv2[2] = argv[3], argv2[3] = "-bt", argv2[4] = argv[1], argv2[5] = argv[2];
+	ret = main_samview(argc2, argv2);
+	free(argv2);
+	return ret;
+} 
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/samtools b/ext/samtools-0.1.7a_getUnique-0.1.3/samtools
new file mode 100755
index 0000000..b06fcb2
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/samtools differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/samtools.1 b/ext/samtools-0.1.7a_getUnique-0.1.3/samtools.1
new file mode 100644
index 0000000..31375f3
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/samtools.1
@@ -0,0 +1,442 @@
+.TH samtools 1 "10 November 2009" "samtools-0.1.7" "Bioinformatics tools"
+.SH NAME
+.PP
+samtools - Utilities for the Sequence Alignment/Map (SAM) format
+.SH SYNOPSIS
+.PP
+samtools view -bt ref_list.txt -o aln.bam aln.sam.gz
+.PP
+samtools sort aln.bam aln.sorted
+.PP
+samtools index aln.sorted.bam
+.PP
+samtools view aln.sorted.bam chr2:20,100,000-20,200,000
+.PP
+samtools merge out.bam in1.bam in2.bam in3.bam
+.PP
+samtools faidx ref.fasta
+.PP
+samtools pileup -f ref.fasta aln.sorted.bam
+.PP
+samtools tview aln.sorted.bam ref.fasta
+
+.SH DESCRIPTION
+.PP
+Samtools is a set of utilities that manipulate alignments in the BAM
+format. It imports from and exports to the SAM (Sequence Alignment/Map)
+format, does sorting, merging and indexing, and allows to retrieve reads
+in any regions swiftly.
+
+Samtools is designed to work on a stream. It regards an input file `-'
+as the standard input (stdin) and an output file `-' as the standard
+output (stdout). Several commands can thus be combined with Unix
+pipes. Samtools always output warning and error messages to the standard
+error output (stderr).
+
+Samtools is also able to open a BAM (not SAM) file on a remote FTP or
+HTTP server if the BAM file name starts with `ftp://' or `http://'.
+Samtools checks the current working directory for the index file and
+will download the index upon absence. Samtools does not retrieve the
+entire alignment file unless it is asked to do so.
+
+.SH COMMANDS AND OPTIONS
+
+.TP 10
+.B import
+samtools import <in.ref_list> <in.sam> <out.bam>
+
+Since 0.1.4, this command is an alias of:
+
+samtools view -bt <in.ref_list> -o <out.bam> <in.sam>
+
+.TP
+.B sort
+samtools sort [-n] [-m maxMem] <in.bam> <out.prefix>
+
+Sort alignments by leftmost coordinates. File
+.I <out.prefix>.bam
+will be created. This command may also create temporary files
+.I <out.prefix>.%d.bam
+when the whole alignment cannot be fitted into memory (controlled by
+option -m).
+
+.B OPTIONS:
+.RS
+.TP 8
+.B -n
+Sort by read names rather than by chromosomal coordinates
+.TP
+.B -m INT
+Approximately the maximum required memory. [500000000]
+.RE
+
+.TP
+.B merge
+samtools merge [-h inh.sam] [-n] <out.bam> <in1.bam> <in2.bam> [...]
+
+Merge multiple sorted alignments.
+The header reference lists of all the input BAM files, and the @SQ headers of
+.IR inh.sam ,
+if any, must all refer to the same set of reference sequences.
+The header reference list and (unless overridden by
+.BR -h )
+`@' headers of
+.I in1.bam
+will be copied to
+.IR out.bam ,
+and the headers of other files will be ignored.
+
+.B OPTIONS:
+.RS
+.TP 8
+.B -h FILE
+Use the lines of
+.I FILE
+as `@' headers to be copied to
+.IR out.bam ,
+replacing any header lines that would otherwise be copied from
+.IR in1.bam .
+.RI ( FILE
+is actually in SAM format, though any alignment records it may contain
+are ignored.)
+.TP
+.B -n
+The input alignments are sorted by read names rather than by chromosomal
+coordinates
+.RE
+
+.TP
+.B index
+samtools index <aln.bam>
+
+Index sorted alignment for fast random access. Index file
+.I <aln.bam>.bai
+will be created.
+
+.TP
+.B view
+samtools view [-bhuHS] [-t in.refList] [-o output] [-f reqFlag] [-F
+skipFlag] [-q minMapQ] [-l library] [-r readGroup] <in.bam>|<in.sam> [region1 [...]]
+
+Extract/print all or sub alignments in SAM or BAM format. If no region
+is specified, all the alignments will be printed; otherwise only
+alignments overlapping the specified regions will be output. An
+alignment may be given multiple times if it is overlapping several
+regions. A region can be presented, for example, in the following
+format: `chr2' (the whole chr2), `chr2:1000000' (region starting from
+1,000,000bp) or `chr2:1,000,000-2,000,000' (region between 1,000,000 and
+2,000,000bp including the end points). The coordinate is 1-based.
+
+.B OPTIONS:
+.RS
+.TP 8
+.B -b
+Output in the BAM format.
+.TP
+.B -u
+Output uncompressed BAM. This option saves time spent on
+compression/decomprssion and is thus preferred when the output is piped
+to another samtools command.
+.TP
+.B -h
+Include the header in the output.
+.TP
+.B -H
+Output the header only.
+.TP
+.B -S
+Input is in SAM. If @SQ header lines are absent, the
+.B `-t'
+option is required.
+.TP
+.B -t FILE
+This file is TAB-delimited. Each line must contain the reference name
+and the length of the reference, one line for each distinct reference;
+additional fields are ignored. This file also defines the order of the
+reference sequences in sorting. If you run `samtools faidx <ref.fa>',
+the resultant index file
+.I <ref.fa>.fai
+can be used as this
+.I <in.ref_list>
+file.
+.TP
+.B -o FILE
+Output file [stdout]
+.TP
+.B -f INT
+Only output alignments with all bits in INT present in the FLAG
+field. INT can be in hex in the format of /^0x[0-9A-F]+/ [0]
+.TP
+.B -F INT
+Skip alignments with bits present in INT [0]
+.TP
+.B -q INT
+Skip alignments with MAPQ smaller than INT [0]
+.TP
+.B -l STR
+Only output reads in library STR [null]
+.TP
+.B -r STR
+Only output reads in read group STR [null]
+.RE
+
+.TP
+.B faidx
+samtools faidx <ref.fasta> [region1 [...]]
+
+Index reference sequence in the FASTA format or extract subsequence from
+indexed reference sequence. If no region is specified,
+.B faidx
+will index the file and create
+.I <ref.fasta>.fai
+on the disk. If regions are speficified, the subsequences will be
+retrieved and printed to stdout in the FASTA format. The input file can
+be compressed in the
+.B RAZF
+format.
+
+.TP
+.B pileup
+samtools pileup [-f in.ref.fasta] [-t in.ref_list] [-l in.site_list]
+[-iscgS2] [-T theta] [-N nHap] [-r pairDiffRate] <in.bam>|<in.sam>
+
+Print the alignment in the pileup format. In the pileup format, each
+line represents a genomic position, consisting of chromosome name,
+coordinate, reference base, read bases, read qualities and alignment
+mapping qualities. Information on match, mismatch, indel, strand,
+mapping quality and start and end of a read are all encoded at the read
+base column. At this column, a dot stands for a match to the reference
+base on the forward strand, a comma for a match on the reverse strand,
+`ACGTN' for a mismatch on the forward strand and `acgtn' for a mismatch
+on the reverse strand. A pattern `\\+[0-9]+[ACGTNacgtn]+' indicates
+there is an insertion between this reference position and the next
+reference position. The length of the insertion is given by the integer
+in the pattern, followed by the inserted sequence. Similarly, a pattern
+`-[0-9]+[ACGTNacgtn]+' represents a deletion from the reference. The
+deleted bases will be presented as `*' in the following lines. Also at
+the read base column, a symbol `^' marks the start of a read segment
+which is a contiguous subsequence on the read separated by `N/S/H' CIGAR
+operations. The ASCII of the character following `^' minus 33 gives the
+mapping quality. A symbol `$' marks the end of a read segment.
+
+If option
+.B -c
+is applied, the consensus base, Phred-scaled consensus quality, SNP
+quality (i.e. the Phred-scaled probability of the consensus being
+identical to the reference) and root mean square (RMS) mapping quality
+of the reads covering the site will be inserted between the `reference
+base' and the `read bases' columns. An indel occupies an additional
+line. Each indel line consists of chromosome name, coordinate, a star,
+the genotype, consensus quality, SNP quality, RMS mapping quality, #
+covering reads, the first alllele, the second allele, # reads supporting
+the first allele, # reads supporting the second allele and # reads
+containing indels different from the top two alleles.
+
+.B OPTIONS:
+.RS
+
+.TP 10
+.B -s
+Print the mapping quality as the last column. This option makes the
+output easier to parse, although this format is not space efficient.
+
+.TP
+.B -S
+The input file is in SAM.
+
+.TP
+.B -i
+Only output pileup lines containing indels.
+
+.TP
+.B -f FILE
+The reference sequence in the FASTA format. Index file
+.I FILE.fai
+will be created if
+absent.
+
+.TP
+.B -M INT
+Cap mapping quality at INT [60]
+
+.TP
+.B -t FILE
+List of reference names ane sequence lengths, in the format described
+for the
+.B import
+command. If this option is present, samtools assumes the input
+.I <in.alignment>
+is in SAM format; otherwise it assumes in BAM format.
+
+.TP
+.B -l FILE
+List of sites at which pileup is output. This file is space
+delimited. The first two columns are required to be chromosome and
+1-based coordinate. Additional columns are ignored. It is
+recommended to use option
+.B -s
+together with
+.B -l
+as in the default format we may not know the mapping quality.
+
+.TP
+.B -c
+Call the consensus sequence using MAQ consensus model. Options
+.B -T,
+.B -N,
+.B -I
+and
+.B -r
+are only effective when
+.B -c
+or
+.B -g
+is in use.
+
+.TP
+.B -g
+Generate genotype likelihood in the binary GLFv3 format. This option
+suppresses -c, -i and -s.
+
+.TP
+.B -T FLOAT
+The theta parameter (error dependency coefficient) in the maq consensus
+calling model [0.85]
+
+.TP
+.B -N INT
+Number of haplotypes in the sample (>=2) [2]
+
+.TP
+.B -r FLOAT
+Expected fraction of differences between a pair of haplotypes [0.001]
+
+.TP
+.B -I INT
+Phred probability of an indel in sequencing/prep. [40]
+
+.RE
+
+.TP
+.B tview
+samtools tview <in.sorted.bam> [ref.fasta]
+
+Text alignment viewer (based on the ncurses library). In the viewer,
+press `?' for help and press `g' to check the alignment start from a
+region in the format like `chr10:10,000,000'.
+
+.TP
+.B fixmate
+samtools fixmate <in.nameSrt.bam> <out.bam>
+
+Fill in mate coordinates, ISIZE and mate related flags from a
+name-sorted alignment.
+
+.TP
+.B rmdup
+samtools rmdup <input.srt.bam> <out.bam>
+
+Remove potential PCR duplicates: if multiple read pairs have identical
+external coordinates, only retain the pair with highest mapping quality.
+This command
+.B ONLY
+works with FR orientation and requires ISIZE is correctly set.
+
+.TP
+.B rmdupse
+samtools rmdupse <input.srt.bam> <out.bam>
+
+Remove potential duplicates for single-ended reads. This command will
+treat all reads as single-ended even if they are paired in fact.
+
+.TP
+.B fillmd
+samtools fillmd [-e] <aln.bam> <ref.fasta>
+
+Generate the MD tag. If the MD tag is already present, this command will
+give a warning if the MD tag generated is different from the existing
+tag.
+
+.B OPTIONS:
+.RS
+.TP 8
+.B -e
+Convert a the read base to = if it is identical to the aligned reference
+base. Indel caller does not support the = bases at the moment.
+
+.RE
+
+.SH SAM FORMAT
+
+SAM is TAB-delimited. Apart from the header lines, which are started
+with the `@' symbol, each alignment line consists of:
+
+.TS
+center box;
+cb | cb | cb
+n | l | l .
+Col	Field	Description
+_
+1	QNAME	Query (pair) NAME
+2	FLAG	bitwise FLAG
+3	RNAME	Reference sequence NAME
+4	POS	1-based leftmost POSition/coordinate of clipped sequence
+5	MAPQ	MAPping Quality (Phred-scaled)
+6	CIAGR	extended CIGAR string
+7	MRNM	Mate Reference sequence NaMe (`=' if same as RNAME)
+8	MPOS	1-based Mate POSistion
+9	ISIZE	Inferred insert SIZE
+10	SEQ	query SEQuence on the same strand as the reference
+11	QUAL	query QUALity (ASCII-33 gives the Phred base quality)
+12	OPT	variable OPTional fields in the format TAG:VTYPE:VALUE
+.TE
+
+.PP
+Each bit in the FLAG field is defined as:
+
+.TS
+center box;
+cb | cb
+l | l .
+Flag	Description
+_
+0x0001	the read is paired in sequencing
+0x0002	the read is mapped in a proper pair
+0x0004	the query sequence itself is unmapped
+0x0008	the mate is unmapped
+0x0010	strand of the query (1 for reverse)
+0x0020	strand of the mate
+0x0040	the read is the first read in a pair
+0x0080	the read is the second read in a pair
+0x0100	the alignment is not primary
+0x0200	the read fails platform/vendor quality checks
+0x0400	the read is either a PCR or an optical duplicate
+.TE
+
+.SH LIMITATIONS
+.PP
+.IP o 2
+Unaligned words used in bam_import.c, bam_endian.h, bam.c and bam_aux.c.
+.IP o 2
+CIGAR operation P is not properly handled at the moment.
+.IP o 2
+In merging, the input files are required to have the same number of
+reference sequences. The requirement can be relaxed. In addition,
+merging does not reconstruct the header dictionaries
+automatically. Endusers have to provide the correct header. Picard is
+better at merging.
+.IP o 2
+Samtools' rmdup does not work for single-end data and does not remove
+duplicates across chromosomes. Picard is better.
+
+.SH AUTHOR
+.PP
+Heng Li from the Sanger Institute wrote the C version of samtools. Bob
+Handsaker from the Broad Institute implemented the BGZF library and Jue
+Ruan from Beijing Genomics Institute wrote the RAZF library. Various
+people in the 1000Genomes Project contributed to the SAM format
+specification.
+
+.SH SEE ALSO
+.PP
+Samtools website: <http://samtools.sourceforge.net>
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/samtools.txt b/ext/samtools-0.1.7a_getUnique-0.1.3/samtools.txt
new file mode 100644
index 0000000..feec238
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/samtools.txt
@@ -0,0 +1,375 @@
+samtools(1)                  Bioinformatics tools                  samtools(1)
+
+
+
+NAME
+       samtools - Utilities for the Sequence Alignment/Map (SAM) format
+
+SYNOPSIS
+       samtools view -bt ref_list.txt -o aln.bam aln.sam.gz
+
+       samtools sort aln.bam aln.sorted
+
+       samtools index aln.sorted.bam
+
+       samtools view aln.sorted.bam chr2:20,100,000-20,200,000
+
+       samtools merge out.bam in1.bam in2.bam in3.bam
+
+       samtools faidx ref.fasta
+
+       samtools pileup -f ref.fasta aln.sorted.bam
+
+       samtools tview aln.sorted.bam ref.fasta
+
+
+DESCRIPTION
+       Samtools  is  a  set of utilities that manipulate alignments in the BAM
+       format. It imports from and exports to the SAM (Sequence Alignment/Map)
+       format,  does  sorting,  merging  and  indexing, and allows to retrieve
+       reads in any regions swiftly.
+
+       Samtools is designed to work on a stream. It regards an input file  `-'
+       as  the  standard  input (stdin) and an output file `-' as the standard
+       output (stdout). Several commands can thus be combined with Unix pipes.
+       Samtools always output warning and error messages to the standard error
+       output (stderr).
+
+       Samtools is also able to open a BAM (not SAM) file on a remote  FTP  or
+       HTTP  server  if  the  BAM file name starts with `ftp://' or `http://'.
+       Samtools checks the current working directory for the  index  file  and
+       will  download  the  index upon absence. Samtools does not retrieve the
+       entire alignment file unless it is asked to do so.
+
+
+COMMANDS AND OPTIONS
+       import    samtools import <in.ref_list> <in.sam> <out.bam>
+
+                 Since 0.1.4, this command is an alias of:
+
+                 samtools view -bt <in.ref_list> -o <out.bam> <in.sam>
+
+
+       sort      samtools sort [-n] [-m maxMem] <in.bam> <out.prefix>
+
+                 Sort  alignments  by  leftmost  coordinates.  File  <out.pre-
+                 fix>.bam will be created. This command may also create tempo-
+                 rary files <out.prefix>.%d.bam when the whole alignment  can-
+                 not be fitted into memory (controlled by option -m).
+
+                 OPTIONS:
+
+                 -n      Sort by read names rather than by chromosomal coordi-
+                         nates
+
+                 -m INT  Approximately   the    maximum    required    memory.
+                         [500000000]
+
+
+       merge     samtools   merge   [-h   inh.sam]  [-n]  <out.bam>  <in1.bam>
+                 <in2.bam> [...]
+
+                 Merge multiple sorted alignments.  The header reference lists
+                 of  all  the input BAM files, and the @SQ headers of inh.sam,
+                 if  any,  must  all  refer  to  the  same  set  of  reference
+                 sequences.   The header reference list and (unless overridden
+                 by -h) `@' headers of in1.bam will be copied to out.bam,  and
+                 the headers of other files will be ignored.
+
+                 OPTIONS:
+
+                 -h FILE Use  the lines of FILE as `@' headers to be copied to
+                         out.bam, replacing any header lines that would other-
+                         wise  be  copied  from in1.bam.  (FILE is actually in
+                         SAM format, though any alignment records it may  con-
+                         tain are ignored.)
+
+                 -n      The  input alignments are sorted by read names rather
+                         than by chromosomal coordinates
+
+
+       index     samtools index <aln.bam>
+
+                 Index sorted alignment for fast  random  access.  Index  file
+                 <aln.bam>.bai will be created.
+
+
+       view      samtools  view  [-bhuHS]  [-t  in.refList]  [-o  output]  [-f
+                 reqFlag] [-F skipFlag] [-q minMapQ] [-l  library]  [-r  read-
+                 Group] <in.bam>|<in.sam> [region1 [...]]
+
+                 Extract/print  all or sub alignments in SAM or BAM format. If
+                 no region is specified, all the alignments will  be  printed;
+                 otherwise  only  alignments overlapping the specified regions
+                 will be output. An alignment may be given multiple  times  if
+                 it is overlapping several regions. A region can be presented,
+                 for example, in  the  following  format:  `chr2'  (the  whole
+                 chr2),  `chr2:1000000'  (region starting from 1,000,000bp) or
+                 `chr2:1,000,000-2,000,000'  (region  between  1,000,000   and
+                 2,000,000bp  including  the  end  points).  The coordinate is
+                 1-based.
+
+                 OPTIONS:
+
+                 -b      Output in the BAM format.
+
+                 -u      Output uncompressed BAM. This option saves time spent
+                         on  compression/decomprssion  and  is  thus preferred
+                         when the output is piped to another samtools command.
+
+                 -h      Include the header in the output.
+
+                 -H      Output the header only.
+
+                 -S      Input  is in SAM. If @SQ header lines are absent, the
+                         `-t' option is required.
+
+                 -t FILE This file is TAB-delimited. Each  line  must  contain
+                         the  reference  name and the length of the reference,
+                         one line  for  each  distinct  reference;  additional
+                         fields  are ignored. This file also defines the order
+                         of the reference sequences in  sorting.  If  you  run
+                         `samtools  faidx  <ref.fa>', the resultant index file
+                         <ref.fa>.fai can be used as this <in.ref_list>  file.
+
+                 -o FILE Output file [stdout]
+
+                 -f INT  Only  output  alignments with all bits in INT present
+                         in the FLAG field. INT can be in hex in the format of
+                         /^0x[0-9A-F]+/ [0]
+
+                 -F INT  Skip alignments with bits present in INT [0]
+
+                 -q INT  Skip alignments with MAPQ smaller than INT [0]
+
+                 -l STR  Only output reads in library STR [null]
+
+                 -r STR  Only output reads in read group STR [null]
+
+
+       faidx     samtools faidx <ref.fasta> [region1 [...]]
+
+                 Index  reference sequence in the FASTA format or extract sub-
+                 sequence from indexed reference sequence.  If  no  region  is
+                 specified,   faidx   will   index   the   file   and   create
+                 <ref.fasta>.fai on the disk. If regions are speficified,  the
+                 subsequences  will  be retrieved and printed to stdout in the
+                 FASTA format. The input file can be compressed  in  the  RAZF
+                 format.
+
+
+       pileup    samtools   pileup  [-f  in.ref.fasta]  [-t  in.ref_list]  [-l
+                 in.site_list]   [-iscgS2]   [-T   theta]   [-N   nHap]    [-r
+                 pairDiffRate] <in.bam>|<in.sam>
+
+                 Print  the alignment in the pileup format. In the pileup for-
+                 mat, each line represents a genomic position,  consisting  of
+                 chromosome name, coordinate, reference base, read bases, read
+                 qualities and alignment  mapping  qualities.  Information  on
+                 match, mismatch, indel, strand, mapping quality and start and
+                 end of a read are all encoded at the  read  base  column.  At
+                 this  column,  a dot stands for a match to the reference base
+                 on the forward strand, a comma for a  match  on  the  reverse
+                 strand,  `ACGTN'  for  a  mismatch  on the forward strand and
+                 `acgtn' for a mismatch  on  the  reverse  strand.  A  pattern
+                 `\+[0-9]+[ACGTNacgtn]+'   indicates  there  is  an  insertion
+                 between this reference position and the next reference  posi-
+                 tion.  The length of the insertion is given by the integer in
+                 the pattern, followed by the inserted sequence. Similarly,  a
+                 pattern `-[0-9]+[ACGTNacgtn]+' represents a deletion from the
+                 reference. The deleted bases will be presented as `*' in  the
+                 following  lines.  Also at the read base column, a symbol `^'
+                 marks the start of a read segment which is a contiguous  sub-
+                 sequence  on  the read separated by `N/S/H' CIGAR operations.
+                 The ASCII of the character following `^' minus 33  gives  the
+                 mapping  quality.  A  symbol `$' marks the end of a read seg-
+                 ment.
+
+                 If option -c is applied,  the  consensus  base,  Phred-scaled
+                 consensus  quality, SNP quality (i.e. the Phred-scaled proba-
+                 bility of the consensus being identical to the reference) and
+                 root  mean square (RMS) mapping quality of the reads covering
+                 the site will be inserted between the  `reference  base'  and
+                 the  `read  bases'  columns.  An indel occupies an additional
+                 line. Each indel line consists of  chromosome  name,  coordi-
+                 nate,  a  star, the genotype, consensus quality, SNP quality,
+                 RMS mapping quality, # covering reads, the first alllele, the
+                 second  allele,  # reads supporting the first allele, # reads
+                 supporting the second allele and #  reads  containing  indels
+                 different from the top two alleles.
+
+                 OPTIONS:
+
+
+                 -s        Print  the mapping quality as the last column. This
+                           option makes the output easier to  parse,  although
+                           this format is not space efficient.
+
+
+                 -S        The input file is in SAM.
+
+
+                 -i        Only output pileup lines containing indels.
+
+
+                 -f FILE   The  reference  sequence in the FASTA format. Index
+                           file FILE.fai will be created if absent.
+
+
+                 -M INT    Cap mapping quality at INT [60]
+
+
+                 -t FILE   List of reference names ane  sequence  lengths,  in
+                           the  format  described  for  the import command. If
+                           this option is present, samtools assumes the  input
+                           <in.alignment>  is  in  SAM  format;  otherwise  it
+                           assumes in BAM format.
+
+
+                 -l FILE   List of sites at which pileup is output. This  file
+                           is  space  delimited.  The  first  two  columns are
+                           required to be chromosome and  1-based  coordinate.
+                           Additional  columns  are ignored. It is recommended
+                           to use option -s together with -l as in the default
+                           format we may not know the mapping quality.
+
+
+                 -c        Call  the  consensus  sequence  using MAQ consensus
+                           model. Options -T, -N, -I and -r are only effective
+                           when -c or -g is in use.
+
+
+                 -g        Generate  genotype  likelihood  in the binary GLFv3
+                           format. This option suppresses -c, -i and -s.
+
+
+                 -T FLOAT  The theta parameter (error dependency  coefficient)
+                           in the maq consensus calling model [0.85]
+
+
+                 -N INT    Number of haplotypes in the sample (>=2) [2]
+
+
+                 -r FLOAT  Expected  fraction of differences between a pair of
+                           haplotypes [0.001]
+
+
+                 -I INT    Phred probability of an indel  in  sequencing/prep.
+                           [40]
+
+
+
+       tview     samtools tview <in.sorted.bam> [ref.fasta]
+
+                 Text  alignment viewer (based on the ncurses library). In the
+                 viewer, press `?' for help and press `g' to check the  align-
+                 ment    start    from   a   region   in   the   format   like
+                 `chr10:10,000,000'.
+
+
+       fixmate   samtools fixmate <in.nameSrt.bam> <out.bam>
+
+                 Fill in mate coordinates, ISIZE and mate related flags from a
+                 name-sorted alignment.
+
+
+       rmdup     samtools rmdup <input.srt.bam> <out.bam>
+
+                 Remove  potential PCR duplicates: if multiple read pairs have
+                 identical external coordinates, only  retain  the  pair  with
+                 highest  mapping  quality.   This  command ONLY works with FR
+                 orientation and requires ISIZE is correctly set.
+
+
+       rmdupse   samtools rmdupse <input.srt.bam> <out.bam>
+
+                 Remove potential duplicates for single-ended reads. This com-
+                 mand  will  treat  all reads as single-ended even if they are
+                 paired in fact.
+
+
+       fillmd    samtools fillmd [-e] <aln.bam> <ref.fasta>
+
+                 Generate the MD tag. If the MD tag is already  present,  this
+                 command  will  give a warning if the MD tag generated is dif-
+                 ferent from the existing tag.
+
+                 OPTIONS:
+
+                 -e      Convert a the read base to = if it  is  identical  to
+                         the  aligned  reference  base.  Indel caller does not
+                         support the = bases at the moment.
+
+
+
+SAM FORMAT
+       SAM is TAB-delimited. Apart from the header lines,  which  are  started
+       with the `@' symbol, each alignment line consists of:
+
+
+       +----+-------+----------------------------------------------------------+
+       |Col | Field |                       Description                        |
+       +----+-------+----------------------------------------------------------+
+       | 1  | QNAME | Query (pair) NAME                                        |
+       | 2  | FLAG  | bitwise FLAG                                             |
+       | 3  | RNAME | Reference sequence NAME                                  |
+       | 4  | POS   | 1-based leftmost POSition/coordinate of clipped sequence |
+       | 5  | MAPQ  | MAPping Quality (Phred-scaled)                           |
+       | 6  | CIAGR | extended CIGAR string                                    |
+       | 7  | MRNM  | Mate Reference sequence NaMe (`=' if same as RNAME)      |
+       | 8  | MPOS  | 1-based Mate POSistion                                   |
+       | 9  | ISIZE | Inferred insert SIZE                                     |
+       |10  | SEQ   | query SEQuence on the same strand as the reference       |
+       |11  | QUAL  | query QUALity (ASCII-33 gives the Phred base quality)    |
+       |12  | OPT   | variable OPTional fields in the format TAG:VTYPE:VALUE   |
+       +----+-------+----------------------------------------------------------+
+
+       Each bit in the FLAG field is defined as:
+
+
+             +-------+--------------------------------------------------+
+             | Flag  |                   Description                    |
+             +-------+--------------------------------------------------+
+             |0x0001 | the read is paired in sequencing                 |
+             |0x0002 | the read is mapped in a proper pair              |
+             |0x0004 | the query sequence itself is unmapped            |
+             |0x0008 | the mate is unmapped                             |
+             |0x0010 | strand of the query (1 for reverse)              |
+             |0x0020 | strand of the mate                               |
+             |0x0040 | the read is the first read in a pair             |
+             |0x0080 | the read is the second read in a pair            |
+             |0x0100 | the alignment is not primary                     |
+             |0x0200 | the read fails platform/vendor quality checks    |
+             |0x0400 | the read is either a PCR or an optical duplicate |
+             +-------+--------------------------------------------------+
+
+LIMITATIONS
+       o Unaligned   words  used  in  bam_import.c,  bam_endian.h,  bam.c  and
+         bam_aux.c.
+
+       o CIGAR operation P is not properly handled at the moment.
+
+       o In merging, the input files are required to have the same  number  of
+         reference  sequences.  The  requirement  can be relaxed. In addition,
+         merging does not reconstruct the header  dictionaries  automatically.
+         Endusers  have  to  provide  the  correct header. Picard is better at
+         merging.
+
+       o Samtools' rmdup does not work for single-end data and does not remove
+         duplicates across chromosomes. Picard is better.
+
+
+AUTHOR
+       Heng  Li from the Sanger Institute wrote the C version of samtools. Bob
+       Handsaker from the Broad Institute implemented the BGZF library and Jue
+       Ruan  from  Beijing  Genomics Institute wrote the RAZF library. Various
+       people in the 1000Genomes Project contributed to the SAM format  speci-
+       fication.
+
+
+SEE ALSO
+       Samtools website: <http://samtools.sourceforge.net>
+
+
+
+samtools-0.1.7                 10 November 2009                    samtools(1)
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/win32/libcurses.a b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/libcurses.a
new file mode 100644
index 0000000..a3863b8
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/libcurses.a differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/win32/libz.a b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/libz.a
new file mode 100644
index 0000000..23e8d60
Binary files /dev/null and b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/libz.a differ
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/win32/xcurses.h b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/xcurses.h
new file mode 100644
index 0000000..6f3ce19
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/xcurses.h
@@ -0,0 +1,1377 @@
+/* Public Domain Curses */
+
+/* $Id: curses.h,v 1.295 2008/07/15 17:13:25 wmcbrine Exp $ */
+
+/*----------------------------------------------------------------------*
+ *                              PDCurses                                *
+ *----------------------------------------------------------------------*/
+
+#ifndef __PDCURSES__
+#define __PDCURSES__ 1
+
+/*man-start**************************************************************
+
+PDCurses definitions list:  (Only define those needed)
+
+    XCURSES         True if compiling for X11.
+    PDC_RGB         True if you want to use RGB color definitions
+                    (Red = 1, Green = 2, Blue = 4) instead of BGR.
+    PDC_WIDE        True if building wide-character support.
+    PDC_DLL_BUILD   True if building a Win32 DLL.
+    NCURSES_MOUSE_VERSION   Use the ncurses mouse API instead
+                            of PDCurses' traditional mouse API.
+
+PDCurses portable platform definitions list:
+
+    PDC_BUILD       Defines API build version.
+    PDCURSES        Enables access to PDCurses-only routines.
+    XOPEN           Always true.
+    SYSVcurses      True if you are compiling for SYSV portability.
+    BSDcurses       True if you are compiling for BSD portability.
+
+**man-end****************************************************************/
+
+#define PDC_BUILD 3401
+#define PDCURSES        1      /* PDCurses-only routines */
+#define XOPEN           1      /* X/Open Curses routines */
+#define SYSVcurses      1      /* System V Curses routines */
+#define BSDcurses       1      /* BSD Curses routines */
+#define CHTYPE_LONG     1      /* size of chtype; long */
+
+/*----------------------------------------------------------------------*/
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>             /* Required by X/Open usage below */
+
+#ifdef PDC_WIDE
+# include <wchar.h>
+#endif
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+extern "C"
+{
+# define bool _bool
+#endif
+
+/*----------------------------------------------------------------------
+ *
+ *  PDCurses Manifest Constants
+ *
+ */
+
+#ifndef FALSE
+# define FALSE 0
+#endif
+#ifndef TRUE
+# define TRUE 1
+#endif
+#ifndef NULL
+# define NULL (void *)0
+#endif
+#ifndef ERR
+# define ERR (-1)
+#endif
+#ifndef OK
+# define OK 0
+#endif
+
+/*----------------------------------------------------------------------
+ *
+ *  PDCurses Type Declarations
+ *
+ */
+
+typedef unsigned char bool;    /* PDCurses Boolean type */
+
+#ifdef CHTYPE_LONG
+# if _LP64
+typedef unsigned int chtype;
+# else
+typedef unsigned long chtype;  /* 16-bit attr + 16-bit char */
+# endif
+#else
+typedef unsigned short chtype; /* 8-bit attr + 8-bit char */
+#endif
+
+#ifdef PDC_WIDE
+typedef chtype cchar_t;
+#endif
+
+typedef chtype attr_t;
+
+/*----------------------------------------------------------------------
+ *
+ *  PDCurses Mouse Interface -- SYSVR4, with extensions
+ *
+ */
+
+typedef struct
+{
+    int x;           /* absolute column, 0 based, measured in characters */
+    int y;           /* absolute row, 0 based, measured in characters */
+    short button[3]; /* state of each button */
+    int changes;     /* flags indicating what has changed with the mouse */
+} MOUSE_STATUS;
+
+#define BUTTON_RELEASED         0x0000
+#define BUTTON_PRESSED          0x0001
+#define BUTTON_CLICKED          0x0002
+#define BUTTON_DOUBLE_CLICKED   0x0003
+#define BUTTON_TRIPLE_CLICKED   0x0004
+#define BUTTON_MOVED            0x0005  /* PDCurses */
+#define WHEEL_SCROLLED          0x0006  /* PDCurses */
+#define BUTTON_ACTION_MASK      0x0007  /* PDCurses */
+
+#define PDC_BUTTON_SHIFT        0x0008  /* PDCurses */
+#define PDC_BUTTON_CONTROL      0x0010  /* PDCurses */
+#define PDC_BUTTON_ALT          0x0020  /* PDCurses */
+#define BUTTON_MODIFIER_MASK    0x0038  /* PDCurses */
+
+#define MOUSE_X_POS             (Mouse_status.x)
+#define MOUSE_Y_POS             (Mouse_status.y)
+
+/*
+ * Bits associated with the .changes field:
+ *   3         2         1         0
+ * 210987654321098765432109876543210
+ *                                 1 <- button 1 has changed
+ *                                10 <- button 2 has changed
+ *                               100 <- button 3 has changed
+ *                              1000 <- mouse has moved
+ *                             10000 <- mouse position report
+ *                            100000 <- mouse wheel up
+ *                           1000000 <- mouse wheel down
+ */
+
+#define PDC_MOUSE_MOVED         0x0008
+#define PDC_MOUSE_POSITION      0x0010
+#define PDC_MOUSE_WHEEL_UP      0x0020
+#define PDC_MOUSE_WHEEL_DOWN    0x0040
+
+#define A_BUTTON_CHANGED        (Mouse_status.changes & 7)
+#define MOUSE_MOVED             (Mouse_status.changes & PDC_MOUSE_MOVED)
+#define MOUSE_POS_REPORT        (Mouse_status.changes & PDC_MOUSE_POSITION)
+#define BUTTON_CHANGED(x)       (Mouse_status.changes & (1 << ((x) - 1)))
+#define BUTTON_STATUS(x)        (Mouse_status.button[(x) - 1])
+#define MOUSE_WHEEL_UP          (Mouse_status.changes & PDC_MOUSE_WHEEL_UP)
+#define MOUSE_WHEEL_DOWN        (Mouse_status.changes & PDC_MOUSE_WHEEL_DOWN)
+
+/* mouse bit-masks */
+
+#define BUTTON1_RELEASED        0x00000001L
+#define BUTTON1_PRESSED         0x00000002L
+#define BUTTON1_CLICKED         0x00000004L
+#define BUTTON1_DOUBLE_CLICKED  0x00000008L
+#define BUTTON1_TRIPLE_CLICKED  0x00000010L
+#define BUTTON1_MOVED           0x00000010L /* PDCurses */
+
+#define BUTTON2_RELEASED        0x00000020L
+#define BUTTON2_PRESSED         0x00000040L
+#define BUTTON2_CLICKED         0x00000080L
+#define BUTTON2_DOUBLE_CLICKED  0x00000100L
+#define BUTTON2_TRIPLE_CLICKED  0x00000200L
+#define BUTTON2_MOVED           0x00000200L /* PDCurses */
+
+#define BUTTON3_RELEASED        0x00000400L
+#define BUTTON3_PRESSED         0x00000800L
+#define BUTTON3_CLICKED         0x00001000L
+#define BUTTON3_DOUBLE_CLICKED  0x00002000L
+#define BUTTON3_TRIPLE_CLICKED  0x00004000L
+#define BUTTON3_MOVED           0x00004000L /* PDCurses */
+
+/* For the ncurses-compatible functions only, BUTTON4_PRESSED and 
+   BUTTON5_PRESSED are returned for mouse scroll wheel up and down; 
+   otherwise PDCurses doesn't support buttons 4 and 5 */
+
+#define BUTTON4_RELEASED        0x00008000L
+#define BUTTON4_PRESSED         0x00010000L
+#define BUTTON4_CLICKED         0x00020000L
+#define BUTTON4_DOUBLE_CLICKED  0x00040000L
+#define BUTTON4_TRIPLE_CLICKED  0x00080000L
+
+#define BUTTON5_RELEASED        0x00100000L
+#define BUTTON5_PRESSED         0x00200000L
+#define BUTTON5_CLICKED         0x00400000L
+#define BUTTON5_DOUBLE_CLICKED  0x00800000L
+#define BUTTON5_TRIPLE_CLICKED  0x01000000L
+
+#define MOUSE_WHEEL_SCROLL      0x02000000L /* PDCurses */
+#define BUTTON_MODIFIER_SHIFT   0x04000000L /* PDCurses */
+#define BUTTON_MODIFIER_CONTROL 0x08000000L /* PDCurses */
+#define BUTTON_MODIFIER_ALT     0x10000000L /* PDCurses */
+
+#define ALL_MOUSE_EVENTS        0x1fffffffL
+#define REPORT_MOUSE_POSITION   0x20000000L
+
+/* ncurses mouse interface */
+
+typedef unsigned long mmask_t;
+
+typedef struct
+{
+        short id;       /* unused, always 0 */
+        int x, y, z;    /* x, y same as MOUSE_STATUS; z unused */
+        mmask_t bstate; /* equivalent to changes + button[], but
+                           in the same format as used for mousemask() */
+} MEVENT;
+
+#ifdef NCURSES_MOUSE_VERSION
+# define BUTTON_SHIFT   BUTTON_MODIFIER_SHIFT
+# define BUTTON_CONTROL BUTTON_MODIFIER_CONTROL
+# define BUTTON_CTRL    BUTTON_MODIFIER_CONTROL
+# define BUTTON_ALT     BUTTON_MODIFIER_ALT
+#else
+# define BUTTON_SHIFT   PDC_BUTTON_SHIFT
+# define BUTTON_CONTROL PDC_BUTTON_CONTROL
+# define BUTTON_ALT     PDC_BUTTON_ALT
+#endif
+
+/*----------------------------------------------------------------------
+ *
+ *  PDCurses Structure Definitions
+ *
+ */
+
+typedef struct _win       /* definition of a window */
+{
+    int   _cury;          /* current pseudo-cursor */
+    int   _curx;
+    int   _maxy;          /* max window coordinates */
+    int   _maxx;
+    int   _begy;          /* origin on screen */
+    int   _begx;
+    int   _flags;         /* window properties */
+    chtype _attrs;        /* standard attributes and colors */
+    chtype _bkgd;         /* background, normally blank */
+    bool  _clear;         /* causes clear at next refresh */
+    bool  _leaveit;       /* leaves cursor where it is */
+    bool  _scroll;        /* allows window scrolling */
+    bool  _nodelay;       /* input character wait flag */
+    bool  _immed;         /* immediate update flag */
+    bool  _sync;          /* synchronise window ancestors */
+    bool  _use_keypad;    /* flags keypad key mode active */
+    chtype **_y;          /* pointer to line pointer array */
+    int   *_firstch;      /* first changed character in line */
+    int   *_lastch;       /* last changed character in line */
+    int   _tmarg;         /* top of scrolling region */
+    int   _bmarg;         /* bottom of scrolling region */
+    int   _delayms;       /* milliseconds of delay for getch() */
+    int   _parx, _pary;   /* coords relative to parent (0,0) */
+    struct _win *_parent; /* subwin's pointer to parent win */
+} WINDOW;
+
+/* Avoid using the SCREEN struct directly -- use the corresponding 
+   functions if possible. This struct may eventually be made private. */
+
+typedef struct
+{
+    bool  alive;          /* if initscr() called, and not endwin() */
+    bool  autocr;         /* if cr -> lf */
+    bool  cbreak;         /* if terminal unbuffered */
+    bool  echo;           /* if terminal echo */
+    bool  raw_inp;        /* raw input mode (v. cooked input) */
+    bool  raw_out;        /* raw output mode (7 v. 8 bits) */
+    bool  audible;        /* FALSE if the bell is visual */
+    bool  mono;           /* TRUE if current screen is mono */
+    bool  resized;        /* TRUE if TERM has been resized */
+    bool  orig_attr;      /* TRUE if we have the original colors */
+    short orig_fore;      /* original screen foreground color */
+    short orig_back;      /* original screen foreground color */
+    int   cursrow;        /* position of physical cursor */
+    int   curscol;        /* position of physical cursor */
+    int   visibility;     /* visibility of cursor */
+    int   orig_cursor;    /* original cursor size */
+    int   lines;          /* new value for LINES */
+    int   cols;           /* new value for COLS */
+    unsigned long _trap_mbe;       /* trap these mouse button events */
+    unsigned long _map_mbe_to_key; /* map mouse buttons to slk */
+    int   mouse_wait;              /* time to wait (in ms) for a
+                                      button release after a press, in 
+                                      order to count it as a click */
+    int   slklines;                /* lines in use by slk_init() */
+    WINDOW *slk_winptr;            /* window for slk */
+    int   linesrippedoff;          /* lines ripped off via ripoffline() */
+    int   linesrippedoffontop;     /* lines ripped off on 
+                                      top via ripoffline() */
+    int   delaytenths;             /* 1/10ths second to wait block
+                                      getch() for */
+    bool  _preserve;               /* TRUE if screen background
+                                      to be preserved */
+    int   _restore;                /* specifies if screen background
+                                      to be restored, and how */
+    bool  save_key_modifiers;      /* TRUE if each key modifiers saved
+                                      with each key press */
+    bool  return_key_modifiers;    /* TRUE if modifier keys are
+                                      returned as "real" keys */
+    bool  key_code;                /* TRUE if last key is a special key;
+                                      used internally by get_wch() */
+#ifdef XCURSES
+    int   XcurscrSize;    /* size of Xcurscr shared memory block */
+    bool  sb_on;
+    int   sb_viewport_y;
+    int   sb_viewport_x;
+    int   sb_total_y;
+    int   sb_total_x;
+    int   sb_cur_y;
+    int   sb_cur_x;
+#endif
+    short line_color;     /* color of line attributes - default -1 */
+} SCREEN;
+
+/*----------------------------------------------------------------------
+ *
+ *  PDCurses External Variables
+ *
+ */
+
+#ifdef PDC_DLL_BUILD
+# ifdef CURSES_LIBRARY
+#  define PDCEX __declspec(dllexport) extern
+# else
+#  define PDCEX __declspec(dllimport)
+# endif
+#else
+# define PDCEX extern
+#endif
+
+PDCEX  int          LINES;        /* terminal height */
+PDCEX  int          COLS;         /* terminal width */
+PDCEX  WINDOW       *stdscr;      /* the default screen window */
+PDCEX  WINDOW       *curscr;      /* the current screen image */
+PDCEX  SCREEN       *SP;          /* curses variables */
+PDCEX  MOUSE_STATUS Mouse_status;
+PDCEX  int          COLORS;
+PDCEX  int          COLOR_PAIRS;
+PDCEX  int          TABSIZE;
+PDCEX  chtype       acs_map[];    /* alternate character set map */
+PDCEX  char         ttytype[];    /* terminal name/description */
+
+/*man-start**************************************************************
+
+PDCurses Text Attributes
+========================
+
+Originally, PDCurses used a short (16 bits) for its chtype. To include 
+color, a number of things had to be sacrificed from the strict Unix and 
+System V support. The main problem was fitting all character attributes 
+and color into an unsigned char (all 8 bits!).
+
+Today, PDCurses by default uses a long (32 bits) for its chtype, as in 
+System V. The short chtype is still available, by undefining CHTYPE_LONG 
+and rebuilding the library.
+
+The following is the structure of a win->_attrs chtype:
+
+short form:
+
+-------------------------------------------------
+|15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+-------------------------------------------------
+  color number |  attrs |   character eg 'a'
+
+The available non-color attributes are bold, reverse and blink. Others 
+have no effect. The high order char is an index into an array of 
+physical colors (defined in color.c) -- 32 foreground/background color 
+pairs (5 bits) plus 3 bits for other attributes.
+
+long form:
+
+----------------------------------------------------------------------------
+|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|..| 3| 2| 1| 0|
+----------------------------------------------------------------------------
+      color number      |     modifiers         |      character eg 'a'
+
+The available non-color attributes are bold, underline, invisible, 
+right-line, left-line, protect, reverse and blink. 256 color pairs (8 
+bits), 8 bits for other attributes, and 16 bits for character data.
+
+**man-end****************************************************************/
+
+/*** Video attribute macros ***/
+
+#define A_NORMAL      (chtype)0
+
+#ifdef CHTYPE_LONG
+# define A_ALTCHARSET (chtype)0x00010000
+# define A_RIGHTLINE  (chtype)0x00020000
+# define A_LEFTLINE   (chtype)0x00040000
+# define A_INVIS      (chtype)0x00080000
+# define A_UNDERLINE  (chtype)0x00100000
+# define A_REVERSE    (chtype)0x00200000
+# define A_BLINK      (chtype)0x00400000
+# define A_BOLD       (chtype)0x00800000
+
+# define A_ATTRIBUTES (chtype)0xffff0000
+# define A_CHARTEXT   (chtype)0x0000ffff
+# define A_COLOR      (chtype)0xff000000
+
+# define A_ITALIC     A_INVIS
+# define A_PROTECT    (A_UNDERLINE | A_LEFTLINE | A_RIGHTLINE)
+
+# define PDC_ATTR_SHIFT  19
+# define PDC_COLOR_SHIFT 24
+#else
+# define A_BOLD       (chtype)0x0100  /* X/Open */
+# define A_REVERSE    (chtype)0x0200  /* X/Open */
+# define A_BLINK      (chtype)0x0400  /* X/Open */
+
+# define A_ATTRIBUTES (chtype)0xff00  /* X/Open */
+# define A_CHARTEXT   (chtype)0x00ff  /* X/Open */
+# define A_COLOR      (chtype)0xf800  /* System V */
+
+# define A_ALTCHARSET A_NORMAL        /* X/Open */
+# define A_PROTECT    A_NORMAL        /* X/Open */
+# define A_UNDERLINE  A_NORMAL        /* X/Open */
+
+# define A_LEFTLINE   A_NORMAL
+# define A_RIGHTLINE  A_NORMAL
+# define A_ITALIC     A_NORMAL
+# define A_INVIS      A_NORMAL
+
+# define PDC_ATTR_SHIFT   8
+# define PDC_COLOR_SHIFT 11
+#endif
+
+#define A_STANDOUT    (A_REVERSE | A_BOLD) /* X/Open */
+#define A_DIM         A_NORMAL
+
+#define CHR_MSK       A_CHARTEXT           /* Obsolete */
+#define ATR_MSK       A_ATTRIBUTES         /* Obsolete */
+#define ATR_NRM       A_NORMAL             /* Obsolete */
+
+/* For use with attr_t -- X/Open says, "these shall be distinct", so 
+   this is a non-conforming implementation. */
+
+#define WA_ALTCHARSET A_ALTCHARSET
+#define WA_BLINK      A_BLINK
+#define WA_BOLD       A_BOLD
+#define WA_DIM        A_DIM
+#define WA_INVIS      A_INVIS
+#define WA_LEFT       A_LEFTLINE
+#define WA_PROTECT    A_PROTECT
+#define WA_REVERSE    A_REVERSE
+#define WA_RIGHT      A_RIGHTLINE
+#define WA_STANDOUT   A_STANDOUT
+#define WA_UNDERLINE  A_UNDERLINE
+
+#define WA_HORIZONTAL A_NORMAL
+#define WA_LOW        A_NORMAL
+#define WA_TOP        A_NORMAL
+#define WA_VERTICAL   A_NORMAL
+
+/*** Alternate character set macros ***/
+
+/* 'w' = 32-bit chtype; acs_map[] index | A_ALTCHARSET
+   'n' = 16-bit chtype; it gets the fallback set because no bit is 
+         available for A_ALTCHARSET */
+
+#ifdef CHTYPE_LONG
+# define ACS_PICK(w, n) ((chtype)w | A_ALTCHARSET)
+#else
+# define ACS_PICK(w, n) ((chtype)n)
+#endif
+
+/* VT100-compatible symbols -- box chars */
+
+#define ACS_ULCORNER  ACS_PICK('l', '+')
+#define ACS_LLCORNER  ACS_PICK('m', '+')
+#define ACS_URCORNER  ACS_PICK('k', '+')
+#define ACS_LRCORNER  ACS_PICK('j', '+')
+#define ACS_RTEE      ACS_PICK('u', '+')
+#define ACS_LTEE      ACS_PICK('t', '+')
+#define ACS_BTEE      ACS_PICK('v', '+')
+#define ACS_TTEE      ACS_PICK('w', '+')
+#define ACS_HLINE     ACS_PICK('q', '-')
+#define ACS_VLINE     ACS_PICK('x', '|')
+#define ACS_PLUS      ACS_PICK('n', '+')
+
+/* VT100-compatible symbols -- other */
+
+#define ACS_S1        ACS_PICK('o', '-')
+#define ACS_S9        ACS_PICK('s', '_')
+#define ACS_DIAMOND   ACS_PICK('`', '+')
+#define ACS_CKBOARD   ACS_PICK('a', ':')
+#define ACS_DEGREE    ACS_PICK('f', '\'')
+#define ACS_PLMINUS   ACS_PICK('g', '#')
+#define ACS_BULLET    ACS_PICK('~', 'o')
+
+/* Teletype 5410v1 symbols -- these are defined in SysV curses, but
+   are not well-supported by most terminals. Stick to VT100 characters
+   for optimum portability. */
+
+#define ACS_LARROW    ACS_PICK(',', '<')
+#define ACS_RARROW    ACS_PICK('+', '>')
+#define ACS_DARROW    ACS_PICK('.', 'v')
+#define ACS_UARROW    ACS_PICK('-', '^')
+#define ACS_BOARD     ACS_PICK('h', '#')
+#define ACS_LANTERN   ACS_PICK('i', '*')
+#define ACS_BLOCK     ACS_PICK('0', '#')
+
+/* That goes double for these -- undocumented SysV symbols. Don't use
+   them. */
+
+#define ACS_S3        ACS_PICK('p', '-')
+#define ACS_S7        ACS_PICK('r', '-')
+#define ACS_LEQUAL    ACS_PICK('y', '<')
+#define ACS_GEQUAL    ACS_PICK('z', '>')
+#define ACS_PI        ACS_PICK('{', 'n')
+#define ACS_NEQUAL    ACS_PICK('|', '+')
+#define ACS_STERLING  ACS_PICK('}', 'L')
+
+/* Box char aliases */
+
+#define ACS_BSSB      ACS_ULCORNER
+#define ACS_SSBB      ACS_LLCORNER
+#define ACS_BBSS      ACS_URCORNER
+#define ACS_SBBS      ACS_LRCORNER
+#define ACS_SBSS      ACS_RTEE
+#define ACS_SSSB      ACS_LTEE
+#define ACS_SSBS      ACS_BTEE
+#define ACS_BSSS      ACS_TTEE
+#define ACS_BSBS      ACS_HLINE
+#define ACS_SBSB      ACS_VLINE
+#define ACS_SSSS      ACS_PLUS
+
+/* cchar_t aliases */
+
+#ifdef PDC_WIDE
+# define WACS_ULCORNER (&(acs_map['l']))
+# define WACS_LLCORNER (&(acs_map['m']))
+# define WACS_URCORNER (&(acs_map['k']))
+# define WACS_LRCORNER (&(acs_map['j']))
+# define WACS_RTEE     (&(acs_map['u']))
+# define WACS_LTEE     (&(acs_map['t']))
+# define WACS_BTEE     (&(acs_map['v']))
+# define WACS_TTEE     (&(acs_map['w']))
+# define WACS_HLINE    (&(acs_map['q']))
+# define WACS_VLINE    (&(acs_map['x']))
+# define WACS_PLUS     (&(acs_map['n']))
+
+# define WACS_S1       (&(acs_map['o']))
+# define WACS_S9       (&(acs_map['s']))
+# define WACS_DIAMOND  (&(acs_map['`']))
+# define WACS_CKBOARD  (&(acs_map['a']))
+# define WACS_DEGREE   (&(acs_map['f']))
+# define WACS_PLMINUS  (&(acs_map['g']))
+# define WACS_BULLET   (&(acs_map['~']))
+
+# define WACS_LARROW   (&(acs_map[',']))
+# define WACS_RARROW   (&(acs_map['+']))
+# define WACS_DARROW   (&(acs_map['.']))
+# define WACS_UARROW   (&(acs_map['-']))
+# define WACS_BOARD    (&(acs_map['h']))
+# define WACS_LANTERN  (&(acs_map['i']))
+# define WACS_BLOCK    (&(acs_map['0']))
+
+# define WACS_S3       (&(acs_map['p']))
+# define WACS_S7       (&(acs_map['r']))
+# define WACS_LEQUAL   (&(acs_map['y']))
+# define WACS_GEQUAL   (&(acs_map['z']))
+# define WACS_PI       (&(acs_map['{']))
+# define WACS_NEQUAL   (&(acs_map['|']))
+# define WACS_STERLING (&(acs_map['}']))
+
+# define WACS_BSSB     WACS_ULCORNER
+# define WACS_SSBB     WACS_LLCORNER
+# define WACS_BBSS     WACS_URCORNER
+# define WACS_SBBS     WACS_LRCORNER
+# define WACS_SBSS     WACS_RTEE
+# define WACS_SSSB     WACS_LTEE
+# define WACS_SSBS     WACS_BTEE
+# define WACS_BSSS     WACS_TTEE
+# define WACS_BSBS     WACS_HLINE
+# define WACS_SBSB     WACS_VLINE
+# define WACS_SSSS     WACS_PLUS
+#endif
+
+/*** Color macros ***/
+
+#define COLOR_BLACK   0
+
+#ifdef PDC_RGB        /* RGB */
+# define COLOR_RED    1
+# define COLOR_GREEN  2
+# define COLOR_BLUE   4
+#else                 /* BGR */
+# define COLOR_BLUE   1
+# define COLOR_GREEN  2
+# define COLOR_RED    4
+#endif
+
+#define COLOR_CYAN    (COLOR_BLUE | COLOR_GREEN)
+#define COLOR_MAGENTA (COLOR_RED | COLOR_BLUE)
+#define COLOR_YELLOW  (COLOR_RED | COLOR_GREEN)
+
+#define COLOR_WHITE   7
+
+/*----------------------------------------------------------------------
+ *
+ *  Function and Keypad Key Definitions.
+ *  Many are just for compatibility.
+ *
+ */
+
+#define KEY_CODE_YES  0x100  /* If get_wch() gives a key code */
+
+#define KEY_BREAK     0x101  /* Not on PC KBD */
+#define KEY_DOWN      0x102  /* Down arrow key */
+#define KEY_UP        0x103  /* Up arrow key */
+#define KEY_LEFT      0x104  /* Left arrow key */
+#define KEY_RIGHT     0x105  /* Right arrow key */
+#define KEY_HOME      0x106  /* home key */
+#define KEY_BACKSPACE 0x107  /* not on pc */
+#define KEY_F0        0x108  /* function keys; 64 reserved */
+
+#define KEY_DL        0x148  /* delete line */
+#define KEY_IL        0x149  /* insert line */
+#define KEY_DC        0x14a  /* delete character */
+#define KEY_IC        0x14b  /* insert char or enter ins mode */
+#define KEY_EIC       0x14c  /* exit insert char mode */
+#define KEY_CLEAR     0x14d  /* clear screen */
+#define KEY_EOS       0x14e  /* clear to end of screen */
+#define KEY_EOL       0x14f  /* clear to end of line */
+#define KEY_SF        0x150  /* scroll 1 line forward */
+#define KEY_SR        0x151  /* scroll 1 line back (reverse) */
+#define KEY_NPAGE     0x152  /* next page */
+#define KEY_PPAGE     0x153  /* previous page */
+#define KEY_STAB      0x154  /* set tab */
+#define KEY_CTAB      0x155  /* clear tab */
+#define KEY_CATAB     0x156  /* clear all tabs */
+#define KEY_ENTER     0x157  /* enter or send (unreliable) */
+#define KEY_SRESET    0x158  /* soft/reset (partial/unreliable) */
+#define KEY_RESET     0x159  /* reset/hard reset (unreliable) */
+#define KEY_PRINT     0x15a  /* print/copy */
+#define KEY_LL        0x15b  /* home down/bottom (lower left) */
+#define KEY_ABORT     0x15c  /* abort/terminate key (any) */
+#define KEY_SHELP     0x15d  /* short help */
+#define KEY_LHELP     0x15e  /* long help */
+#define KEY_BTAB      0x15f  /* Back tab key */
+#define KEY_BEG       0x160  /* beg(inning) key */
+#define KEY_CANCEL    0x161  /* cancel key */
+#define KEY_CLOSE     0x162  /* close key */
+#define KEY_COMMAND   0x163  /* cmd (command) key */
+#define KEY_COPY      0x164  /* copy key */
+#define KEY_CREATE    0x165  /* create key */
+#define KEY_END       0x166  /* end key */
+#define KEY_EXIT      0x167  /* exit key */
+#define KEY_FIND      0x168  /* find key */
+#define KEY_HELP      0x169  /* help key */
+#define KEY_MARK      0x16a  /* mark key */
+#define KEY_MESSAGE   0x16b  /* message key */
+#define KEY_MOVE      0x16c  /* move key */
+#define KEY_NEXT      0x16d  /* next object key */
+#define KEY_OPEN      0x16e  /* open key */
+#define KEY_OPTIONS   0x16f  /* options key */
+#define KEY_PREVIOUS  0x170  /* previous object key */
+#define KEY_REDO      0x171  /* redo key */
+#define KEY_REFERENCE 0x172  /* ref(erence) key */
+#define KEY_REFRESH   0x173  /* refresh key */
+#define KEY_REPLACE   0x174  /* replace key */
+#define KEY_RESTART   0x175  /* restart key */
+#define KEY_RESUME    0x176  /* resume key */
+#define KEY_SAVE      0x177  /* save key */
+#define KEY_SBEG      0x178  /* shifted beginning key */
+#define KEY_SCANCEL   0x179  /* shifted cancel key */
+#define KEY_SCOMMAND  0x17a  /* shifted command key */
+#define KEY_SCOPY     0x17b  /* shifted copy key */
+#define KEY_SCREATE   0x17c  /* shifted create key */
+#define KEY_SDC       0x17d  /* shifted delete char key */
+#define KEY_SDL       0x17e  /* shifted delete line key */
+#define KEY_SELECT    0x17f  /* select key */
+#define KEY_SEND      0x180  /* shifted end key */
+#define KEY_SEOL      0x181  /* shifted clear line key */
+#define KEY_SEXIT     0x182  /* shifted exit key */
+#define KEY_SFIND     0x183  /* shifted find key */
+#define KEY_SHOME     0x184  /* shifted home key */
+#define KEY_SIC       0x185  /* shifted input key */
+
+#define KEY_SLEFT     0x187  /* shifted left arrow key */
+#define KEY_SMESSAGE  0x188  /* shifted message key */
+#define KEY_SMOVE     0x189  /* shifted move key */
+#define KEY_SNEXT     0x18a  /* shifted next key */
+#define KEY_SOPTIONS  0x18b  /* shifted options key */
+#define KEY_SPREVIOUS 0x18c  /* shifted prev key */
+#define KEY_SPRINT    0x18d  /* shifted print key */
+#define KEY_SREDO     0x18e  /* shifted redo key */
+#define KEY_SREPLACE  0x18f  /* shifted replace key */
+#define KEY_SRIGHT    0x190  /* shifted right arrow */
+#define KEY_SRSUME    0x191  /* shifted resume key */
+#define KEY_SSAVE     0x192  /* shifted save key */
+#define KEY_SSUSPEND  0x193  /* shifted suspend key */
+#define KEY_SUNDO     0x194  /* shifted undo key */
+#define KEY_SUSPEND   0x195  /* suspend key */
+#define KEY_UNDO      0x196  /* undo key */
+
+/* PDCurses-specific key definitions -- PC only */
+
+#define ALT_0         0x197
+#define ALT_1         0x198
+#define ALT_2         0x199
+#define ALT_3         0x19a
+#define ALT_4         0x19b
+#define ALT_5         0x19c
+#define ALT_6         0x19d
+#define ALT_7         0x19e
+#define ALT_8         0x19f
+#define ALT_9         0x1a0
+#define ALT_A         0x1a1
+#define ALT_B         0x1a2
+#define ALT_C         0x1a3
+#define ALT_D         0x1a4
+#define ALT_E         0x1a5
+#define ALT_F         0x1a6
+#define ALT_G         0x1a7
+#define ALT_H         0x1a8
+#define ALT_I         0x1a9
+#define ALT_J         0x1aa
+#define ALT_K         0x1ab
+#define ALT_L         0x1ac
+#define ALT_M         0x1ad
+#define ALT_N         0x1ae
+#define ALT_O         0x1af
+#define ALT_P         0x1b0
+#define ALT_Q         0x1b1
+#define ALT_R         0x1b2
+#define ALT_S         0x1b3
+#define ALT_T         0x1b4
+#define ALT_U         0x1b5
+#define ALT_V         0x1b6
+#define ALT_W         0x1b7
+#define ALT_X         0x1b8
+#define ALT_Y         0x1b9
+#define ALT_Z         0x1ba
+
+#define CTL_LEFT      0x1bb  /* Control-Left-Arrow */
+#define CTL_RIGHT     0x1bc
+#define CTL_PGUP      0x1bd
+#define CTL_PGDN      0x1be
+#define CTL_HOME      0x1bf
+#define CTL_END       0x1c0
+
+#define KEY_A1        0x1c1  /* upper left on Virtual keypad */
+#define KEY_A2        0x1c2  /* upper middle on Virt. keypad */
+#define KEY_A3        0x1c3  /* upper right on Vir. keypad */
+#define KEY_B1        0x1c4  /* middle left on Virt. keypad */
+#define KEY_B2        0x1c5  /* center on Virt. keypad */
+#define KEY_B3        0x1c6  /* middle right on Vir. keypad */
+#define KEY_C1        0x1c7  /* lower left on Virt. keypad */
+#define KEY_C2        0x1c8  /* lower middle on Virt. keypad */
+#define KEY_C3        0x1c9  /* lower right on Vir. keypad */
+
+#define PADSLASH      0x1ca  /* slash on keypad */
+#define PADENTER      0x1cb  /* enter on keypad */
+#define CTL_PADENTER  0x1cc  /* ctl-enter on keypad */
+#define ALT_PADENTER  0x1cd  /* alt-enter on keypad */
+#define PADSTOP       0x1ce  /* stop on keypad */
+#define PADSTAR       0x1cf  /* star on keypad */
+#define PADMINUS      0x1d0  /* minus on keypad */
+#define PADPLUS       0x1d1  /* plus on keypad */
+#define CTL_PADSTOP   0x1d2  /* ctl-stop on keypad */
+#define CTL_PADCENTER 0x1d3  /* ctl-enter on keypad */
+#define CTL_PADPLUS   0x1d4  /* ctl-plus on keypad */
+#define CTL_PADMINUS  0x1d5  /* ctl-minus on keypad */
+#define CTL_PADSLASH  0x1d6  /* ctl-slash on keypad */
+#define CTL_PADSTAR   0x1d7  /* ctl-star on keypad */
+#define ALT_PADPLUS   0x1d8  /* alt-plus on keypad */
+#define ALT_PADMINUS  0x1d9  /* alt-minus on keypad */
+#define ALT_PADSLASH  0x1da  /* alt-slash on keypad */
+#define ALT_PADSTAR   0x1db  /* alt-star on keypad */
+#define ALT_PADSTOP   0x1dc  /* alt-stop on keypad */
+#define CTL_INS       0x1dd  /* ctl-insert */
+#define ALT_DEL       0x1de  /* alt-delete */
+#define ALT_INS       0x1df  /* alt-insert */
+#define CTL_UP        0x1e0  /* ctl-up arrow */
+#define CTL_DOWN      0x1e1  /* ctl-down arrow */
+#define CTL_TAB       0x1e2  /* ctl-tab */
+#define ALT_TAB       0x1e3
+#define ALT_MINUS     0x1e4
+#define ALT_EQUAL     0x1e5
+#define ALT_HOME      0x1e6
+#define ALT_PGUP      0x1e7
+#define ALT_PGDN      0x1e8
+#define ALT_END       0x1e9
+#define ALT_UP        0x1ea  /* alt-up arrow */
+#define ALT_DOWN      0x1eb  /* alt-down arrow */
+#define ALT_RIGHT     0x1ec  /* alt-right arrow */
+#define ALT_LEFT      0x1ed  /* alt-left arrow */
+#define ALT_ENTER     0x1ee  /* alt-enter */
+#define ALT_ESC       0x1ef  /* alt-escape */
+#define ALT_BQUOTE    0x1f0  /* alt-back quote */
+#define ALT_LBRACKET  0x1f1  /* alt-left bracket */
+#define ALT_RBRACKET  0x1f2  /* alt-right bracket */
+#define ALT_SEMICOLON 0x1f3  /* alt-semi-colon */
+#define ALT_FQUOTE    0x1f4  /* alt-forward quote */
+#define ALT_COMMA     0x1f5  /* alt-comma */
+#define ALT_STOP      0x1f6  /* alt-stop */
+#define ALT_FSLASH    0x1f7  /* alt-forward slash */
+#define ALT_BKSP      0x1f8  /* alt-backspace */
+#define CTL_BKSP      0x1f9  /* ctl-backspace */
+#define PAD0          0x1fa  /* keypad 0 */
+
+#define CTL_PAD0      0x1fb  /* ctl-keypad 0 */
+#define CTL_PAD1      0x1fc
+#define CTL_PAD2      0x1fd
+#define CTL_PAD3      0x1fe
+#define CTL_PAD4      0x1ff
+#define CTL_PAD5      0x200
+#define CTL_PAD6      0x201
+#define CTL_PAD7      0x202
+#define CTL_PAD8      0x203
+#define CTL_PAD9      0x204
+
+#define ALT_PAD0      0x205  /* alt-keypad 0 */
+#define ALT_PAD1      0x206
+#define ALT_PAD2      0x207
+#define ALT_PAD3      0x208
+#define ALT_PAD4      0x209
+#define ALT_PAD5      0x20a
+#define ALT_PAD6      0x20b
+#define ALT_PAD7      0x20c
+#define ALT_PAD8      0x20d
+#define ALT_PAD9      0x20e
+
+#define CTL_DEL       0x20f  /* clt-delete */
+#define ALT_BSLASH    0x210  /* alt-back slash */
+#define CTL_ENTER     0x211  /* ctl-enter */
+
+#define SHF_PADENTER  0x212  /* shift-enter on keypad */
+#define SHF_PADSLASH  0x213  /* shift-slash on keypad */
+#define SHF_PADSTAR   0x214  /* shift-star  on keypad */
+#define SHF_PADPLUS   0x215  /* shift-plus  on keypad */
+#define SHF_PADMINUS  0x216  /* shift-minus on keypad */
+#define SHF_UP        0x217  /* shift-up on keypad */
+#define SHF_DOWN      0x218  /* shift-down on keypad */
+#define SHF_IC        0x219  /* shift-insert on keypad */
+#define SHF_DC        0x21a  /* shift-delete on keypad */
+
+#define KEY_MOUSE     0x21b  /* "mouse" key */
+#define KEY_SHIFT_L   0x21c  /* Left-shift */
+#define KEY_SHIFT_R   0x21d  /* Right-shift */
+#define KEY_CONTROL_L 0x21e  /* Left-control */
+#define KEY_CONTROL_R 0x21f  /* Right-control */
+#define KEY_ALT_L     0x220  /* Left-alt */
+#define KEY_ALT_R     0x221  /* Right-alt */
+#define KEY_RESIZE    0x222  /* Window resize */
+#define KEY_SUP       0x223  /* Shifted up arrow */
+#define KEY_SDOWN     0x224  /* Shifted down arrow */
+
+#define KEY_MIN       KEY_BREAK      /* Minimum curses key value */
+#define KEY_MAX       KEY_SDOWN      /* Maximum curses key */
+
+#define KEY_F(n)      (KEY_F0 + (n))
+
+/*----------------------------------------------------------------------
+ *
+ *  PDCurses Function Declarations
+ *
+ */
+
+/* Standard */
+
+int     addch(const chtype);
+int     addchnstr(const chtype *, int);
+int     addchstr(const chtype *);
+int     addnstr(const char *, int);
+int     addstr(const char *);
+int     attroff(chtype);
+int     attron(chtype);
+int     attrset(chtype);
+int     attr_get(attr_t *, short *, void *);
+int     attr_off(attr_t, void *);
+int     attr_on(attr_t, void *);
+int     attr_set(attr_t, short, void *);
+int     baudrate(void);
+int     beep(void);
+int     bkgd(chtype);
+void    bkgdset(chtype);
+int     border(chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype);
+int     box(WINDOW *, chtype, chtype);
+bool    can_change_color(void);
+int     cbreak(void); 
+int     chgat(int, attr_t, short, const void *);
+int     clearok(WINDOW *, bool);
+int     clear(void);
+int     clrtobot(void);
+int     clrtoeol(void);
+int     color_content(short, short *, short *, short *);
+int     color_set(short, void *);
+int     copywin(const WINDOW *, WINDOW *, int, int, int, int, int, int, int);
+int     curs_set(int);
+int     def_prog_mode(void);
+int     def_shell_mode(void);
+int     delay_output(int);
+int     delch(void);
+int     deleteln(void);
+void    delscreen(SCREEN *); 
+int     delwin(WINDOW *);
+WINDOW *derwin(WINDOW *, int, int, int, int);
+int     doupdate(void);
+WINDOW *dupwin(WINDOW *);
+int     echochar(const chtype);
+int     echo(void);
+int     endwin(void);
+char    erasechar(void);
+int     erase(void);
+void    filter(void);
+int     flash(void);
+int     flushinp(void);
+chtype  getbkgd(WINDOW *);
+int     getnstr(char *, int);
+int     getstr(char *);
+WINDOW *getwin(FILE *);
+int     halfdelay(int);
+bool    has_colors(void);
+bool    has_ic(void);
+bool    has_il(void);
+int     hline(chtype, int);
+void    idcok(WINDOW *, bool);
+int     idlok(WINDOW *, bool);
+void    immedok(WINDOW *, bool);
+int     inchnstr(chtype *, int);
+int     inchstr(chtype *);
+chtype  inch(void);
+int     init_color(short, short, short, short);
+int     init_pair(short, short, short);
+WINDOW *initscr(void);
+int     innstr(char *, int);
+int     insch(chtype);
+int     insdelln(int);
+int     insertln(void);
+int     insnstr(const char *, int);
+int     insstr(const char *);
+int     instr(char *);
+int     intrflush(WINDOW *, bool);
+bool    isendwin(void);
+bool    is_linetouched(WINDOW *, int);
+bool    is_wintouched(WINDOW *);
+char   *keyname(int);
+int     keypad(WINDOW *, bool);
+char    killchar(void);
+int     leaveok(WINDOW *, bool);
+char   *longname(void);
+int     meta(WINDOW *, bool);
+int     move(int, int);
+int     mvaddch(int, int, const chtype);
+int     mvaddchnstr(int, int, const chtype *, int);
+int     mvaddchstr(int, int, const chtype *);
+int     mvaddnstr(int, int, const char *, int);
+int     mvaddstr(int, int, const char *);
+int     mvchgat(int, int, int, attr_t, short, const void *);
+int     mvcur(int, int, int, int);
+int     mvdelch(int, int);
+int     mvderwin(WINDOW *, int, int);
+int     mvgetch(int, int);
+int     mvgetnstr(int, int, char *, int);
+int     mvgetstr(int, int, char *);
+int     mvhline(int, int, chtype, int);
+chtype  mvinch(int, int);
+int     mvinchnstr(int, int, chtype *, int);
+int     mvinchstr(int, int, chtype *);
+int     mvinnstr(int, int, char *, int);
+int     mvinsch(int, int, chtype);
+int     mvinsnstr(int, int, const char *, int);
+int     mvinsstr(int, int, const char *);
+int     mvinstr(int, int, char *);
+int     mvprintw(int, int, const char *, ...);
+int     mvscanw(int, int, const char *, ...);
+int     mvvline(int, int, chtype, int);
+int     mvwaddchnstr(WINDOW *, int, int, const chtype *, int);
+int     mvwaddchstr(WINDOW *, int, int, const chtype *);
+int     mvwaddch(WINDOW *, int, int, const chtype);
+int     mvwaddnstr(WINDOW *, int, int, const char *, int);
+int     mvwaddstr(WINDOW *, int, int, const char *);
+int     mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);
+int     mvwdelch(WINDOW *, int, int);
+int     mvwgetch(WINDOW *, int, int);
+int     mvwgetnstr(WINDOW *, int, int, char *, int);
+int     mvwgetstr(WINDOW *, int, int, char *);
+int     mvwhline(WINDOW *, int, int, chtype, int);
+int     mvwinchnstr(WINDOW *, int, int, chtype *, int);
+int     mvwinchstr(WINDOW *, int, int, chtype *);
+chtype  mvwinch(WINDOW *, int, int);
+int     mvwinnstr(WINDOW *, int, int, char *, int);
+int     mvwinsch(WINDOW *, int, int, chtype);
+int     mvwinsnstr(WINDOW *, int, int, const char *, int);
+int     mvwinsstr(WINDOW *, int, int, const char *);
+int     mvwinstr(WINDOW *, int, int, char *);
+int     mvwin(WINDOW *, int, int);
+int     mvwprintw(WINDOW *, int, int, const char *, ...);
+int     mvwscanw(WINDOW *, int, int, const char *, ...);
+int     mvwvline(WINDOW *, int, int, chtype, int);
+int     napms(int);
+WINDOW *newpad(int, int);
+SCREEN *newterm(const char *, FILE *, FILE *);
+WINDOW *newwin(int, int, int, int);
+int     nl(void);
+int     nocbreak(void);
+int     nodelay(WINDOW *, bool);
+int     noecho(void);
+int     nonl(void);
+void    noqiflush(void);
+int     noraw(void);
+int     notimeout(WINDOW *, bool);
+int     overlay(const WINDOW *, WINDOW *);
+int     overwrite(const WINDOW *, WINDOW *);
+int     pair_content(short, short *, short *);
+int     pechochar(WINDOW *, chtype);
+int     pnoutrefresh(WINDOW *, int, int, int, int, int, int);
+int     prefresh(WINDOW *, int, int, int, int, int, int);
+int     printw(const char *, ...);
+int     putwin(WINDOW *, FILE *);
+void    qiflush(void);
+int     raw(void);
+int     redrawwin(WINDOW *);
+int     refresh(void);
+int     reset_prog_mode(void);
+int     reset_shell_mode(void);
+int     resetty(void);
+int     ripoffline(int, int (*)(WINDOW *, int));
+int     savetty(void);
+int     scanw(const char *, ...);
+int     scr_dump(const char *);
+int     scr_init(const char *);
+int     scr_restore(const char *);
+int     scr_set(const char *);
+int     scrl(int);
+int     scroll(WINDOW *);
+int     scrollok(WINDOW *, bool);
+SCREEN *set_term(SCREEN *);
+int     setscrreg(int, int);
+int     slk_attroff(const chtype);
+int     slk_attr_off(const attr_t, void *);
+int     slk_attron(const chtype);
+int     slk_attr_on(const attr_t, void *);
+int     slk_attrset(const chtype);
+int     slk_attr_set(const attr_t, short, void *);
+int     slk_clear(void);
+int     slk_color(short);
+int     slk_init(int);
+char   *slk_label(int);
+int     slk_noutrefresh(void);
+int     slk_refresh(void);
+int     slk_restore(void);
+int     slk_set(int, const char *, int);
+int     slk_touch(void);
+int     standend(void);
+int     standout(void);
+int     start_color(void);
+WINDOW *subpad(WINDOW *, int, int, int, int);
+WINDOW *subwin(WINDOW *, int, int, int, int);
+int     syncok(WINDOW *, bool);
+chtype  termattrs(void);
+attr_t  term_attrs(void);
+char   *termname(void);
+void    timeout(int);
+int     touchline(WINDOW *, int, int);
+int     touchwin(WINDOW *);
+int     typeahead(int);
+int     untouchwin(WINDOW *);
+void    use_env(bool);
+int     vidattr(chtype);
+int     vid_attr(attr_t, short, void *);
+int     vidputs(chtype, int (*)(int));
+int     vid_puts(attr_t, short, void *, int (*)(int));
+int     vline(chtype, int);
+int     vw_printw(WINDOW *, const char *, va_list);
+int     vwprintw(WINDOW *, const char *, va_list);
+int     vw_scanw(WINDOW *, const char *, va_list);
+int     vwscanw(WINDOW *, const char *, va_list);
+int     waddchnstr(WINDOW *, const chtype *, int);
+int     waddchstr(WINDOW *, const chtype *);
+int     waddch(WINDOW *, const chtype);
+int     waddnstr(WINDOW *, const char *, int);
+int     waddstr(WINDOW *, const char *);
+int     wattroff(WINDOW *, chtype);
+int     wattron(WINDOW *, chtype);
+int     wattrset(WINDOW *, chtype);
+int     wattr_get(WINDOW *, attr_t *, short *, void *);
+int     wattr_off(WINDOW *, attr_t, void *);
+int     wattr_on(WINDOW *, attr_t, void *);
+int     wattr_set(WINDOW *, attr_t, short, void *);
+void    wbkgdset(WINDOW *, chtype);
+int     wbkgd(WINDOW *, chtype);
+int     wborder(WINDOW *, chtype, chtype, chtype, chtype,
+                chtype, chtype, chtype, chtype);
+int     wchgat(WINDOW *, int, attr_t, short, const void *);
+int     wclear(WINDOW *);
+int     wclrtobot(WINDOW *);
+int     wclrtoeol(WINDOW *);
+int     wcolor_set(WINDOW *, short, void *);
+void    wcursyncup(WINDOW *);
+int     wdelch(WINDOW *);
+int     wdeleteln(WINDOW *);
+int     wechochar(WINDOW *, const chtype);
+int     werase(WINDOW *);
+int     wgetch(WINDOW *);
+int     wgetnstr(WINDOW *, char *, int);
+int     wgetstr(WINDOW *, char *);
+int     whline(WINDOW *, chtype, int);
+int     winchnstr(WINDOW *, chtype *, int);
+int     winchstr(WINDOW *, chtype *);
+chtype  winch(WINDOW *);
+int     winnstr(WINDOW *, char *, int);
+int     winsch(WINDOW *, chtype);
+int     winsdelln(WINDOW *, int);
+int     winsertln(WINDOW *);
+int     winsnstr(WINDOW *, const char *, int);
+int     winsstr(WINDOW *, const char *);
+int     winstr(WINDOW *, char *);
+int     wmove(WINDOW *, int, int);
+int     wnoutrefresh(WINDOW *);
+int     wprintw(WINDOW *, const char *, ...);
+int     wredrawln(WINDOW *, int, int);
+int     wrefresh(WINDOW *);
+int     wscanw(WINDOW *, const char *, ...);
+int     wscrl(WINDOW *, int);
+int     wsetscrreg(WINDOW *, int, int);
+int     wstandend(WINDOW *);
+int     wstandout(WINDOW *);
+void    wsyncdown(WINDOW *);
+void    wsyncup(WINDOW *);
+void    wtimeout(WINDOW *, int);
+int     wtouchln(WINDOW *, int, int, int);
+int     wvline(WINDOW *, chtype, int);
+
+/* Wide-character functions */
+
+#ifdef PDC_WIDE
+int     addnwstr(const wchar_t *, int);
+int     addwstr(const wchar_t *);
+int     add_wch(const cchar_t *);
+int     add_wchnstr(const cchar_t *, int);
+int     add_wchstr(const cchar_t *);
+int     border_set(const cchar_t *, const cchar_t *, const cchar_t *, 
+                   const cchar_t *, const cchar_t *, const cchar_t *, 
+                   const cchar_t *, const cchar_t *);
+int     box_set(WINDOW *, const cchar_t *, const cchar_t *);
+int     echo_wchar(const cchar_t *);
+int     erasewchar(wchar_t *);
+int     getbkgrnd(cchar_t *);
+int     getcchar(const cchar_t *, wchar_t *, attr_t *, short *, void *);
+int     getn_wstr(wint_t *, int);
+int     get_wch(wint_t *);
+int     get_wstr(wint_t *);
+int     hline_set(const cchar_t *, int);
+int     innwstr(wchar_t *, int);
+int     ins_nwstr(const wchar_t *, int);
+int     ins_wch(const cchar_t *);
+int     ins_wstr(const wchar_t *);
+int     inwstr(wchar_t *);
+int     in_wch(cchar_t *);
+int     in_wchnstr(cchar_t *, int);
+int     in_wchstr(cchar_t *);
+char   *key_name(wchar_t);
+int     killwchar(wchar_t *);
+int     mvaddnwstr(int, int, const wchar_t *, int);
+int     mvaddwstr(int, int, const wchar_t *);
+int     mvadd_wch(int, int, const cchar_t *);
+int     mvadd_wchnstr(int, int, const cchar_t *, int);
+int     mvadd_wchstr(int, int, const cchar_t *);
+int     mvgetn_wstr(int, int, wint_t *, int);
+int     mvget_wch(int, int, wint_t *);
+int     mvget_wstr(int, int, wint_t *);
+int     mvhline_set(int, int, const cchar_t *, int);
+int     mvinnwstr(int, int, wchar_t *, int);
+int     mvins_nwstr(int, int, const wchar_t *, int);
+int     mvins_wch(int, int, const cchar_t *);
+int     mvins_wstr(int, int, const wchar_t *);
+int     mvinwstr(int, int, wchar_t *);
+int     mvin_wch(int, int, cchar_t *);
+int     mvin_wchnstr(int, int, cchar_t *, int);
+int     mvin_wchstr(int, int, cchar_t *);
+int     mvvline_set(int, int, const cchar_t *, int);
+int     mvwaddnwstr(WINDOW *, int, int, const wchar_t *, int);
+int     mvwaddwstr(WINDOW *, int, int, const wchar_t *);
+int     mvwadd_wch(WINDOW *, int, int, const cchar_t *);
+int     mvwadd_wchnstr(WINDOW *, int, int, const cchar_t *, int);
+int     mvwadd_wchstr(WINDOW *, int, int, const cchar_t *);
+int     mvwgetn_wstr(WINDOW *, int, int, wint_t *, int);
+int     mvwget_wch(WINDOW *, int, int, wint_t *);
+int     mvwget_wstr(WINDOW *, int, int, wint_t *);
+int     mvwhline_set(WINDOW *, int, int, const cchar_t *, int);
+int     mvwinnwstr(WINDOW *, int, int, wchar_t *, int);
+int     mvwins_nwstr(WINDOW *, int, int, const wchar_t *, int);
+int     mvwins_wch(WINDOW *, int, int, const cchar_t *);
+int     mvwins_wstr(WINDOW *, int, int, const wchar_t *);
+int     mvwin_wch(WINDOW *, int, int, cchar_t *);
+int     mvwin_wchnstr(WINDOW *, int, int, cchar_t *, int);
+int     mvwin_wchstr(WINDOW *, int, int, cchar_t *);
+int     mvwinwstr(WINDOW *, int, int, wchar_t *);
+int     mvwvline_set(WINDOW *, int, int, const cchar_t *, int);
+int     pecho_wchar(WINDOW *, const cchar_t*);
+int     setcchar(cchar_t*, const wchar_t*, const attr_t, short, const void*);
+int     slk_wset(int, const wchar_t *, int);
+int     unget_wch(const wchar_t);
+int     vline_set(const cchar_t *, int);
+int     waddnwstr(WINDOW *, const wchar_t *, int);
+int     waddwstr(WINDOW *, const wchar_t *);
+int     wadd_wch(WINDOW *, const cchar_t *);
+int     wadd_wchnstr(WINDOW *, const cchar_t *, int);
+int     wadd_wchstr(WINDOW *, const cchar_t *);
+int     wbkgrnd(WINDOW *, const cchar_t *);
+void    wbkgrndset(WINDOW *, const cchar_t *);
+int     wborder_set(WINDOW *, const cchar_t *, const cchar_t *,
+                    const cchar_t *, const cchar_t *, const cchar_t *, 
+                    const cchar_t *, const cchar_t *, const cchar_t *);
+int     wecho_wchar(WINDOW *, const cchar_t *);
+int     wgetbkgrnd(WINDOW *, cchar_t *);
+int     wgetn_wstr(WINDOW *, wint_t *, int);
+int     wget_wch(WINDOW *, wint_t *);
+int     wget_wstr(WINDOW *, wint_t *);
+int     whline_set(WINDOW *, const cchar_t *, int);
+int     winnwstr(WINDOW *, wchar_t *, int);
+int     wins_nwstr(WINDOW *, const wchar_t *, int);
+int     wins_wch(WINDOW *, const cchar_t *);
+int     wins_wstr(WINDOW *, const wchar_t *);
+int     winwstr(WINDOW *, wchar_t *);
+int     win_wch(WINDOW *, cchar_t *);
+int     win_wchnstr(WINDOW *, cchar_t *, int);
+int     win_wchstr(WINDOW *, cchar_t *);
+wchar_t *wunctrl(cchar_t *);
+int     wvline_set(WINDOW *, const cchar_t *, int);
+#endif
+
+/* Quasi-standard */
+
+chtype  getattrs(WINDOW *);
+int     getbegx(WINDOW *);
+int     getbegy(WINDOW *);
+int     getmaxx(WINDOW *);
+int     getmaxy(WINDOW *);
+int     getparx(WINDOW *);
+int     getpary(WINDOW *);
+int     getcurx(WINDOW *);
+int     getcury(WINDOW *);
+void    traceoff(void);
+void    traceon(void);
+char   *unctrl(chtype);
+
+int     crmode(void);
+int     nocrmode(void);
+int     draino(int);
+int     resetterm(void);
+int     fixterm(void);
+int     saveterm(void);
+int     setsyx(int, int);
+
+int     mouse_set(unsigned long);
+int     mouse_on(unsigned long);
+int     mouse_off(unsigned long);
+int     request_mouse_pos(void);
+int     map_button(unsigned long);
+void    wmouse_position(WINDOW *, int *, int *);
+unsigned long getmouse(void);
+unsigned long getbmap(void);
+
+/* ncurses */
+
+int     assume_default_colors(int, int);
+const char *curses_version(void);
+bool    has_key(int);
+int     use_default_colors(void);
+int     wresize(WINDOW *, int, int);
+
+int     mouseinterval(int);
+mmask_t mousemask(mmask_t, mmask_t *);
+bool    mouse_trafo(int *, int *, bool);
+int     nc_getmouse(MEVENT *);
+int     ungetmouse(MEVENT *);
+bool    wenclose(const WINDOW *, int, int);
+bool    wmouse_trafo(const WINDOW *, int *, int *, bool);
+
+/* PDCurses */
+
+int     addrawch(chtype);
+int     insrawch(chtype);
+bool    is_termresized(void);
+int     mvaddrawch(int, int, chtype);
+int     mvdeleteln(int, int);
+int     mvinsertln(int, int);
+int     mvinsrawch(int, int, chtype);
+int     mvwaddrawch(WINDOW *, int, int, chtype);
+int     mvwdeleteln(WINDOW *, int, int);
+int     mvwinsertln(WINDOW *, int, int);
+int     mvwinsrawch(WINDOW *, int, int, chtype);
+int     raw_output(bool);
+int     resize_term(int, int);
+WINDOW *resize_window(WINDOW *, int, int);
+int     waddrawch(WINDOW *, chtype);
+int     winsrawch(WINDOW *, chtype);
+char    wordchar(void);
+
+#ifdef PDC_WIDE
+wchar_t *slk_wlabel(int);
+#endif
+
+void    PDC_debug(const char *, ...);
+int     PDC_ungetch(int);
+int     PDC_set_blink(bool);
+int     PDC_set_line_color(short);
+void    PDC_set_title(const char *);
+
+int     PDC_clearclipboard(void);
+int     PDC_freeclipboard(char *);
+int     PDC_getclipboard(char **, long *);
+int     PDC_setclipboard(const char *, long);
+
+unsigned long PDC_get_input_fd(void);
+unsigned long PDC_get_key_modifiers(void);
+int     PDC_return_key_modifiers(bool);
+int     PDC_save_key_modifiers(bool);
+
+#ifdef XCURSES
+WINDOW *Xinitscr(int, char **);
+void    XCursesExit(void);
+int     sb_init(void);
+int     sb_set_horz(int, int, int);
+int     sb_set_vert(int, int, int);
+int     sb_get_horz(int *, int *, int *);
+int     sb_get_vert(int *, int *, int *);
+int     sb_refresh(void);
+#endif
+
+/*** Functions defined as macros ***/
+
+/* getch() and ungetch() conflict with some DOS libraries */
+
+#define getch()            wgetch(stdscr)
+#define ungetch(ch)        PDC_ungetch(ch)
+
+#define COLOR_PAIR(n)      (((chtype)(n) << PDC_COLOR_SHIFT) & A_COLOR)
+#define PAIR_NUMBER(n)     (((n) & A_COLOR) >> PDC_COLOR_SHIFT)
+
+/* These will _only_ work as macros */
+
+#define getbegyx(w, y, x)  (y = getbegy(w), x = getbegx(w))
+#define getmaxyx(w, y, x)  (y = getmaxy(w), x = getmaxx(w))
+#define getparyx(w, y, x)  (y = getpary(w), x = getparx(w))
+#define getyx(w, y, x)     (y = getcury(w), x = getcurx(w))
+
+#define getsyx(y, x)       { if (curscr->_leaveit) (y)=(x)=-1; \
+                             else getyx(curscr,(y),(x)); }
+
+#ifdef NCURSES_MOUSE_VERSION
+# define getmouse(x) nc_getmouse(x)
+#endif
+
+/* return codes from PDC_getclipboard() and PDC_setclipboard() calls */
+
+#define PDC_CLIP_SUCCESS         0
+#define PDC_CLIP_ACCESS_ERROR    1
+#define PDC_CLIP_EMPTY           2
+#define PDC_CLIP_MEMORY_ERROR    3
+
+/* PDCurses key modifier masks */
+
+#define PDC_KEY_MODIFIER_SHIFT   1
+#define PDC_KEY_MODIFIER_CONTROL 2
+#define PDC_KEY_MODIFIER_ALT     4
+#define PDC_KEY_MODIFIER_NUMLOCK 8
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+# undef bool
+}
+#endif
+
+#endif  /* __PDCURSES__ */
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/win32/zconf.h b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/zconf.h
new file mode 100644
index 0000000..03a9431
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/zconf.h
@@ -0,0 +1,332 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define alloc_func            z_alloc_func
+#  define free_func             z_free_func
+#  define in_func               z_in_func
+#  define out_func              z_out_func
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
+#  include <sys/types.h> /* for off_t */
+#  include <unistd.h>    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
+#  define z_off_t off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+
+#endif /* ZCONF_H */
diff --git a/ext/samtools-0.1.7a_getUnique-0.1.3/win32/zlib.h b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/zlib.h
new file mode 100644
index 0000000..0228179
--- /dev/null
+++ b/ext/samtools-0.1.7a_getUnique-0.1.3/win32/zlib.h
@@ -0,0 +1,1357 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.3, July 18th, 2005
+
+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.3"
+#define ZLIB_VERNUM 0x1230
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with "gz".  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: binary or text */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+typedef struct gz_header_s {
+    int     text;       /* true if compressed data believed to be text */
+    uLong   time;       /* modification time */
+    int     xflags;     /* extra flags (not used when writing a gzip file) */
+    int     os;         /* operating system */
+    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
+    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
+    uInt    extra_max;  /* space at extra (only when reading header) */
+    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
+    uInt    name_max;   /* space at name (only when reading header) */
+    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
+    uInt    comm_max;   /* space at comment (only when reading header) */
+    int     hcrc;       /* true if there was or will be a header crc */
+    int     done;       /* true when done reading gzip header (not used
+                           when writing a gzip file) */
+} gz_header;
+
+typedef gz_header FAR *gz_headerp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_FIXED               4
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_TEXT     1
+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/*
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
+  decide how much data to accumualte before producing output, in order to
+  maximize compression.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out is greater than six to avoid repeated flush markers due to
+  avail_out == 0 on return.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  the value returned by deflateBound (see below). If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm->adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update strm->data_type if it can make a good guess about
+  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+  fatal, and deflate() can be called again with more input and more output
+  space to continue compressing.
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/*
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it gets to the next deflate block boundary. When decoding the
+  zlib or gzip format, this will cause inflate() to return immediately after
+  the header and before the first block. When doing a raw inflate, inflate()
+  will go ahead and process the first block, and will return when it gets to
+  the end of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm->data_type to the
+  number of unused bits in the last byte taken from strm->next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm->next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm->adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm->adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer). It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+   determines the window size. deflate() will then generate raw deflate data
+   with no zlib header or trailer, and will not compute an adler32 check value.
+
+     windowBits can also be greater than 15 for optional gzip encoding. Add
+   16 to windowBits to write a simple gzip header and trailer around the
+   compressed data instead of a zlib wrapper. The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero),
+   no header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match), or Z_RLE to limit match distances to one (run-length
+   encoding). Filtered data consists mostly of small values with a somewhat
+   random distribution. In this case, the compression algorithm is tuned to
+   compress them better. The effect of Z_FILTERED is to force more Huffman
+   coding and less string matching; it is somewhat intermediate between
+   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+   parameter only affects the compression ratio but not the correctness of the
+   compressed output even if it is not set appropriately.  Z_FIXED prevents the
+   use of dynamic Huffman codes, allowing for a simpler decoder for special
+   applications.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front. In addition, the
+   current implementation of deflate will use at most the window size minus
+   262 bytes of the provided dictionary.
+
+     Upon return of this function, strm->adler is set to the adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.) If a raw deflate was requested, then the
+   adler32 value is not computed and strm->adler is not set.
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                      int level,
+                                      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
+                                    int good_length,
+                                    int max_lazy,
+                                    int nice_length,
+                                    int max_chain));
+/*
+     Fine tune deflate's internal compression parameters.  This should only be
+   used by someone who understands the algorithm used by zlib's deflate for
+   searching for the best matching string, and even then only by the most
+   fanatic optimizer trying to squeeze out the last compressed bit for their
+   specific input data.  Read the deflate.c source code for the meaning of the
+   max_lazy, good_length, nice_length, and max_chain parameters.
+
+     deflateTune() can be called after deflateInit() or deflateInit2(), and
+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
+ */
+
+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                       uLong sourceLen));
+/*
+     deflateBound() returns an upper bound on the compressed size after
+   deflation of sourceLen bytes.  It must be called after deflateInit()
+   or deflateInit2().  This would be used to allocate an output buffer
+   for deflation in a single pass, and so would be called before deflate().
+*/
+
+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     deflatePrime() inserts bits in the deflate output stream.  The intent
+  is that this function is used to start off the deflate output with the
+  bits leftover from a previous deflate stream when appending to it.  As such,
+  this function can only be used for raw deflate, and must be used before the
+  first deflate() call after a deflateInit2() or deflateReset().  bits must be
+  less than or equal to 16, and that many of the least significant bits of
+  value will be inserted in the output.
+
+      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      deflateSetHeader() provides gzip header information for when a gzip
+   stream is requested by deflateInit2().  deflateSetHeader() may be called
+   after deflateInit2() or deflateReset() and before the first call of
+   deflate().  The text, time, os, extra field, name, and comment information
+   in the provided gz_header structure are written to the gzip header (xflag is
+   ignored -- the extra flags are set according to the compression level).  The
+   caller must assure that, if not Z_NULL, name and comment are terminated with
+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
+   available there.  If hcrc is true, a gzip header crc is included.  Note that
+   the current versions of the command-line version of gzip (up through version
+   1.3.x) do not support header crc's, and will report that it is a "multi-part
+   gzip file" and give up.
+
+      If deflateSetHeader is not used, the default gzip header has text false,
+   the time set to zero, and os set to 255, with no extra, name, or comment
+   fields.  The gzip header is returned to the default state by deflateReset().
+
+      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. windowBits must be greater than or equal to the windowBits value
+   provided to deflateInit2() while compressing, or it must be equal to 15 if
+   deflateInit2() was not used. If a compressed stream with a larger window
+   size is given as input, inflate() will return with the error code
+   Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+   determines the window size. inflate() will then process raw deflate data,
+   not looking for a zlib or gzip header, not generating a check value, and not
+   looking for any check values for comparison at the end of the stream. This
+   is for use with other formats that use the deflate compressed data format
+   such as zip.  Those formats provide their own check values. If a custom
+   format is developed using the raw deflate format for compressed data, it is
+   recommended that a check value such as an adler32 or a crc32 be applied to
+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+   most applications, the zlib format should be used as is. Note that comments
+   above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+     windowBits can also be greater than 15 for optional gzip decoding. Add
+   32 to windowBits to enable zlib and gzip decoding with automatic header
+   detection, or add 16 to decode only the gzip format (the zlib format will
+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is
+   a crc32 instead of an adler32.
+
+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg
+   is set to null if there is no error message.  inflateInit2 does not perform
+   any decompression apart from reading the zlib header if present: this will
+   be done by inflate(). (So next_in and avail_in may be modified, but next_out
+   and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate,
+   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by that call of inflate.
+   The compressor and decompressor must use exactly the same dictionary (see
+   deflateSetDictionary).  For raw inflate, this function can be called
+   immediately after inflateInit2() or inflateReset() and before any call of
+   inflate() to set the dictionary.  The application must insure that the
+   dictionary that was used for compression is provided.
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/*
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when randomly accessing a large stream.  The
+   first pass through the stream can periodically record the inflate state,
+   allowing restarting inflate at those points when randomly accessing the
+   stream.
+
+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     This function inserts bits in the inflate input stream.  The intent is
+  that this function is used to start inflating at a bit position in the
+  middle of a byte.  The provided bits will be used before any bytes are used
+  from next_in.  This function should only be used with raw inflate, and
+  should be used before the first inflate() call after inflateInit2() or
+  inflateReset().  bits must be less than or equal to 16, and that many of the
+  least significant bits of value will be inserted in the input.
+
+      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      inflateGetHeader() requests that gzip header information be stored in the
+   provided gz_header structure.  inflateGetHeader() may be called after
+   inflateInit2() or inflateReset(), and before the first call of inflate().
+   As inflate() processes the gzip stream, head->done is zero until the header
+   is completed, at which time head->done is set to one.  If a zlib stream is
+   being decoded, then head->done is set to -1 to indicate that there will be
+   no gzip header information forthcoming.  Note that Z_BLOCK can be used to
+   force inflate() to return immediately after header processing is complete
+   and before any actual data is decompressed.
+
+      The text, time, xflags, and os fields are filled in with the gzip header
+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
+   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max
+   contains the maximum number of bytes to write to extra.  Once done is true,
+   extra_len contains the actual extra field length, and extra contains the
+   extra field, or that field truncated if extra_max is less than extra_len.
+   If name is not Z_NULL, then up to name_max characters are written there,
+   terminated with a zero unless the length is greater than name_max.  If
+   comment is not Z_NULL, then up to comm_max characters are written there,
+   terminated with a zero unless the length is greater than comm_max.  When
+   any of extra, name, or comment are not Z_NULL and the respective field is
+   not present in the header, then that field is set to Z_NULL to signal its
+   absence.  This allows the use of deflateSetHeader() with the returned
+   structure to duplicate the header.  However if those fields are set to
+   allocated memory, then the application will need to save those pointers
+   elsewhere so that they can be eventually freed.
+
+      If inflateGetHeader is not used, then the header information is simply
+   discarded.  The header is always checked for validity, including the header
+   CRC if present.  inflateReset() will reset the process to discard the header
+   information.  The application would need to call inflateGetHeader() again to
+   retrieve the header from the next gzip stream.
+
+      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
+                                        unsigned char FAR *window));
+
+     Initialize the internal stream state for decompression using inflateBack()
+   calls.  The fields zalloc, zfree and opaque in strm must be initialized
+   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   derived memory allocation routines are used.  windowBits is the base two
+   logarithm of the window size, in the range 8..15.  window is a caller
+   supplied buffer of that size.  Except for special applications where it is
+   assured that deflate was used with small window sizes, windowBits must be 15
+   and a 32K byte window must be supplied to be able to decompress general
+   deflate streams.
+
+     See inflateBack() for the usage of these routines.
+
+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+   be allocated, or Z_VERSION_ERROR if the version of the library does not
+   match the version of the header file.
+*/
+
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
+
+ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
+                                    in_func in, void FAR *in_desc,
+                                    out_func out, void FAR *out_desc));
+/*
+     inflateBack() does a raw inflate with a single call using a call-back
+   interface for input and output.  This is more efficient than inflate() for
+   file i/o applications in that it avoids copying between the output and the
+   sliding window by simply making the window itself the output buffer.  This
+   function trusts the application to not change the output buffer passed by
+   the output function, at least until inflateBack() returns.
+
+     inflateBackInit() must be called first to allocate the internal state
+   and to initialize the state with the user-provided window buffer.
+   inflateBack() may then be used multiple times to inflate a complete, raw
+   deflate stream with each call.  inflateBackEnd() is then called to free
+   the allocated state.
+
+     A raw deflate stream is one with no zlib or gzip header or trailer.
+   This routine would normally be used in a utility that reads zip or gzip
+   files and writes out uncompressed files.  The utility would decode the
+   header and process the trailer on its own, hence this routine expects
+   only the raw deflate stream to decompress.  This is different from the
+   normal behavior of inflate(), which expects either a zlib or gzip header and
+   trailer around the deflate stream.
+
+     inflateBack() uses two subroutines supplied by the caller that are then
+   called by inflateBack() for input and output.  inflateBack() calls those
+   routines until it reads a complete deflate stream and writes out all of the
+   uncompressed data, or until it encounters an error.  The function's
+   parameters and return types are defined above in the in_func and out_func
+   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
+   number of bytes of provided input, and a pointer to that input in buf.  If
+   there is no input available, in() must return zero--buf is ignored in that
+   case--and inflateBack() will return a buffer error.  inflateBack() will call
+   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+   should return zero on success, or non-zero on failure.  If out() returns
+   non-zero, inflateBack() will return with an error.  Neither in() nor out()
+   are permitted to change the contents of the window provided to
+   inflateBackInit(), which is also the buffer that out() uses to write from.
+   The length written by out() will be at most the window size.  Any non-zero
+   amount of input may be provided by in().
+
+     For convenience, inflateBack() can be provided input on the first call by
+   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
+   in() will be called.  Therefore strm->next_in must be initialized before
+   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
+   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
+   must also be initialized, and then if strm->avail_in is not zero, input will
+   initially be taken from strm->next_in[0 .. strm->avail_in - 1].
+
+     The in_desc and out_desc parameters of inflateBack() is passed as the
+   first parameter of in() and out() respectively when they are called.  These
+   descriptors can be optionally used to pass any information that the caller-
+   supplied in() and out() functions need to do their job.
+
+     On return, inflateBack() will set strm->next_in and strm->avail_in to
+   pass back any unused input that was provided by the last in() call.  The
+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format
+   error in the deflate stream (in which case strm->msg is set to indicate the
+   nature of the error), or Z_STREAM_ERROR if the stream was not properly
+   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+   distinguished using strm->next_in which will be Z_NULL only if in() returned
+   an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
+   out() returning non-zero.  (in() will always be called before out(), so
+   strm->next_in is assured to be defined if out() returns non-zero.)  Note
+   that inflateBack() cannot return Z_OK.
+*/
+
+ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
+/*
+     All memory allocated by inflateBackInit() is freed.
+
+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+   state was inconsistent.
+*/
+
+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+/* Return flags indicating compile-time options.
+
+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+     1.0: size of uInt
+     3.2: size of uLong
+     5.4: size of voidpf (pointer)
+     7.6: size of z_off_t
+
+    Compiler, assembler, and debug options:
+     8: DEBUG
+     9: ASMV or ASMINF -- use ASM code
+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+     11: 0 (reserved)
+
+    One-time table building (smaller code, but not thread-safe if true):
+     12: BUILDFIXED -- build static block decoding tables when needed
+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+     14,15: 0 (reserved)
+
+    Library content (indicates missing functionality):
+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                          deflate code when not needed)
+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                    and decode gzip streams (to avoid linking crc code)
+     18-19: 0 (reserved)
+
+    Operation variations (changes in library functionality):
+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+     21: FASTEST -- deflate algorithm with only one, lowest compression level
+     22,23: 0 (reserved)
+
+    The sprintf variant used by gzprintf (zero is best):
+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+    Remainder:
+     27-31: 0 (reserved)
+ */
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least the value returned
+   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least the value returned by
+   compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+/*
+     compressBound() returns an upper bound on the compressed size after
+   compress() or compress2() on sourceLen bytes.  It would be used before
+   a compress() or compress2() call to allocate the destination buffer.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+   Huffman only compression as in "wb1h", or 'R' for run-length encoding
+   as in "wb1R". (See the description of deflateInit2 for more information
+   about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                   voidpc buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).  The number of
+   uncompressed bytes written is limited to 4095. The caller should assure that
+   this limit is not exceeded. If it is exceeded, then gzprintf() will return
+   return an error (0) with nothing written. In this case, there may also be a
+   buffer overflow with unpredictable consequences, which is possible only if
+   zlib was compiled with the insecure functions sprintf() or vsprintf()
+   because the secure snprintf() or vsnprintf() functions were not available.
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+/*
+      Push one character back onto the stream to be read again later.
+   Only one character of push-back is allowed.  gzungetc() returns the
+   character pushed, or -1 on failure.  gzungetc() will fail if a
+   character has been pushed but not read yet, or if c is -1. The pushed
+   character will be discarded if the stream is repositioned with gzseek()
+   or gzrewind().
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                      z_off_t offset, int whence));
+/*
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
+/*
+     Returns 1 if file is being read directly without decompression, otherwise
+   zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+/*
+     Clears the error and end-of-file flags for file. This is analogous to the
+   clearerr() function in stdio. This is useful for continuing to read a gzip
+   file that is being written concurrently.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
+                                          z_off_t len2));
+/*
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32. If buf is NULL, this function returns the required initial
+   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   performed within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
+
+/*
+     Combine two CRC-32 check values into one.  For two sequences of bytes,
+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
+   len2.
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
+                                         unsigned char FAR *window,
+                                         const char *version,
+                                         int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */
diff --git a/haplotype_graph/TO_bpgraph_hidden_node_for_connectivity_chromosomes_job_ACN.R b/haplotype_graph/TO_bpgraph_hidden_node_for_connectivity_chromosomes_job_ACN.R
index c4a9145..ffe24bc 100644
--- a/haplotype_graph/TO_bpgraph_hidden_node_for_connectivity_chromosomes_job_ACN.R
+++ b/haplotype_graph/TO_bpgraph_hidden_node_for_connectivity_chromosomes_job_ACN.R
@@ -1,4 +1,5 @@
 args=commandArgs(T)
+options(warn=-1)
 t=read.table("SVs.AS_SV.haplotype_phased", stringsAsFactors=F)
 ochr=c(1:22, "X");
 chr=c();
diff --git a/haplotype_graph/haplotype_graph b/haplotype_graph/haplotype_graph
index 72c916a..24b6a4a 100755
--- a/haplotype_graph/haplotype_graph
+++ b/haplotype_graph/haplotype_graph
@@ -43,6 +43,14 @@ if [[ ! -s ${haplotype_path} ]];then
         exit 1
 fi
 thread=`echo $thread | awk '{if($1>23){print 23}else{print $1}}'`
+
+max_mem=`free | awk '/Mem\:/ { print $2 }'`
+max_thread=`echo $max_mem | awk '{print int($1/40000000)}'`
+if [[ $thread -gt $max_thread ]];then
+	thread=$max_thread
+fi
+
+
 echo "thread = ${thread}"
 if [[ ! -s $out_dir ]];then
         echo "The output directory of allele graph construction is not found."
diff --git a/haplotype_graph/phasing/dag_N.o b/haplotype_graph/phasing/dag_N.o
index 75a257e..b8f7a55 100644
Binary files a/haplotype_graph/phasing/dag_N.o and b/haplotype_graph/phasing/dag_N.o differ
diff --git a/haplotype_graph/phasing/phasing b/haplotype_graph/phasing/phasing
index 53aa165..6b7072d 100755
Binary files a/haplotype_graph/phasing/phasing and b/haplotype_graph/phasing/phasing differ
diff --git a/humandb/GRCh37.repeatmasker.gz b/humandb/GRCh37.repeatmasker.gz
new file mode 100644
index 0000000..130fdd2
Binary files /dev/null and b/humandb/GRCh37.repeatmasker.gz differ
diff --git a/humandb/hg19.CRG.50bp.tar.gz b/humandb/hg19.CRG.50bp.tar.gz
new file mode 100644
index 0000000..34c36cd
Binary files /dev/null and b/humandb/hg19.CRG.50bp.tar.gz differ
diff --git a/humandb/human.hg19.excl.tsv b/humandb/human.hg19.excl.tsv
new file mode 100755
index 0000000..ad1e792
--- /dev/null
+++ b/humandb/human.hg19.excl.tsv
@@ -0,0 +1,263 @@
+chr1	0	10000	telomere
+chr1	121535434	124535434	centromere
+chr1	249240621	249250621	telomere
+chr10	0	10000	telomere
+chr10	39254935	42254935	centromere
+chr10	135524747	135534747	telomere
+chr11	0	10000	telomere
+chr11	51644205	54644205	centromere
+chr11	134996516	135006516	telomere
+chr12	0	10000	telomere
+chr12	34856694	37856694	centromere
+chr12	133841895	133851895	telomere
+chr13	0	10000	telomere
+chr13	16000000	19000000	centromere
+chr13	115159878	115169878	telomere
+chr14	0	10000	telomere
+chr14	16000000	19000000	centromere
+chr14	107339540	107349540	telomere
+chr15	0	10000	telomere
+chr15	17000000	20000000	centromere
+chr15	102521392	102531392	telomere
+chr16	0	10000	telomere
+chr16	35335801	38335801	centromere
+chr16	90344753	90354753	telomere
+chr17	22263006	25263006	centromere
+chr18	0	10000	telomere
+chr18	15460898	18460898	centromere
+chr18	78067248	78077248	telomere
+chr19	0	10000	telomere
+chr19	24681782	27681782	centromere
+chr19	59118983	59128983	telomere
+chr2	0	10000	telomere
+chr2	92326171	95326171	centromere
+chr2	243189373	243199373	telomere
+chr20	0	10000	telomere
+chr20	26369569	29369569	centromere
+chr20	63015520	63025520	telomere
+chr21	0	10000	telomere
+chr21	11288129	14288129	centromere
+chr21	48119895	48129895	telomere
+chr22	0	10000	telomere
+chr22	13000000	16000000	centromere
+chr22	51294566	51304566	telomere
+chr3	0	10000	telomere
+chr3	90504854	93504854	centromere
+chr3	198012430	198022430	telomere
+chr4	0	10000	telomere
+chr4	49660117	52660117	centromere
+chr4	191144276	191154276	telomere
+chr5	0	10000	telomere
+chr5	46405641	49405641	centromere
+chr5	180905260	180915260	telomere
+chr6	0	10000	telomere
+chr6	58830166	61830166	centromere
+chr6	171105067	171115067	telomere
+chr7	0	10000	telomere
+chr7	58054331	61054331	centromere
+chr7	159128663	159138663	telomere
+chr8	0	10000	telomere
+chr8	43838887	46838887	centromere
+chr8	146354022	146364022	telomere
+chr9	0	10000	telomere
+chr9	47367679	50367679	centromere
+chr9	141203431	141213431	telomere
+chrX	0	10000	telomere
+chrX	58632012	61632012	centromere
+chrX	155260560	155270560	telomere
+chrY	0	10000	telomere
+chrY	10104553	13104553	centromere
+chrY	59363566	59373566	telomere
+1	0	10000	telomere
+1	121535434	124535434	centromere
+1	249240621	249250621	telomere
+10	0	10000	telomere
+10	39254935	42254935	centromere
+10	135524747	135534747	telomere
+11	0	10000	telomere
+11	51644205	54644205	centromere
+11	134996516	135006516	telomere
+12	0	10000	telomere
+12	34856694	37856694	centromere
+12	133841895	133851895	telomere
+13	0	10000	telomere
+13	16000000	19000000	centromere
+13	115159878	115169878	telomere
+14	0	10000	telomere
+14	16000000	19000000	centromere
+14	107339540	107349540	telomere
+15	0	10000	telomere
+15	17000000	20000000	centromere
+15	102521392	102531392	telomere
+16	0	10000	telomere
+16	35335801	38335801	centromere
+16	90344753	90354753	telomere
+17	22263006	25263006	centromere
+18	0	10000	telomere
+18	15460898	18460898	centromere
+18	78067248	78077248	telomere
+19	0	10000	telomere
+19	24681782	27681782	centromere
+19	59118983	59128983	telomere
+2	0	10000	telomere
+2	92326171	95326171	centromere
+2	243189373	243199373	telomere
+20	0	10000	telomere
+20	26369569	29369569	centromere
+20	63015520	63025520	telomere
+21	0	10000	telomere
+21	11288129	14288129	centromere
+21	48119895	48129895	telomere
+22	0	10000	telomere
+22	13000000	16000000	centromere
+22	51294566	51304566	telomere
+3	0	10000	telomere
+3	90504854	93504854	centromere
+3	198012430	198022430	telomere
+4	0	10000	telomere
+4	49660117	52660117	centromere
+4	191144276	191154276	telomere
+5	0	10000	telomere
+5	46405641	49405641	centromere
+5	180905260	180915260	telomere
+6	0	10000	telomere
+6	58830166	61830166	centromere
+6	171105067	171115067	telomere
+7	0	10000	telomere
+7	58054331	61054331	centromere
+7	159128663	159138663	telomere
+8	0	10000	telomere
+8	43838887	46838887	centromere
+8	146354022	146364022	telomere
+9	0	10000	telomere
+9	47367679	50367679	centromere
+9	141203431	141213431	telomere
+X	0	10000	telomere
+X	58632012	61632012	centromere
+X	155260560	155270560	telomere
+Y	0	10000	telomere
+Y	10104553	13104553	centromere
+Y	59363566	59373566	telomere
+chrM
+chrMT
+MT
+GL000207.1
+GL000226.1
+GL000229.1
+GL000231.1
+GL000210.1
+GL000239.1
+GL000235.1
+GL000201.1
+GL000247.1
+GL000245.1
+GL000197.1
+GL000203.1
+GL000246.1
+GL000249.1
+GL000196.1
+GL000248.1
+GL000244.1
+GL000238.1
+GL000202.1
+GL000234.1
+GL000232.1
+GL000206.1
+GL000240.1
+GL000236.1
+GL000241.1
+GL000243.1
+GL000242.1
+GL000230.1
+GL000237.1
+GL000233.1
+GL000204.1
+GL000198.1
+GL000208.1
+GL000191.1
+GL000227.1
+GL000228.1
+GL000214.1
+GL000221.1
+GL000209.1
+GL000218.1
+GL000220.1
+GL000213.1
+GL000211.1
+GL000199.1
+GL000217.1
+GL000216.1
+GL000215.1
+GL000205.1
+GL000219.1
+GL000224.1
+GL000223.1
+GL000195.1
+GL000212.1
+GL000222.1
+GL000200.1
+GL000193.1
+GL000194.1
+GL000225.1
+GL000192.1
+NC_007605
+hs37d5
+chr11_gl000202_random
+chr17_gl000203_random
+chr17_gl000204_random
+chr17_gl000205_random
+chr17_gl000206_random
+chr18_gl000207_random
+chr19_gl000208_random
+chr19_gl000209_random
+chr1_gl000191_random
+chr1_gl000192_random
+chr21_gl000210_random
+chr4_gl000193_random
+chr4_gl000194_random
+chr7_gl000195_random
+chr8_gl000196_random
+chr8_gl000197_random
+chr9_gl000198_random
+chr9_gl000199_random
+chr9_gl000200_random
+chr9_gl000201_random
+chrUn_gl000211
+chrUn_gl000212
+chrUn_gl000213
+chrUn_gl000214
+chrUn_gl000215
+chrUn_gl000216
+chrUn_gl000217
+chrUn_gl000218
+chrUn_gl000219
+chrUn_gl000220
+chrUn_gl000221
+chrUn_gl000222
+chrUn_gl000223
+chrUn_gl000224
+chrUn_gl000225
+chrUn_gl000226
+chrUn_gl000227
+chrUn_gl000228
+chrUn_gl000229
+chrUn_gl000230
+chrUn_gl000231
+chrUn_gl000232
+chrUn_gl000233
+chrUn_gl000234
+chrUn_gl000235
+chrUn_gl000236
+chrUn_gl000237
+chrUn_gl000238
+chrUn_gl000239
+chrUn_gl000240
+chrUn_gl000241
+chrUn_gl000242
+chrUn_gl000243
+chrUn_gl000244
+chrUn_gl000245
+chrUn_gl000246
+chrUn_gl000247
+chrUn_gl000248
+chrUn_gl000249
diff --git a/preprocessing/bicseq_preprocess.sh b/preprocessing/bicseq_preprocess.sh
index cb6dc48..d3047f4 100755
--- a/preprocessing/bicseq_preprocess.sh
+++ b/preprocessing/bicseq_preprocess.sh
@@ -1,16 +1,44 @@
 #!/bin/bash
-reference=hg19.fa
-norm_script=./NBICseq-norm_v0.2.4/NBICseq-norm.pl
-map_file=./NBICseq-norm_v0.2.4/hg19.CRG.50bp/
-read_length=100
-fragment_size=350
-tumor_bam=tumor.bam
-
-mkdir bicseq_samtools
-modifiedSamtools view -U BWA,bicseq_samtools/,N,N $tumor_bam
-
-mkdir cn_norm
-echo -e "chromName\tfaFile\tMapFile\treadPosFile\tbinFileNorm" > norm_configFile;
+cleanup() {
+        pkill -P $$
+        kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+        trap "
+            cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+declare -a pids;
+
+lib=`dirname $(readlink -f ${BASH_SOURCE[0]})`
+
+reference=$2
+norm_script=`which NBICseq-norm.pl`
+map_file=$3
+read_length=150
+fragment_size=550
+bam=$1
+
+output=$4
+stat=$5
+
+samtools stats $bam > $output.bam.stats &
+pids[0]=$!;
+
+modifiedSamtools=$lib\/../ext/samtools-0.1.7a_getUnique-0.1.3/samtools
+
+
+mkdir -p $output.samtools
+$modifiedSamtools view -U BWA,$output.samtools/,N,N $bam &
+pids[1]=$!;
+
+wait ${pids[0]}
+wait ${pids[1]}
+
+mkdir -p $output
+echo -e "chromName\tfaFile\tMapFile\treadPosFile\tbinFileNorm" > $output.configFile;
 for i in {1..23}
 do
         if [ $i == 23 ]
@@ -19,10 +47,14 @@ do
         else
                 chr=$i;
         fi
-        echo -e "$chr\t$reference.$chr\t$map_file\/hg19.50mer.CRC.chr$chr.txt\t$PWD/bicseq_samtools/$chr.seq\t$PWD/cn_norm/$chr.norm.bin" >> norm_configFile;
+        echo -e "$chr\t$reference.$chr\t${map_file}/hg19.50mer.CRC.chr$chr.txt\t$PWD/${output}.samtools/$chr.seq\t$PWD/${output}/$chr.norm.bin" >> $output.configFile;
 
 done
 
-mkdir tmp;
-perl $norm_script -l $read_length -s $fragment_size norm_configFile ./NB_parameters --tmp tmp
+read_length=`cat $output.bam.stats | grep ^SN | cut -f 2- | grep "average length" | awk -F "\t" '{split($2,f,"."); print f[1]}'`
+fragment_size=`cat $output.bam.stats | grep ^SN | cut -f 2- | grep "insert size average" | awk -F "\t" '{split($2,f,"."); print f[1]}'`
+
+
+mkdir -p $output.tmp;
+perl $norm_script -l $read_length -s $fragment_size $output.configFile $output.NB_parameters --tmp $output.tmp
 
diff --git a/preprocessing/delly.sh b/preprocessing/delly.sh
new file mode 100755
index 0000000..b72f715
--- /dev/null
+++ b/preprocessing/delly.sh
@@ -0,0 +1,88 @@
+#!/bin/bash
+lib=`dirname $(readlink -f ${BASH_SOURCE[0]})`
+
+cleanup() {
+        pkill -P $$
+        kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+        trap "
+            cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+
+
+mode=$1
+bam=$2
+ref=$3
+exclude_tsv=$4
+PE_thres=$5
+MAPQ_thres=$6
+
+bcf_prefix="";
+if [[ $mode == "germline" ]];then
+	bcf_prefix="germline"
+else
+	bcf_prefix="tumor"
+fi
+
+idx=0;
+mkdir -p log;
+
+for type in DEL DUP INV TRA;do
+	delly call -t $type -g $ref -o $bcf_prefix.$type.bcf $bam  -x $exclude_tsv -q 10 -s 15 -n &>log/$bcf_prefix.$type.log &
+	pids[$idx]=$!;
+	idx=$(($idx+1));
+done
+
+
+for pid in ${pids[*]}; do
+        wait $pid;
+done
+
+for type in DEL DUP INV TRA;do
+	bcftools view $bcf_prefix.$type.bcf > $bcf_prefix.$type.vcf
+done
+
+echo -n "" > $bcf_prefix.filtered.format
+for type in DEL DUP INV TRA;do
+                file=$bcf_prefix.$type.vcf
+
+                cat $file | awk -F "\t" '{
+                                                n=split($8,f,"SR=");
+                                                if(n>1){
+                                                        split(f[2],SR, ";");
+                                                        SR_number=SR[1];
+                                                }else{
+                                                        SR_number=0;
+                                                }
+                                                split($8, f, "SVTYPE=");
+                                                split(f[2], SVTYPE, ";");
+
+                                               split($8, f, "CHR2=");
+                                                split(f[2], chr2, ";");
+
+                                               split($8, f, ";END=");
+                                                split(f[2], pos2, ";");
+
+                                               split($8, f, ";PE=");
+                                                split(f[2], PE, ";");
+
+                                               split($8, f, "MAPQ=");
+                                                split(f[2], MAPQ, ";");
+
+                                              split($8, f, "CT=");
+                                                split(f[2], ori, ";");
+
+						if($7=="PASS" && (PE[1] > '$PE_thres' && SR_number > -1)&& MAPQ[1] > '$MAPQ_thres'){
+                                                        print "<"SVTYPE[1]">""\t"$1"\t"$2"\t"chr2[1]"\t"pos2[1]"\t"ori[1]"\t"PE[1]"\t"SR_number"\t"MAPQ[1]"\t"PE[1]+SR_number"\t0\t0\t1\t1\t"
+                                                }
+                                        }' | awk '{if(($2~/^[1-2]?[0-9]$/ || $2=="X") && ($4~/^[1-2]?[0-9]$/ || $4=="X")) print $0}'  >> $bcf_prefix.filtered.format
+
+done
+
+if [[ mode != "germline" ]];then
+	ln -s $bcf_prefix.filtered.format delly.format
+fi
diff --git a/preprocessing/delly_somatic.sh b/preprocessing/delly_somatic.sh
index 7283169..37426f6 100755
--- a/preprocessing/delly_somatic.sh
+++ b/preprocessing/delly_somatic.sh
@@ -1,41 +1,58 @@
 #!/bin/bash
+lib=`dirname $(readlink -f ${BASH_SOURCE[0]})`
 
-#echo "Type SRR ID"
-#read tumorIDini
-ref=hg19.fa
-tsv=samples.tsv
-tumor_bam=tumor.bam
-normal_bam=normal.bam
-
-delly_v0.7.6 call -t DEL -g $ref -o somatic_pre_DEL.bcf $tumor_bam $normal_bam
-delly_v0.7.6 filter -t DEL -f somatic -o somatic_DEL.bcf -s samples.tsv somatic_pre_DEL.bcf -a 0 -m 100
-delly_v0.7.6 call -t INV -g $ref -o somatic_pre_INV.bcf $tumor_bam $normal_bam
-delly_v0.7.6 filter -t INV -f somatic -o somatic_INV.bcf -s samples.tsv somatic_pre_INV.bcf -a 0 -m 100
-delly_v0.7.6 call -t DUP -g $ref -o somatic_pre_DUP.bcf $tumor_bam $normal_bam
-delly_v0.7.6 filter -t DUP -f somatic -o somatic_DUP.bcf -s samples.tsv somatic_pre_DUP.bcf -a 0 -m 100
-delly_v0.7.6 call -t TRA -g $ref -o somatic_pre_TRA.bcf $tumor_bam $normal_bam 
-delly_v0.7.6 filter -t TRA -f somatic -o somatic_TRA.bcf -s samples.tsv somatic_pre_TRA.bcf -a 0 -m 100
-
-PE_thres=$1
-MAPQ_thres=$2
-#lib=$2
-
-for i in {1..4}
+cleanup() {
+	pkill -P $$
+	kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+	trap "
+	    cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+
+# trap cleanup EXIT
+
+tumor_bam=$1
+normal_bam=$2
+ref=$3
+PE_thres=$4
+MAPQ_thres=$5
+
+idx=0;
+
+declare -a pids;
+mkdir -p log
+for type in DEL INV DUP TRA;do
+	delly call -t $type -g $ref -o somatic_pre_$type.bcf $tumor_bam $normal_bam &>log/somatic.$type.log &
+	pids[$idx]=$!;
+	idx=$(($idx+1));
+done
+
+for z in `seq 0 3`;do
+        wait ${pids[$z]};
+done
+
+
+bcftools view somatic_pre_DEL.bcf -h | tail -n1 | awk '{print $10"\ttumor"; print $11"\tcontrol"}' > samples.tsv
+
+delly filter -t DEL -f somatic -o somatic_DEL.bcf -s samples.tsv somatic_pre_DEL.bcf -a 0 -m 100
+delly filter -t INV -f somatic -o somatic_INV.bcf -s samples.tsv somatic_pre_INV.bcf -a 0 -m 100
+delly filter -t DUP -f somatic -o somatic_DUP.bcf -s samples.tsv somatic_pre_DUP.bcf -a 0 -m 100
+delly filter -t TRA -f somatic -o somatic_TRA.bcf -s samples.tsv somatic_pre_TRA.bcf -a 0 -m 100
+
+for type in DEL INV DUP TRA;do
+	bcftools view somatic_$type.bcf > somatic_$type.vcf
+done
+
+echo -n "" > delly.format
+for type in DEL INV DUP TRA;
 do
-        if [ $i == 1 ]
-        then
-                tumorID=somatic_DEL.vcf
-        elif [ $i == 2 ]
-        then
-                tumorID=somatic_INV.vcf
-        elif [ $i == 3 ]
-        then
-                tumorID=somatic_DUP.vcf
-        else
-                tumorID=somatic_TRA.vcf
-        fi
-
-                cat $tumorID | awk -F "\t" '{
+                tumorID=somatic_$type.vcf
+
+                cat $tumorID | grep -v '#' | awk -F "\t" '{
                                                 n=split($8,f,"SR=");
                                                 if(n>1){
                                                         split(f[2],SR, ";");
@@ -68,6 +85,6 @@ do
 
 done
 
-#Rscript $lib/SV_overnoise.R delly.format
+Rscript $lib/SV_overnoise.R delly.format
 
 
diff --git a/preprocessing/het_SNP_detection.sh b/preprocessing/het_SNP_detection.sh
new file mode 100755
index 0000000..3a98cb3
--- /dev/null
+++ b/preprocessing/het_SNP_detection.sh
@@ -0,0 +1,69 @@
+#!/bin/bash
+cleanup() {
+        pkill -P $$
+        kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+        trap "
+            cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+
+reference=$1
+tumor_bam=$2
+
+declare -a pids;
+
+mkdir -p vcf
+
+for l in `seq 1 22`;do
+		samtools mpileup -t DP,AD,ADF,ADR,SP -q 20 -d 5000 -I -uf $reference $tumor_bam -r $l | bcftools call -c -v > vcf/$l.vcf &
+		pids[$l]=$!;
+done
+l='X';
+                samtools mpileup -t DP,AD,ADF,ADR,SP -q 20 -d 5000 -I -uf $reference $tumor_bam -r $l | bcftools call -c -v > vcf/$l.vcf &
+		pids[23]=$!;
+
+for l in `seq 1 23`;do
+	wait ${pids[$l]}
+done
+
+
+for i in `seq 1 23`; do
+        if [ $i -eq 23 ];then
+                i="X";
+        fi
+        cat vcf/$i.vcf | grep -v '#' | awk '{
+
+                if(length($4)==1 && length($5) == 1 && $6>50){
+                        split($10,f,":");
+                        if(f[1] == "0/1"){
+                                split($10,f1,":");
+                                split(f1[7], tumor, ",");
+
+                                print "'$i'""\t"$2"\t"$3"\t"$4"\t"$5"\t""NA""\t""NA""\t"tumor[1]"\t"tumor[2]
+                        }
+                }
+        }' > vcf/$i.vcf.format.het
+
+        cat vcf/$i.vcf | grep -v '#' | awk '{
+
+                if(length($4)==1 && length($5) == 1 && $6>50){
+                        split($10,f,":");
+                        if(f[1] == "1/1"){
+                                split($10,f1,":");
+                                split(f1[7], tumor, ",");
+
+                                print "'$i'""\t"$2"\t"$3"\t"$4"\t"$5"\t""NA""\t""NA""\t"tumor[1]"\t"tumor[2]
+                        }
+                }
+        }' > vcf/$i.vcf.format.hom
+
+
+done
+
+cat vcf/*.vcf.format.het > het_snps.format
+cat vcf/*.vcf.format.hom > hom_snps.format
+
diff --git a/preprocessing/het_SNP_detection_somatic.sh b/preprocessing/het_SNP_detection_somatic.sh
index 49743af..8e7ad60 100755
--- a/preprocessing/het_SNP_detection_somatic.sh
+++ b/preprocessing/het_SNP_detection_somatic.sh
@@ -1,15 +1,34 @@
 #!/bin/bash
-reference=hg19.fa
-normal_bam=normal.bam
-tumor_bam=tumor.bam
+cleanup() {
+        pkill -P $$
+        kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+        trap "
+            cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+
+reference=$1
+normal_bam=$2
+tumor_bam=$3
+
+declare -a pids;
 
-mkdir vcf_somatic
+mkdir -p vcf_somatic
 for l in `seq 1 22`;do
-		samtools mpileup -t DP,AD,ADF,ADR,SP -q 10 -d 5000 -I -uf $reference $normal_bam $tumor_bam -r $l | bcftools call -c -v > vcf_somatic/$l.vcf
+		samtools mpileup -t DP,AD,ADF,ADR,SP -q 10 -d 5000 -I -uf $reference $normal_bam $tumor_bam -r $l | bcftools call -c -v > vcf_somatic/$l.vcf &
+		pids[$l]=$!;
 done
 l='X';
-                samtools mpileup -t DP,AD,ADF,ADR,SP -q 10 -d 5000 -I -uf $reference $normal_bam $tumor_bam -r $l | bcftools call -c -v > vcf_somatic/$l.vcf
+                samtools mpileup -t DP,AD,ADF,ADR,SP -q 10 -d 5000 -I -uf $reference $normal_bam $tumor_bam -r $l | bcftools call -c -v > vcf_somatic/$l.vcf &
+		pids[23]=$!;
 
+for l in `seq 1 23`;do
+	wait ${pids[$l]}
+done
 
 
 for i in `seq 1 23`; do
@@ -21,11 +40,11 @@ for i in `seq 1 23`; do
                 if(length($4)==1 && length($5) == 1 && $6>50){
                         split($10,f,":");
                         split($11,g,":");
-                        if(g[1] == "0/1"){
+                        if(f[1] == "0/1"){
                                 split($10,f1,":");
-                                split(f1[7], tumor, ",");
+                                split(f1[7], normal, ",");
                                split($11,f2,":");
-                                split(f2[7], normal, ",");
+                                split(f2[7], tumor, ",");
 
                                 print "'$i'""\t"$2"\t"$3"\t"$4"\t"$5"\t"normal[1]"\t"normal[2]"\t"tumor[1]"\t"tumor[2]
                         }
@@ -35,25 +54,22 @@ for i in `seq 1 23`; do
         cat vcf_somatic/$i.vcf | grep -v '#' | awk '{
 
                 if(length($4)==1 && length($5) == 1 && $6>50){
-                        split($10,f,":");
+                        split($11,f,":");
                         if(f[1] == "1/1"){
                                 split($10,f1,":");
-                                split(f1[7], tumor, ",");
+                                split(f1[7], normal, ",");
                               split($11,f2,":");
-                                split(f2[7], normal, ",");
+                                split(f2[7], tumor, ",");
 
                                 print "'$i'""\t"$2"\t"$3"\t"$4"\t"$5"\t"normal[1]"\t"normal[2]"\t"tumor[1]"\t"tumor[2]
                         }
                 }
         }' > vcf_somatic/$i.vcf.format.hom
 
+done
 
 
 
-
-
-        cat vcf_somatic/*.vcf.format.het > het_snps.format
-        cat vcf_somatic/*.vcf.format.hom > hom_snps.format
-
-done
+cat vcf_somatic/*.vcf.format.het > het_snps.format
+cat vcf_somatic/*.vcf.format.hom > hom_snps.format
 
diff --git a/preprocessing/manta.sh b/preprocessing/manta.sh
new file mode 100755
index 0000000..2f7af78
--- /dev/null
+++ b/preprocessing/manta.sh
@@ -0,0 +1,60 @@
+#!/bin/bash
+script1=configManta.py
+tumor_bam=$1
+reference=$2
+PE_thres=4
+
+mkdir -p log
+$script1 --tumorBam $tumor_bam --referenceFasta $reference --runDir manta &> log/manta.log
+cd manta
+./runWorkflow.py -m local -j 8 &>> ../log/manta.log
+cd ../
+
+
+zcat ./manta/results/variants/tumorSV.vcf.gz | awk -F "\t" '{
+
+	n=split($8,f,";");
+	split(f[2],DUPDEL,"=");
+	split(f[1],TRA, "=");
+	rn=split($10,read, ":");
+	if(rn==1){
+		split(read[1],pr,",");
+		PR=pr[2];
+		SR=0;
+	}else{
+		split(read[1],pr,",");
+		PR=pr[2];
+		split(read[2],sr,",");
+		SR=sr[2];
+	}
+	if(DUPDEL[2]=="DUP"){
+		split(f[1], pos2, "=");
+		print "<DUP>\t"$1"\t"$2"\t"$1"\t"pos2[2]"\t5to3\t"PR"\t"SR
+	}else if(DUPDEL[2]=="DEL"){
+		split(f[1], pos2, "=");
+		print "<DEL>\t"$1"\t"$2"\t"$1"\t"pos2[2]"\t3to5\t"PR"\t"SR
+	}else if(DUPDEL[2]=="INV"){
+		split(f[1], pos2, "=");
+		split($8, INV, ";INV");
+		split(INV[2], inv_ori, ";");
+		print "<INV>\t"$1"\t"$2"\t"$1"\t"pos2[2]"\t"inv_ori[1]"to"inv_ori[1]"\t"PR"\t"SR;
+	}else if(TRA[2]=="BND"){
+		n1=split($5, tra_ori, "[");
+		if(n1>2){
+			if(length(tra_ori[1])!=0)
+				ori="3to5"
+			else if(length(tra_ori[3])!=0)
+				ori="5to5"
+		}else{
+		n2=split($5, tra_ori, "]");
+			if(length(tra_ori[1])!=0)
+				ori="3to3"
+			else if(length(tra_ori[3])!=0)
+				ori="5to3"
+		}
+		split(tra_ori[2], chr2_pos2, ":");
+		print "<TRA>\t"$1"\t"$2"\t"chr2_pos2[1]"\t"chr2_pos2[2]"\t"ori"\t"PR"\t"SR;
+}
+
+}' | awk '{ if($7 > '$PE_thres' ){
+        print $0"\t0\t0\t0\t0\t0\t0"}}' | awk '{if(($2~/^[1-2]?[0-9]$/ || $2=="X") && ($4~/^[1-2]?[0-9]$/ || $4=="X")) print $0}' > manta.format
diff --git a/preprocessing/manta_somatic.sh b/preprocessing/manta_somatic.sh
index c55ccb0..c659ee8 100755
--- a/preprocessing/manta_somatic.sh
+++ b/preprocessing/manta_somatic.sh
@@ -1,12 +1,14 @@
 #!/bin/bash
-reference=hg19.fa
-script1=./manta-1.1.0.centos5_x86_64/bin/configManta.py
-script2=./runWorkflow.py
-normal_bam=normal.bam
-tumor_bam=tumor.bam
+script1=configManta.py
+tumor_bam=$1
+normal_bam=$2
+reference=$3
 
-$script1 --normalBam $normal_bam --tumorBam $tumor_bam --referenceFasta $reference --runDir manta_somatic
-$script2 -m local -j 1 
+mkdir -p log
+$script1 --normalBam $normal_bam --tumorBam $tumor_bam --referenceFasta $reference --runDir manta_somatic &> log/manta_somatic.log
+cd manta_somatic
+./runWorkflow.py -m local -j 8 &>> ../log/manta_somatic.log
+cd ../
 
 
 zcat ./manta_somatic/results/variants/somaticSV.vcf.gz | awk -F "\t" '{
@@ -56,5 +58,5 @@ zcat ./manta_somatic/results/variants/somaticSV.vcf.gz | awk -F "\t" '{
 	}
 
 }' | awk '{
-	print $0"\t0\t0\t0\t0\t0\t0"}'  > manta.format
+	print $0"\t0\t0\t0\t0\t0\t0"}' | awk '{if(($2~/^[1-2]?[0-9]$/ || $2=="X") && ($4~/^[1-2]?[0-9]$/ || $4=="X")) print $0}'  > manta.format
 
diff --git a/workflow/Snakefile b/workflow/Snakefile
new file mode 100644
index 0000000..634594a
--- /dev/null
+++ b/workflow/Snakefile
@@ -0,0 +1,140 @@
+wildcard_constraints:
+
+configfile:"workflow/configs/config.yaml"
+
+rule all:
+
+rule InfoGenomeR_env:
+        conda:
+                "envs/InfoGenomeR.yaml"
+        shell:
+                "workflow/scripts/InfoGenomeR_env.sh"
+
+rule InfoGenomeR_example_download:
+        conda:  
+                "envs/InfoGenomeR.yaml"
+        shell:  
+                "workflow/scripts/InfoGenomeR_example_download.sh"
+
+
+rule InfoGenomeR_download:
+        output:
+                default_repeatmasker=Path(workflow.basedir) / "../humandb/GRCh37.repeatmasker",
+                default_cnv_mappability=directory(Path(workflow.basedir) / "../humandb/hg19.CRG.50bp"),
+                default_haplotype=directory(Path(workflow.basedir) / "../humandb/haplotype_1000G")
+        conda:
+                "envs/InfoGenomeR.yaml"
+        shell:
+                "workflow/scripts/InfoGenomeR_download.sh"
+
+rule bwa_mapping:
+        input:
+                ref="{root}/ref/hg19.fa",
+                fastq_dir=ancient("{root}/fastq"),
+        output:
+                bam_dir=directory("{root}/bam")
+        conda:
+                "envs/InfoGenomeR.yaml"
+        params: 
+                mode=config["mode"]
+        shell:
+                "workflow/scripts/bwa_mapping.sh {params.mode} {input.fastq_dir} {input.ref} {output.bam_dir}"
+
+rule bam_processing:
+        input:  
+                ref="{root}/ref/hg19.fa",
+                bam_dir=ancient("{root}/bam"),
+                exclude_tsv=Path(workflow.basedir) / "../humandb/human.hg19.excl.tsv",
+                norm_map=Path(workflow.basedir) / "../humandb/hg19.CRG.50bp"
+        output: 
+                preprocess_dir=directory("{root}/preprocess")
+        conda:  
+                "envs/InfoGenomeR.yaml"
+        params: 
+                mode=config["mode"]
+        shell:  
+                "workflow/scripts/bam_preprocessing.sh {params.mode} {input.bam_dir} {input.ref} {output.preprocess_dir} {input.exclude_tsv} {input.norm_map}"
+
+rule InfoGenomeR_breakpoint_graph:
+        input:  
+                ref="{root}/ref/hg19.fa",
+                root_dir=ancient("{root}"),
+                preprocess_dir=ancient(rules.bam_processing.output.preprocess_dir),
+        output: 
+                breakpoint_graph_dir=directory("{root}/InfoGenomeR_job"),
+        conda:  
+                "envs/InfoGenomeR.yaml"
+        params:
+                mode=config["mode"],
+                lambda_ini=config["lambda_ini"],
+                lambda_fi=config["lambda_fi"],
+                min_ploidy=config["min_ploidy"],
+                max_ploidy=config["max_ploidy"],
+                cancer_type=config["cancer_type"]
+        shell:  
+                "workflow/scripts/InfoGenomeR_breakpoint.sh {params.mode} {input.root_dir} {input.preprocess_dir} {output.breakpoint_graph_dir} {input.ref} {params.lambda_ini} {params.lambda_fi} {params.min_ploidy} {params.max_ploidy} {params.cancer_type}"
+
+rule InfoGenomeR_breakpoint_graph_simplification:
+        input:  
+                ref="{root}/ref/hg19.fa",
+                root_dir=ancient("{root}"),
+                breakpoint_graph_input_dir=ancient(rules.InfoGenomeR_breakpoint_graph.output.breakpoint_graph_dir)
+        output: 
+                breakpoint_graph_simplification_dir=directory("{root}/InfoGenomeR_simplification_job"),
+        conda:  
+                "envs/InfoGenomeR.yaml"
+        params:
+                mode=config["mode"],
+                lambda_ini=config["lambda_ini"],
+                lambda_fi=config["lambda_fi"],
+                min_ploidy=config["min_ploidy"],
+                max_ploidy=config["max_ploidy"],
+                cancer_type=config["cancer_type"]
+        shell:  
+                "workflow/scripts/InfoGenomeR_breakpoint_simplification.sh {params.mode} {input.root_dir} {input.breakpoint_graph_input_dir} {output.breakpoint_graph_simplification_dir} {input.ref} {params.lambda_ini} {params.lambda_fi} {params.min_ploidy} {params.max_ploidy} {params.cancer_type}"
+
+
+rule InfoGenomeR_allele_graph:
+        input:  
+                ref="{root}/ref/hg19.fa",
+                root_dir=ancient("{root}"),
+                haplotype_path=Path(workflow.basedir) / "../humandb/haplotype_1000G",
+                breakpoint_graph_input_dir=ancient(rules.InfoGenomeR_breakpoint_graph_simplification.output.breakpoint_graph_simplification_dir),
+                preprocess_dir=ancient("{root}/preprocess"),
+        output: 
+                allele_graph_dir=directory("{root}/InfoGenomeR_allele_graph_job"),
+        conda:  
+                "envs/InfoGenomeR.yaml"
+        params: 
+                mode=config["mode"]
+        shell:  
+                "workflow/scripts/InfoGenomeR_allele_graph.sh {params.mode} {input.root_dir} {input.breakpoint_graph_input_dir} {output.allele_graph_dir} {input.ref} {input.haplotype_path}"
+
+
+rule InfoGenomeR_haplotype_graph:
+        input:  
+                ref="{root}/ref/hg19.fa",
+                root_dir=ancient("{root}"),
+                haplotype_path=Path(workflow.basedir) / "../humandb/haplotype_1000G",
+                allele_graph_input_dir=ancient(rules.InfoGenomeR_allele_graph.output.allele_graph_dir),
+        output: 
+                haplotype_graph_dir=directory("{root}/InfoGenomeR_haplotype_graph_job"),
+        conda:  
+                "envs/InfoGenomeR.yaml"
+        shell:  
+                "workflow/scripts/InfoGenomeR_haplotype_graph.sh {input.root_dir} {input.allele_graph_input_dir} {output.haplotype_graph_dir} {input.ref} {input.haplotype_path}"
+
+
+rule InfoGenomeR_karyotyping:
+        input:  
+                ref="{root}/ref/hg19.fa",
+                root_dir=ancient("{root}"),
+                haplotype_path=Path(workflow.basedir) / "../humandb/haplotype_1000G",
+                haplotype_graph_input_dir=ancient(rules.InfoGenomeR_haplotype_graph.output.haplotype_graph_dir),
+        output: 
+                karyotype_output_dir=directory("{root}/InfoGenomeR_output"),
+        conda:  
+                "envs/InfoGenomeR.yaml"
+        shell:  
+                "workflow/scripts/InfoGenomeR_karyotyping.sh {input.root_dir} {input.haplotype_graph_input_dir} {output.karyotype_output_dir} {input.ref} {input.haplotype_path}"
+
diff --git a/workflow/configs/ABSOLUTE_disease_map.txt b/workflow/configs/ABSOLUTE_disease_map.txt
new file mode 100755
index 0000000..c0907e2
--- /dev/null
+++ b/workflow/configs/ABSOLUTE_disease_map.txt
@@ -0,0 +1,77 @@
+Mulitple Myeloma
+GBM
+LUAD
+PRAD
+COAD
+KIRC
+READ
+BRCA
+OV
+LAML
+CESC
+LUSC
+BLCA
+Chronic Lymphocytic Leukemia
+Sarcoma
+Kidney Cancer
+Breast Cancer
+Mesothelioma
+Glioma
+Neuroblastoma
+Endometrial Cancer
+Thyroid Cancer
+Osteosarcoma
+Ewing Sarcoma
+Pediatric Acute lymphoblastic leukemia
+Lung squamous
+Myeloproliferative Disorder
+Esophageal adenocarcinoma
+Pleomorphic Liposarcoma
+Gastric Cancer
+CLL
+Esophageal squamous
+Gastric
+Brain Cancer
+Cervical Cancer
+Lung adenocarcinoma
+Colorectal
+Pediatric GIST
+Lung SCLC
+Lung adenosquamous
+Lung
+Liver Cancer
+Lung Cancer
+Kidney cancer
+Melanoma
+Prostate
+Leiomyosarcoma
+Acute myelogenous leukemia
+Myxoid Liposarcoma
+Ovarian Cancer
+Ovarian
+Chronic lymphocytic leukemia
+Synovial sarcoma
+NSCLC
+Esophageal Cancer
+Pancreatic Cancer
+Rhabdoid Tumor
+Lymphoma
+Bladder Cancer
+Thyroid
+Breast
+Renal Cancer
+Hepatocellular Carcinoma
+Myelodysplasia
+Medulloblastoma
+Prostate Cancer
+Dedifferentiated Liposarcoma
+Colon Cancer
+Multiple Myeloma
+Carcinoid
+Stomach Cancer
+Rectum Cancer
+Rhabdoid
+MFH
+ccRCC
+Head and Neck Cancer
+GIST
diff --git a/workflow/configs/config.yaml b/workflow/configs/config.yaml
new file mode 100644
index 0000000..712d277
--- /dev/null
+++ b/workflow/configs/config.yaml
@@ -0,0 +1,6 @@
+"mode": "somatic"
+"lambda_ini": 16
+"lambda_fi": 2000
+"min_ploidy": 1.5
+"max_ploidy": 5
+"cancer_type": "NA"
diff --git a/workflow/envs/InfoGenomeR.yaml b/workflow/envs/InfoGenomeR.yaml
new file mode 100644
index 0000000..71935cf
--- /dev/null
+++ b/workflow/envs/InfoGenomeR.yaml
@@ -0,0 +1,26 @@
+name: InfoGenomeR
+channels:
+        - conda-forge
+        - bioconda
+        - defaults
+dependencies:
+        - perl
+        - perl-bioperl
+        - bwa=0.7.15
+        - samtools
+        - bedtools=2.29.1
+        - r-base =3.6.3
+        - r-lpsolveapi=5.5.2.0.17.7
+        - r-fitdistrplus=1.1.3
+        - r-numDeriv=2016.8.1.1
+        - r-plotrix
+        - r-mgcv
+        - r-data.table
+        - r-plyr
+        - ucsc-blat
+        - blast
+        - bicseq2-seg=0.7.2
+        - bicseq2-norm=0.2.4
+        - delly=0.7.6
+        - manta=1.1.0
+        - bcftools
diff --git a/workflow/scripts/InfoGenomeR_allele_graph.sh b/workflow/scripts/InfoGenomeR_allele_graph.sh
new file mode 100755
index 0000000..ac3488b
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_allele_graph.sh
@@ -0,0 +1,46 @@
+#!/bin/bash
+unset R_HOME
+mode=$1
+root_dir=`readlink -f $2`
+InfoGenomeR_dir=`readlink -f $3`
+output_dir=`readlink -f $4`
+
+ref=`readlink -f $5`
+ref_dir=`dirname $ref`
+ref_prefix=`basename $ref | awk -F "." '{print $1}'`
+
+export Haplotype_path=`readlink -f $6`
+
+
+if [[ $ref =~ "hg19" ]];then
+	export Ref_version=GRCh37
+fi
+
+bicseq_script=`which NBICseq-norm.pl`
+bicseq_dir=`dirname $bicseq_script`
+
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export BICseq2_path=$bicseq_dir
+export InfoGenomeR_lib=$LIB
+export PATH=$InfoGenomeR_lib/breakpoint_graph:$InfoGenomeR_lib/allele_graph:$InfoGenomeR_lib/haplotype_graph:$InfoGenomeR_lib/Eulerian:$PATH
+
+cd $root_dir
+mkdir -p log
+iter=`ls ${InfoGenomeR_dir} -l | grep -E 'iter[1-9]?[0-9]?[0-9]$' | awk 'BEGIN{max=0}{split($9,f,"iter"); if(max<f[2]) max=f[2];}END{print max}'`
+
+
+mkdir -p InfoGenomeR_allele_graph_job
+
+cp -r ${InfoGenomeR_dir}/iter$iter InfoGenomeR_allele_graph_job
+
+if [[ -s ${InfoGenomeR_dir}/exclude.bed ]];then
+	cp ${InfoGenomeR_dir}/exclude.bed InfoGenomeR_allele_graph_job
+fi
+
+
+if [[ $mode == "somatic" ]];then
+	allele_graph -m $mode -g $ref_dir\/$ref_prefix -o InfoGenomeR_allele_graph_job -t 23 -s germline_job/copy_numbers preprocess/snp/hom_snps.format preprocess/snp/het_snps.format &> log/allele_graph.log
+else
+        allele_graph -m $mode -g $ref_dir\/$ref_prefix -o InfoGenomeR_allele_graph_job -t 23 preprocess/snp/hom_snps.format preprocess/snp/het_snps.format &> log/allele_graph.log
+fi
+
diff --git a/workflow/scripts/InfoGenomeR_breakpoint.sh b/workflow/scripts/InfoGenomeR_breakpoint.sh
new file mode 100755
index 0000000..51efc63
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_breakpoint.sh
@@ -0,0 +1,41 @@
+#!/bin/bash
+unset R_HOME
+mode=$1
+root_dir=`readlink -f $2`
+preprocess_dir=`readlink -f $3`
+output_dir=`readlink -f $4`
+
+ref=`readlink -f $5`
+ref_dir=`dirname $ref`
+ref_prefix=`basename $ref | awk -F "." '{print $1}'`
+
+lambda_ini=$6
+lambda_fi=$7
+min_ploidy=$8
+max_ploidy=$9
+cancer_type="${10}"
+
+if [[ $ref =~ "hg19" ]];then
+	export Ref_version=GRCh37
+fi
+
+bicseq_script=`which NBICseq-norm.pl`
+bicseq_dir=`dirname $bicseq_script`
+
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export BICseq2_path=$bicseq_dir
+export InfoGenomeR_lib=$LIB
+export PATH=$InfoGenomeR_lib/breakpoint_graph:$InfoGenomeR_lib/allele_graph:$InfoGenomeR_lib/haplotype_graph:$InfoGenomeR_lib/Eulerian:$PATH
+
+
+cd $root_dir
+mkdir -p log
+
+if [[ $mode == "somatic" ]];then
+	breakpoint_graph -m germline ${preprocess_dir}/delly/germline.filtered.format  -o germline_job ${preprocess_dir}/bicseq/cn_norm_germ &> log/germline_job.log
+	breakpoint_graph -m somatic ${preprocess_dir}\/SVs ${preprocess_dir}/bicseq/cn_norm -t "$cancer_type" -i $lambda_ini -f $lambda_fi -n $min_ploidy -x $max_ploidy -g $ref_dir\/$ref_prefix  -c ${preprocess_dir}/bicseq/cn_norm_germ -s germline_job/copy_numbers -o InfoGenomeR_job &> log/InfoGenomeR_job.log
+else
+	breakpoint_graph -m total ${preprocess_dir}\/SVs ${preprocess_dir}/bicseq/cn_norm -t "$cancer_type" -i $lambda_ini -f $lambda_fi -n $min_ploidy -x $max_ploidy -g $ref_dir\/$ref_prefix -o InfoGenomeR_job &> log/InfoGenomeR_job.log
+fi
+
+
diff --git a/workflow/scripts/InfoGenomeR_breakpoint_simplification.sh b/workflow/scripts/InfoGenomeR_breakpoint_simplification.sh
new file mode 100755
index 0000000..729a0a6
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_breakpoint_simplification.sh
@@ -0,0 +1,50 @@
+#!/bin/bash
+unset R_HOME
+mode=$1
+root_dir=`readlink -f $2`
+InfoGenomeR_dir=`readlink -f $3`
+output_dir=`readlink -f $4`
+
+ref=`readlink -f $5`
+ref_dir=`dirname $ref`
+ref_prefix=`basename $ref | awk -F "." '{print $1}'`
+
+lambda_ini=$6
+lambda_fi=$7
+min_ploidy=$8
+max_ploidy=$9
+cancer_type="${10}"
+
+
+
+if [[ $ref =~ "hg19" ]];then
+	export Ref_version=GRCh37
+fi
+
+bicseq_script=`which NBICseq-norm.pl`
+bicseq_dir=`dirname $bicseq_script`
+
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export BICseq2_path=$bicseq_dir
+export InfoGenomeR_lib=$LIB
+export PATH=$InfoGenomeR_lib/breakpoint_graph:$InfoGenomeR_lib/allele_graph:$InfoGenomeR_lib/haplotype_graph:$InfoGenomeR_lib/Eulerian:$PATH
+
+cd $root_dir
+mkdir -p log
+iter=`ls ${InfoGenomeR_dir} -l | grep -E 'iter[1-9]?[0-9]?[0-9]$' | awk 'BEGIN{max=0}{split($9,f,"iter"); if(max<f[2]) max=f[2];}END{print max}'`
+mkdir -p InfoGenomeR_simplification_job
+
+
+cp -r ${InfoGenomeR_dir}/iter$iter InfoGenomeR_simplification_job
+cp ${InfoGenomeR_dir}/SVs InfoGenomeR_simplification_job
+ln -s ${InfoGenomeR_dir}/cn_norm InfoGenomeR_simplification_job/cn_norm
+
+
+if [[ $mode == "somatic" ]];then
+	ln -s ${InfoGenomeR_dir}/cn_norm_germ InfoGenomeR_simplification_job/cn_norm_germ
+	breakpoint_graph -m simplification -o InfoGenomeR_simplification_job  -t "$cancer_type" -i $lambda_ini -f $lambda_fi -n $min_ploidy -x $max_ploidy InfoGenomeR_simplification_job/SVs InfoGenomeR_simplification_job/cn_norm -g $ref_dir\/$ref_prefix -c InfoGenomeR_simplification_job/cn_norm_germ -s germline_job/copy_numbers &>  log/simplification.log
+else
+       breakpoint_graph -m simplification -o InfoGenomeR_simplification_job  -t "$cancer_type" -i $lambda_ini -f $lambda_fi -n $min_ploidy -x $max_ploidy InfoGenomeR_simplification_job/SVs InfoGenomeR_simplification_job/cn_norm -g $ref_dir\/$ref_prefix  &>  log/simplification.log
+fi
+
+
diff --git a/workflow/scripts/InfoGenomeR_download.sh b/workflow/scripts/InfoGenomeR_download.sh
new file mode 100755
index 0000000..e6ec49d
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_download.sh
@@ -0,0 +1,38 @@
+#!/bin/bash
+cleanup() {
+        pkill -P $$
+        kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+        trap "
+            cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+
+
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export InfoGenomeR_lib=$LIB
+
+cd $InfoGenomeR_lib/humandb
+
+idx=0;
+
+if [[ ! -s hg19.CRG.50bp ]];then
+	tar -xvf hg19.CRG.50bp.tar.gz 
+fi
+
+if [[ ! -s GRCh37.repeatmasker ]];then
+	zcat GRCh37.repeatmasker.gz > GRCh37.repeatmasker 
+fi
+
+if [[ ! -s haplotype_1000G ]];then
+        wget -N https://zenodo.org/record/5105505/files/haplotype_1000G.tar.xz && tar -xvf haplotype_1000G.tar.xz
+fi
+
+
+if [[ ! -s ref ]];then
+        wget -N https://zenodo.org/records/11561156/files/ref.tar.gz
+        tar -xvf ref.tar.gz
+fi
diff --git a/workflow/scripts/InfoGenomeR_env.sh b/workflow/scripts/InfoGenomeR_env.sh
new file mode 100755
index 0000000..9472750
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_env.sh
@@ -0,0 +1,20 @@
+#!/bin/bash
+unset R_HOME
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+cd $LIB\/
+R CMD INSTALL ext/ABSOLUTE_1.0.6.tar.gz
+
+#cd ext
+#tar -xvf nbicseq-norm_v0.2.4.tar.gz
+#cd NBICseq-norm_v0.2.4
+#make
+#cd ../
+
+#tar -xvf nbicseq-seg_v0.7.2.tar.gz
+#cd NBICseq-seg_v0.7.2
+#make
+#cd ../
+
+
+cd $LIB
+make
diff --git a/workflow/scripts/InfoGenomeR_example_download.sh b/workflow/scripts/InfoGenomeR_example_download.sh
new file mode 100755
index 0000000..66d972b
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_example_download.sh
@@ -0,0 +1,24 @@
+#!/bin/bash
+cleanup() {
+        pkill -P $$
+        kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+        trap "
+            cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+
+
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export InfoGenomeR_lib=$LIB
+
+cd $InfoGenomeR_lib/example/fastq
+
+
+wget -N https://zenodo.org/records/11560492/files/normal1.fq.gz
+wget -N https://zenodo.org/records/11560492/files/normal2.fq.gz
+wget -N https://zenodo.org/records/11560492/files/tumor1.fq.gz
+wget -N https://zenodo.org/records/11560492/files/tumor2.fq.gz
diff --git a/workflow/scripts/InfoGenomeR_haplotype_graph.sh b/workflow/scripts/InfoGenomeR_haplotype_graph.sh
new file mode 100755
index 0000000..200d6c8
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_haplotype_graph.sh
@@ -0,0 +1,37 @@
+#!/bin/bash
+unset R_HOME
+root_dir=`readlink -f $1`
+InfoGenomeR_dir=`readlink -f $2`
+output_dir=`readlink -f $3`
+
+ref=`readlink -f $4`
+ref_dir=`dirname $ref`
+ref_prefix=`basename $ref | awk -F "." '{print $1}'`
+
+export Haplotype_path=`readlink -f $5`
+
+
+if [[ $ref =~ "hg19" ]];then
+	export Ref_version=GRCh37
+fi
+
+bicseq_script=`which NBICseq-norm.pl`
+bicseq_dir=`dirname $bicseq_script`
+
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export BICseq2_path=$bicseq_dir
+export InfoGenomeR_lib=$LIB
+export PATH=$InfoGenomeR_lib/breakpoint_graph:$InfoGenomeR_lib/allele_graph:$InfoGenomeR_lib/haplotype_graph:$InfoGenomeR_lib/Eulerian:$PATH
+
+cd $root_dir
+mkdir -p log
+iter=`ls ${InfoGenomeR_dir} -l | grep -E 'iter[1-9]?[0-9]?[0-9]$' | awk 'BEGIN{max=0}{split($9,f,"iter"); if(max<f[2]) max=f[2];}END{print max}'`
+
+
+mkdir -p InfoGenomeR_haplotype_graph_job
+
+cp -r ${InfoGenomeR_dir}/iter$iter InfoGenomeR_haplotype_graph_job
+
+haplotype_graph -o InfoGenomeR_haplotype_graph_job -t 6 &>  log/haplotype_graph.log
+
+
diff --git a/workflow/scripts/InfoGenomeR_karyotyping.sh b/workflow/scripts/InfoGenomeR_karyotyping.sh
new file mode 100755
index 0000000..3f8e72a
--- /dev/null
+++ b/workflow/scripts/InfoGenomeR_karyotyping.sh
@@ -0,0 +1,32 @@
+#!/bin/bash
+unset R_HOME
+root_dir=`readlink -f $1`
+InfoGenomeR_dir=`readlink -f $2`
+output_dir=`readlink -f $3`
+
+ref=`readlink -f $4`
+ref_dir=`dirname $ref`
+ref_prefix=`basename $ref | awk -F "." '{print $1}'`
+
+export Haplotype_path=`readlink -f $5`
+
+
+if [[ $ref =~ "hg19" ]];then
+	export Ref_version=GRCh37
+fi
+
+bicseq_script=`which NBICseq-norm.pl`
+bicseq_dir=`dirname $bicseq_script`
+
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export BICseq2_path=$bicseq_dir
+export InfoGenomeR_lib=$LIB
+export PATH=$InfoGenomeR_lib/breakpoint_graph:$InfoGenomeR_lib/allele_graph:$InfoGenomeR_lib/haplotype_graph:$InfoGenomeR_lib/Eulerian:$PATH
+
+cd $root_dir
+mkdir -p log
+
+karyotyping -o ${InfoGenomeR_dir} &> log/karyotyping.log
+cp -r ${InfoGenomeR_dir}/InfoGenomeR_output InfoGenomeR_output
+
+
diff --git a/workflow/scripts/bam_preprocessing.sh b/workflow/scripts/bam_preprocessing.sh
new file mode 100755
index 0000000..7a7c9fd
--- /dev/null
+++ b/workflow/scripts/bam_preprocessing.sh
@@ -0,0 +1,123 @@
+#!/bin/bash
+unset R_HOME
+cleanup() {
+        pkill -P $$
+        kill 0
+}
+
+for sig in INT QUIT HUP TERM; do
+        trap "
+            cleanup
+            trap - $sig EXIT
+            kill -s $sig "'"$$"' "$sig"
+done
+
+mode=$1
+bam_dir=`readlink -f $2`
+ref=`readlink -f $3`
+output_dir=`readlink -f $4`
+exclude_tsv=`readlink -f $5`
+norm_map=`readlink -f $6`
+
+
+if [[ $mode != "somatic" ]] && [[ $mode != "total" ]];then
+        echo "mode should be somatic or total"
+        exit 1
+fi
+
+
+mkdir -p $output_dir\/delly
+mkdir -p $output_dir\/manta
+mkdir -p $output_dir\/bicseq
+mkdir -p $output_dir\/snp
+declare -a pids;
+
+tumor_bam=$bam_dir\/tumor_sorted.bam
+normal_bam=$bam_dir\/normal_sorted.bam
+
+  
+LIB=`readlink -f ${BASH_SOURCE[0]} | awk '{n=split($1,f,"/"); for(i=1;i<=n-3;i++){printf "%s/", f[i]}}'`
+export bam_processing_lib=$LIB\/preprocessing
+
+
+if [[ $mode == "somatic" ]];then
+
+	cd $output_dir\/delly
+
+	$bam_processing_lib\/delly_somatic.sh $tumor_bam $normal_bam $ref 2 20 &>delly_somatic.log  &
+	pids[0]=$!;
+
+	echo "delly_somatic run... delly/log delly_somatic.log"
+
+	$bam_processing_lib\/delly.sh germline $normal_bam $ref $exclude_tsv 2 20 &>delly_germline.log &
+	pids[1]=$!;
+
+	echo "delly_germline run... delly/log delly_germline.log"
+
+	cd $output_dir\/manta
+	$bam_processing_lib\/manta_somatic.sh $tumor_bam $normal_bam $ref &>manta_somatic.log &
+	pids[2]=$!;
+
+	echo "manta_somatic run... manta/log manta_somatic.log"
+
+	cd $output_dir\/bicseq
+	$bam_processing_lib\/bicseq_preprocess.sh $tumor_bam $ref $norm_map cn_norm &>bicseq_preprocess.log &
+	pids[3]=$!;
+	echo "bicseq_preprocess run... bicseq_preprocess.log"
+
+	$bam_processing_lib\/bicseq_preprocess.sh $normal_bam $ref $norm_map cn_norm_germ &>bicseq_preprocess_germline.log &
+	pids[4]=$!;
+	echo "bicseq_preprocess_germline run... bicseq_preprocess_germline.log"
+
+	cd $output_dir\/snp
+	$bam_processing_lib\/het_SNP_detection_somatic.sh $ref $normal_bam $tumor_bam &> snp.log &
+	echo "snp run... snp.log"
+	pids[5]=$!;
+
+	wait ${pids[0]}
+	wait ${pids[1]}
+	wait ${pids[2]}
+	wait ${pids[3]}
+	wait ${pids[4]}
+	wait ${pids[5]}
+
+	cd $output_dir
+	cat delly/delly.format manta/manta.format > SVs
+        exit 0
+fi
+
+
+if [[ $mode == "total" ]];then
+        cd $output_dir\/delly
+
+        $bam_processing_lib\/delly.sh tumor $tumor_bam $ref $exclude_tsv 2 20 &>delly_total.log &
+        pids[0]=$!;
+
+        echo "delly_tumor run... delly/log delly_total.log"
+
+        cd $output_dir\/manta
+        $bam_processing_lib\/manta.sh $tumor_bam $ref &>manta_total.log &
+        pids[1]=$!;
+
+        echo "manta_somatic run... manta/log manta_total.log"
+
+        cd $output_dir\/bicseq
+        $bam_processing_lib\/bicseq_preprocess.sh $tumor_bam $ref $norm_map cn_norm &>bicseq_preprocess.log &
+        pids[2]=$!;
+        echo "bicseq_preprocess run... bicseq_preprocess.log"
+
+        cd $output_dir\/snp
+        $bam_processing_lib\/het_SNP_detection.sh $ref $tumor_bam &> snp.log &
+        echo "snp run... snp.log"
+        pids[3]=$!;
+
+        wait ${pids[0]}
+        wait ${pids[1]}
+        wait ${pids[2]}
+        wait ${pids[3]}
+
+        cd $output_dir
+        cat delly/delly.format manta/manta.format > SVs
+        exit 0
+
+fi
diff --git a/workflow/scripts/bwa_mapping.sh b/workflow/scripts/bwa_mapping.sh
new file mode 100755
index 0000000..d7dc9df
--- /dev/null
+++ b/workflow/scripts/bwa_mapping.sh
@@ -0,0 +1,43 @@
+#!/bin/bash
+unset R_HOME
+declare -a pids;
+
+mode=$1
+fastq_dir=`readlink -f $2`
+REF=`readlink -f $3`
+out_dir=`readlink -f $4`
+
+
+if [[ $mode != "somatic" ]] && [[ $mode != "total" ]];then
+	echo "mode should be somatic or total"
+	exit 1
+fi
+
+
+tumor_fq1=$fastq_dir\/tumor1.fq.gz
+tumor_fq2=$fastq_dir\/tumor2.fq.gz
+
+if [[ $mode == "somatic" ]];then
+	normal_fq1=$fastq_dir\/normal1.fq.gz
+	normal_fq2=$fastq_dir\/normal2.fq.gz
+fi
+
+mkdir -p $out_dir
+
+bwa mem -t 40 $REF $tumor_fq1 $tumor_fq2 | samtools view -bS > $out_dir\/tumor.bam
+samtools sort $out_dir\/tumor.bam -@ 40 > $out_dir\/tumor_sorted.bam
+samtools index $out_dir\/tumor_sorted.bam
+rm $out_dir\/tumor.bam
+
+if [[ $mode == "total" ]];then
+  echo "tumor read mapping finished"
+  exit 0
+fi
+
+bwa mem -t 40 $REF $normal_fq1 $normal_fq2 | samtools view -bS > $out_dir\/normal.bam
+samtools sort $out_dir\/normal.bam -@ 40 > $out_dir\/normal_sorted.bam
+samtools index $out_dir\/normal_sorted.bam 
+
+rm $out_dir\/normal.bam
+
+echo "normal read mapping finished"
